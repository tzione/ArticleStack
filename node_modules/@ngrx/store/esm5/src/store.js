import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { distinctUntilChanged, map, pluck } from 'rxjs/operators';
import { ActionsSubject } from './actions_subject';
import { ReducerManager } from './reducer_manager';
import { StateObservable } from './state';
import * as ɵngcc0 from '@angular/core';
var Store = /** @class */ (function (_super) {
    tslib_1.__extends(Store, _super);
    function Store(state$, actionsObserver, reducerManager) {
        var _this = _super.call(this) || this;
        _this.actionsObserver = actionsObserver;
        _this.reducerManager = reducerManager;
        _this.source = state$;
        return _this;
    }
    Store_1 = Store;
    Store.prototype.select = function (pathOrMapFn) {
        var _a;
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        return (_a = select).call.apply(_a, tslib_1.__spread([null, pathOrMapFn], paths))(this);
    };
    Store.prototype.lift = function (operator) {
        var store = new Store_1(this, this.actionsObserver, this.reducerManager);
        store.operator = operator;
        return store;
    };
    Store.prototype.dispatch = function (action) {
        this.actionsObserver.next(action);
    };
    Store.prototype.next = function (action) {
        this.actionsObserver.next(action);
    };
    Store.prototype.error = function (err) {
        this.actionsObserver.error(err);
    };
    Store.prototype.complete = function () {
        this.actionsObserver.complete();
    };
    Store.prototype.addReducer = function (key, reducer) {
        this.reducerManager.addReducer(key, reducer);
    };
    Store.prototype.removeReducer = function (key) {
        this.reducerManager.removeReducer(key);
    };
    var Store_1;
    Store = Store_1 = tslib_1.__decorate([
        tslib_1.__metadata("design:paramtypes", [StateObservable,
            ActionsSubject,
            ReducerManager])
    ], Store);
Store.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: Store, factory: function Store_Factory(t) { return new (t || Store)(ɵngcc0.ɵɵinject(StateObservable), ɵngcc0.ɵɵinject(ActionsSubject), ɵngcc0.ɵɵinject(ReducerManager)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(Store, [{
        type: Injectable
    }], function () { return [{ type: StateObservable }, { type: ActionsSubject }, { type: ReducerManager }]; }, { select: [], lift: [], dispatch: [], next: [], error: [], complete: [], addReducer: [], removeReducer: [] });
    return Store;
}(Observable));
export { Store };
export var STORE_PROVIDERS = [Store];
export function select(pathOrMapFn, propsOrPath) {
    var paths = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        paths[_i - 2] = arguments[_i];
    }
    return function selectOperator(source$) {
        var mapped$;
        if (typeof pathOrMapFn === 'string') {
            var pathSlices = tslib_1.__spread([propsOrPath], paths).filter(Boolean);
            mapped$ = source$.pipe(pluck.apply(void 0, tslib_1.__spread([pathOrMapFn], pathSlices)));
        }
        else if (typeof pathOrMapFn === 'function') {
            mapped$ = source$.pipe(map(function (source) { return pathOrMapFn(source, propsOrPath); }));
        }
        else {
            throw new TypeError("Unexpected type '" + typeof pathOrMapFn + "' in select operator," +
                " expected 'string' or 'function'");
        }
        return mapped$.pipe(distinctUntilChanged());
    };
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3R6aW9uL09uZURyaXZlL9ee16HXnteb15nXnS9Qcml2YXRlL0FydGljbGVTdGFjay1tYXN0ZXIvQXJ0aWNsZVN0YWNrLW1hc3Rlci9ub2RlX21vZHVsZXMvQG5ncngvc3RvcmUvZXNtNS9zcmMvc3RvcmUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0EwQzBDLEFBQ3JCOzs7Ozs7OzsrTkFJUCIsImZpbGUiOiJzdG9yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzbGliXzEgZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwLCBwbHVjayB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFjdGlvbnNTdWJqZWN0IH0gZnJvbSAnLi9hY3Rpb25zX3N1YmplY3QnO1xuaW1wb3J0IHsgUmVkdWNlck1hbmFnZXIgfSBmcm9tICcuL3JlZHVjZXJfbWFuYWdlcic7XG5pbXBvcnQgeyBTdGF0ZU9ic2VydmFibGUgfSBmcm9tICcuL3N0YXRlJztcbnZhciBTdG9yZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdG9yZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdG9yZShzdGF0ZSQsIGFjdGlvbnNPYnNlcnZlciwgcmVkdWNlck1hbmFnZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWN0aW9uc09ic2VydmVyID0gYWN0aW9uc09ic2VydmVyO1xuICAgICAgICBfdGhpcy5yZWR1Y2VyTWFuYWdlciA9IHJlZHVjZXJNYW5hZ2VyO1xuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzdGF0ZSQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3RvcmVfMSA9IFN0b3JlO1xuICAgIFN0b3JlLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAocGF0aE9yTWFwRm4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcGF0aHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHBhdGhzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EgPSBzZWxlY3QpLmNhbGwuYXBwbHkoX2EsIHRzbGliXzEuX19zcHJlYWQoW251bGwsIHBhdGhPck1hcEZuXSwgcGF0aHMpKSh0aGlzKTtcbiAgICB9O1xuICAgIFN0b3JlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdG9yZSA9IG5ldyBTdG9yZV8xKHRoaXMsIHRoaXMuYWN0aW9uc09ic2VydmVyLCB0aGlzLnJlZHVjZXJNYW5hZ2VyKTtcbiAgICAgICAgc3RvcmUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGlvbnNPYnNlcnZlci5uZXh0KGFjdGlvbik7XG4gICAgfTtcbiAgICBTdG9yZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zT2JzZXJ2ZXIubmV4dChhY3Rpb24pO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmFjdGlvbnNPYnNlcnZlci5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGlvbnNPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLmFkZFJlZHVjZXIgPSBmdW5jdGlvbiAoa2V5LCByZWR1Y2VyKSB7XG4gICAgICAgIHRoaXMucmVkdWNlck1hbmFnZXIuYWRkUmVkdWNlcihrZXksIHJlZHVjZXIpO1xuICAgIH07XG4gICAgU3RvcmUucHJvdG90eXBlLnJlbW92ZVJlZHVjZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMucmVkdWNlck1hbmFnZXIucmVtb3ZlUmVkdWNlcihrZXkpO1xuICAgIH07XG4gICAgdmFyIFN0b3JlXzE7XG4gICAgU3RvcmUgPSBTdG9yZV8xID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgSW5qZWN0YWJsZSgpLFxuICAgICAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RhdGVPYnNlcnZhYmxlLFxuICAgICAgICAgICAgQWN0aW9uc1N1YmplY3QsXG4gICAgICAgICAgICBSZWR1Y2VyTWFuYWdlcl0pXG4gICAgXSwgU3RvcmUpO1xuICAgIHJldHVybiBTdG9yZTtcbn0oT2JzZXJ2YWJsZSkpO1xuZXhwb3J0IHsgU3RvcmUgfTtcbmV4cG9ydCB2YXIgU1RPUkVfUFJPVklERVJTID0gW1N0b3JlXTtcbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3QocGF0aE9yTWFwRm4sIHByb3BzT3JQYXRoKSB7XG4gICAgdmFyIHBhdGhzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcGF0aHNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiBzZWxlY3RPcGVyYXRvcihzb3VyY2UkKSB7XG4gICAgICAgIHZhciBtYXBwZWQkO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhPck1hcEZuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHBhdGhTbGljZXMgPSB0c2xpYl8xLl9fc3ByZWFkKFtwcm9wc09yUGF0aF0sIHBhdGhzKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgICAgICBtYXBwZWQkID0gc291cmNlJC5waXBlKHBsdWNrLmFwcGx5KHZvaWQgMCwgdHNsaWJfMS5fX3NwcmVhZChbcGF0aE9yTWFwRm5dLCBwYXRoU2xpY2VzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXRoT3JNYXBGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWFwcGVkJCA9IHNvdXJjZSQucGlwZShtYXAoZnVuY3Rpb24gKHNvdXJjZSkgeyByZXR1cm4gcGF0aE9yTWFwRm4oc291cmNlLCBwcm9wc09yUGF0aCk7IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIHR5cGUgJ1wiICsgdHlwZW9mIHBhdGhPck1hcEZuICsgXCInIGluIHNlbGVjdCBvcGVyYXRvcixcIiArXG4gICAgICAgICAgICAgICAgXCIgZXhwZWN0ZWQgJ3N0cmluZycgb3IgJ2Z1bmN0aW9uJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwcGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgIH07XG59XG4iXX0=
{"version":3,"sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/@ngrx/store/fesm5/store.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCA2DiC,AACZ;;;;;;iFAEE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iCAiMU,AACZ;;;;;;;;;;;;;;;;;;6NAKE;;;;;;;;;;;;;;;;MAgBjB;;;;;mCAGwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wBAkCN,AACH;;;;;;;;;;;;2CAKP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAwDoB,AACb;;;;;;;;+NAIP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCA8VoB,AACb;;;;;;;;;;;;;;;;;;6TAOG;;;;;;;;;;;;;;;;;;qCAkBa,AAChB;;;;;;;;;;;;;;;;;kSAKM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA8GrB;;;;;;uIAGc","file":"store.js","sourcesContent":["/**\n * @license NgRx 8.5.1\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { __assign, __spread, __extends, __decorate, __metadata, __param, __read, __values } from 'tslib';\nimport { Injectable, InjectionToken, Inject, isDevMode, NgModule, Optional, SkipSelf, Injector } from '@angular/core';\nimport { BehaviorSubject, Observable, Subject, queueScheduler } from 'rxjs';\nimport { observeOn, withLatestFrom, scan, pluck, map, distinctUntilChanged } from 'rxjs/operators';\n\n/**\n * @description\n * Creates a configured `Creator` function that, when called, returns an object in the shape of the `Action` interface.\n *\n * Action creators reduce the explicitness of class-based action creators.\n *\n * @param type Describes the action that will be dispatched\n * @param config Additional metadata needed for the handling of the action.  See {@link createAction#usage-notes Usage Notes}.\n *\n * @usageNotes\n *\n * **Declaring an action creator**\n *\n * Without additional metadata:\n * ```ts\n * export const increment = createAction('[Counter] Increment');\n * ```\n * With additional metadata:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   props<{ user: User }>()\n * );\n * ```\n * With a function:\n * ```ts\n * export const loginSuccess = createAction(\n *   '[Auth/API] Login Success',\n *   (response: Response) => response.user\n * );\n * ```\n *\n * **Dispatching an action**\n *\n * Without additional metadata:\n * ```ts\n * store.dispatch(increment());\n * ```\n * With additional metadata:\n * ```ts\n * store.dispatch(loginSuccess({ user: newUser }));\n * ```\n *\n * **Referencing an action in a reducer**\n *\n * Using a switch statement:\n * ```ts\n * switch (action.type) {\n *   // ...\n *   case AuthApiActions.loginSuccess.type: {\n *     return {\n *       ...state,\n *       user: action.user\n *     };\n *   }\n * }\n * ```\n * Using a reducer creator:\n * ```ts\n * on(AuthApiActions.loginSuccess, (state, { user }) => ({ ...state, user }))\n * ```\n *\n *  **Referencing an action in an effect**\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(AuthApiActions.loginSuccess),\n *     // ...\n *   )\n * );\n * ```\n */\nfunction createAction(type, config) {\n    if (typeof config === 'function') {\n        return defineType(type, function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return (__assign({}, config.apply(void 0, __spread(args)), { type: type }));\n        });\n    }\n    var as = config ? config._as : 'empty';\n    switch (as) {\n        case 'empty':\n            return defineType(type, function () { return ({ type: type }); });\n        case 'props':\n            return defineType(type, function (props) { return (__assign({}, props, { type: type })); });\n        default:\n            throw new Error('Unexpected config.');\n    }\n}\nfunction props() {\n    // the return type does not match TypePropertyIsNotAllowed, so double casting\n    // is used.\n    return { _as: 'props', _p: undefined };\n}\nfunction union(creators) {\n    return undefined;\n}\nfunction defineType(type, creator) {\n    return Object.defineProperty(creator, 'type', {\n        value: type,\n        writable: false,\n    });\n}\n\nvar INIT = '@ngrx/store/init';\nvar ActionsSubject = /** @class */ (function (_super) {\n    __extends(ActionsSubject, _super);\n    function ActionsSubject() {\n        return _super.call(this, { type: INIT }) || this;\n    }\n    ActionsSubject.prototype.next = function (action) {\n        if (typeof action === 'function') {\n            throw new TypeError(\"\\n        Dispatch expected an object, instead it received a function.\\n        If you're using the createAction function, make sure to invoke the function\\n        before dispatching the action. For example, someAction should be someAction().\");\n        }\n        else if (typeof action === 'undefined') {\n            throw new TypeError(\"Actions must be objects\");\n        }\n        else if (typeof action.type === 'undefined') {\n            throw new TypeError(\"Actions must have a type property\");\n        }\n        _super.prototype.next.call(this, action);\n    };\n    ActionsSubject.prototype.complete = function () {\n        /* noop */\n    };\n    ActionsSubject.prototype.ngOnDestroy = function () {\n        _super.prototype.complete.call(this);\n    };\n    ActionsSubject = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [])\n    ], ActionsSubject);\n    return ActionsSubject;\n}(BehaviorSubject));\nvar ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\n\nvar _ROOT_STORE_GUARD = new InjectionToken('@ngrx/store Internal Root Guard');\nvar _INITIAL_STATE = new InjectionToken('@ngrx/store Internal Initial State');\nvar INITIAL_STATE = new InjectionToken('@ngrx/store Initial State');\nvar REDUCER_FACTORY = new InjectionToken('@ngrx/store Reducer Factory');\nvar _REDUCER_FACTORY = new InjectionToken('@ngrx/store Internal Reducer Factory Provider');\nvar INITIAL_REDUCERS = new InjectionToken('@ngrx/store Initial Reducers');\nvar _INITIAL_REDUCERS = new InjectionToken('@ngrx/store Internal Initial Reducers');\nvar STORE_FEATURES = new InjectionToken('@ngrx/store Store Features');\nvar _STORE_REDUCERS = new InjectionToken('@ngrx/store Internal Store Reducers');\nvar _FEATURE_REDUCERS = new InjectionToken('@ngrx/store Internal Feature Reducers');\nvar _FEATURE_CONFIGS = new InjectionToken('@ngrx/store Internal Feature Configs');\nvar _STORE_FEATURES = new InjectionToken('@ngrx/store Internal Store Features');\nvar _FEATURE_REDUCERS_TOKEN = new InjectionToken('@ngrx/store Internal Feature Reducers Token');\nvar FEATURE_REDUCERS = new InjectionToken('@ngrx/store Feature Reducers');\n/**\n * User-defined meta reducers from StoreModule.forRoot()\n */\nvar USER_PROVIDED_META_REDUCERS = new InjectionToken('@ngrx/store User Provided Meta Reducers');\n/**\n * Meta reducers defined either internally by @ngrx/store or by library authors\n */\nvar META_REDUCERS = new InjectionToken('@ngrx/store Meta Reducers');\n/**\n * Concats the user provided meta reducers and the meta reducers provided on the multi\n * injection token\n */\nvar _RESOLVED_META_REDUCERS = new InjectionToken('@ngrx/store Internal Resolved Meta Reducers');\n/**\n * Runtime checks defined by the user via an InjectionToken\n * Defaults to `_USER_RUNTIME_CHECKS`\n */\nvar USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store User Runtime Checks Config');\n/**\n * Runtime checks defined by the user via forRoot()\n */\nvar _USER_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal User Runtime Checks Config');\n/**\n * Runtime checks currently in use\n */\nvar _ACTIVE_RUNTIME_CHECKS = new InjectionToken('@ngrx/store Internal Runtime Checks');\n\nfunction combineReducers(reducers, initialState) {\n    if (initialState === void 0) { initialState = {}; }\n    var reducerKeys = Object.keys(reducers);\n    var finalReducers = {};\n    for (var i = 0; i < reducerKeys.length; i++) {\n        var key = reducerKeys[i];\n        if (typeof reducers[key] === 'function') {\n            finalReducers[key] = reducers[key];\n        }\n    }\n    var finalReducerKeys = Object.keys(finalReducers);\n    return function combination(state, action) {\n        state = state === undefined ? initialState : state;\n        var hasChanged = false;\n        var nextState = {};\n        for (var i = 0; i < finalReducerKeys.length; i++) {\n            var key = finalReducerKeys[i];\n            var reducer = finalReducers[key];\n            var previousStateForKey = state[key];\n            var nextStateForKey = reducer(previousStateForKey, action);\n            nextState[key] = nextStateForKey;\n            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n        }\n        return hasChanged ? nextState : state;\n    };\n}\nfunction omit(object, keyToRemove) {\n    return Object.keys(object)\n        .filter(function (key) { return key !== keyToRemove; })\n        .reduce(function (result, key) {\n        var _a;\n        return Object.assign(result, (_a = {}, _a[key] = object[key], _a));\n    }, {});\n}\nfunction compose() {\n    var functions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        functions[_i] = arguments[_i];\n    }\n    return function (arg) {\n        if (functions.length === 0) {\n            return arg;\n        }\n        var last = functions[functions.length - 1];\n        var rest = functions.slice(0, -1);\n        return rest.reduceRight(function (composed, fn) { return fn(composed); }, last(arg));\n    };\n}\nfunction createReducerFactory(reducerFactory, metaReducers) {\n    if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n        reducerFactory = compose.apply(null, __spread(metaReducers, [\n            reducerFactory,\n        ]));\n    }\n    return function (reducers, initialState) {\n        var reducer = reducerFactory(reducers);\n        return function (state, action) {\n            state = state === undefined ? initialState : state;\n            return reducer(state, action);\n        };\n    };\n}\nfunction createFeatureReducerFactory(metaReducers) {\n    var reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0\n        ? compose.apply(void 0, __spread(metaReducers)) : function (r) { return r; };\n    return function (reducer, initialState) {\n        reducer = reducerFactory(reducer);\n        return function (state, action) {\n            state = state === undefined ? initialState : state;\n            return reducer(state, action);\n        };\n    };\n}\n\nvar ReducerObservable = /** @class */ (function (_super) {\n    __extends(ReducerObservable, _super);\n    function ReducerObservable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ReducerObservable;\n}(Observable));\nvar ReducerManagerDispatcher = /** @class */ (function (_super) {\n    __extends(ReducerManagerDispatcher, _super);\n    function ReducerManagerDispatcher() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return ReducerManagerDispatcher;\n}(ActionsSubject));\nvar UPDATE = '@ngrx/store/update-reducers';\nvar ReducerManager = /** @class */ (function (_super) {\n    __extends(ReducerManager, _super);\n    function ReducerManager(dispatcher, initialState, reducers, reducerFactory) {\n        var _this = _super.call(this, reducerFactory(reducers, initialState)) || this;\n        _this.dispatcher = dispatcher;\n        _this.initialState = initialState;\n        _this.reducers = reducers;\n        _this.reducerFactory = reducerFactory;\n        return _this;\n    }\n    ReducerManager.prototype.addFeature = function (feature) {\n        this.addFeatures([feature]);\n    };\n    ReducerManager.prototype.addFeatures = function (features) {\n        var reducers = features.reduce(function (reducerDict, _a) {\n            var reducers = _a.reducers, reducerFactory = _a.reducerFactory, metaReducers = _a.metaReducers, initialState = _a.initialState, key = _a.key;\n            var reducer = typeof reducers === 'function'\n                ? createFeatureReducerFactory(metaReducers)(reducers, initialState)\n                : createReducerFactory(reducerFactory, metaReducers)(reducers, initialState);\n            reducerDict[key] = reducer;\n            return reducerDict;\n        }, {});\n        this.addReducers(reducers);\n    };\n    ReducerManager.prototype.removeFeature = function (feature) {\n        this.removeFeatures([feature]);\n    };\n    ReducerManager.prototype.removeFeatures = function (features) {\n        this.removeReducers(features.map(function (p) { return p.key; }));\n    };\n    ReducerManager.prototype.addReducer = function (key, reducer) {\n        var _a;\n        this.addReducers((_a = {}, _a[key] = reducer, _a));\n    };\n    ReducerManager.prototype.addReducers = function (reducers) {\n        this.reducers = __assign({}, this.reducers, reducers);\n        this.updateReducers(Object.keys(reducers));\n    };\n    ReducerManager.prototype.removeReducer = function (featureKey) {\n        this.removeReducers([featureKey]);\n    };\n    ReducerManager.prototype.removeReducers = function (featureKeys) {\n        var _this = this;\n        featureKeys.forEach(function (key) {\n            _this.reducers = omit(_this.reducers, key) /*TODO(#823)*/;\n        });\n        this.updateReducers(featureKeys);\n    };\n    ReducerManager.prototype.updateReducers = function (featureKeys) {\n        this.next(this.reducerFactory(this.reducers, this.initialState));\n        this.dispatcher.next({\n            type: UPDATE,\n            features: featureKeys,\n        });\n    };\n    ReducerManager.prototype.ngOnDestroy = function () {\n        this.complete();\n    };\n    ReducerManager = __decorate([\n        Injectable(),\n        __param(1, Inject(INITIAL_STATE)),\n        __param(2, Inject(INITIAL_REDUCERS)),\n        __param(3, Inject(REDUCER_FACTORY)),\n        __metadata(\"design:paramtypes\", [ReducerManagerDispatcher, Object, Object, Function])\n    ], ReducerManager);\n    return ReducerManager;\n}(BehaviorSubject));\nvar REDUCER_MANAGER_PROVIDERS = [\n    ReducerManager,\n    { provide: ReducerObservable, useExisting: ReducerManager },\n    { provide: ReducerManagerDispatcher, useExisting: ActionsSubject },\n];\n\nvar ScannedActionsSubject = /** @class */ (function (_super) {\n    __extends(ScannedActionsSubject, _super);\n    function ScannedActionsSubject() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ScannedActionsSubject.prototype.ngOnDestroy = function () {\n        this.complete();\n    };\n    ScannedActionsSubject = __decorate([\n        Injectable()\n    ], ScannedActionsSubject);\n    return ScannedActionsSubject;\n}(Subject));\nvar SCANNED_ACTIONS_SUBJECT_PROVIDERS = [\n    ScannedActionsSubject,\n];\n\nvar StateObservable = /** @class */ (function (_super) {\n    __extends(StateObservable, _super);\n    function StateObservable() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return StateObservable;\n}(Observable));\nvar State = /** @class */ (function (_super) {\n    __extends(State, _super);\n    function State(actions$, reducer$, scannedActions, initialState) {\n        var _this = _super.call(this, initialState) || this;\n        var actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n        var withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n        var seed = { state: initialState };\n        var stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n        _this.stateSubscription = stateAndAction$.subscribe(function (_a) {\n            var state = _a.state, action = _a.action;\n            _this.next(state);\n            scannedActions.next(action);\n        });\n        return _this;\n    }\n    State.prototype.ngOnDestroy = function () {\n        this.stateSubscription.unsubscribe();\n        this.complete();\n    };\n    State.INIT = INIT;\n    State = __decorate([\n        Injectable(),\n        __param(3, Inject(INITIAL_STATE)),\n        __metadata(\"design:paramtypes\", [ActionsSubject,\n            ReducerObservable,\n            ScannedActionsSubject, Object])\n    ], State);\n    return State;\n}(BehaviorSubject));\nfunction reduceState(stateActionPair, _a) {\n    if (stateActionPair === void 0) { stateActionPair = { state: undefined }; }\n    var _b = __read(_a, 2), action = _b[0], reducer = _b[1];\n    var state = stateActionPair.state;\n    return { state: reducer(state, action), action: action };\n}\nvar STATE_PROVIDERS = [\n    State,\n    { provide: StateObservable, useExisting: State },\n];\n\nvar Store = /** @class */ (function (_super) {\n    __extends(Store, _super);\n    function Store(state$, actionsObserver, reducerManager) {\n        var _this = _super.call(this) || this;\n        _this.actionsObserver = actionsObserver;\n        _this.reducerManager = reducerManager;\n        _this.source = state$;\n        return _this;\n    }\n    Store_1 = Store;\n    Store.prototype.select = function (pathOrMapFn) {\n        var _a;\n        var paths = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            paths[_i - 1] = arguments[_i];\n        }\n        return (_a = select).call.apply(_a, __spread([null, pathOrMapFn], paths))(this);\n    };\n    Store.prototype.lift = function (operator) {\n        var store = new Store_1(this, this.actionsObserver, this.reducerManager);\n        store.operator = operator;\n        return store;\n    };\n    Store.prototype.dispatch = function (action) {\n        this.actionsObserver.next(action);\n    };\n    Store.prototype.next = function (action) {\n        this.actionsObserver.next(action);\n    };\n    Store.prototype.error = function (err) {\n        this.actionsObserver.error(err);\n    };\n    Store.prototype.complete = function () {\n        this.actionsObserver.complete();\n    };\n    Store.prototype.addReducer = function (key, reducer) {\n        this.reducerManager.addReducer(key, reducer);\n    };\n    Store.prototype.removeReducer = function (key) {\n        this.reducerManager.removeReducer(key);\n    };\n    var Store_1;\n    Store = Store_1 = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [StateObservable,\n            ActionsSubject,\n            ReducerManager])\n    ], Store);\n    return Store;\n}(Observable));\nvar STORE_PROVIDERS = [Store];\nfunction select(pathOrMapFn, propsOrPath) {\n    var paths = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        paths[_i - 2] = arguments[_i];\n    }\n    return function selectOperator(source$) {\n        var mapped$;\n        if (typeof pathOrMapFn === 'string') {\n            var pathSlices = __spread([propsOrPath], paths).filter(Boolean);\n            mapped$ = source$.pipe(pluck.apply(void 0, __spread([pathOrMapFn], pathSlices)));\n        }\n        else if (typeof pathOrMapFn === 'function') {\n            mapped$ = source$.pipe(map(function (source) { return pathOrMapFn(source, propsOrPath); }));\n        }\n        else {\n            throw new TypeError(\"Unexpected type '\" + typeof pathOrMapFn + \"' in select operator,\" +\n                \" expected 'string' or 'function'\");\n        }\n        return mapped$.pipe(distinctUntilChanged());\n    };\n}\n\nfunction isEqualCheck(a, b) {\n    return a === b;\n}\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n    for (var i = 0; i < args.length; i++) {\n        if (!comparator(args[i], lastArguments[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction resultMemoize(projectionFn, isResultEqual) {\n    return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\nfunction defaultMemoize(projectionFn, isArgumentsEqual, isResultEqual) {\n    if (isArgumentsEqual === void 0) { isArgumentsEqual = isEqualCheck; }\n    if (isResultEqual === void 0) { isResultEqual = isEqualCheck; }\n    var lastArguments = null;\n    // tslint:disable-next-line:no-any anything could be the result.\n    var lastResult = null;\n    var overrideResult;\n    function reset() {\n        lastArguments = null;\n        lastResult = null;\n    }\n    function setResult(result) {\n        if (result === void 0) { result = undefined; }\n        overrideResult = result;\n    }\n    // tslint:disable-next-line:no-any anything could be the result.\n    function memoized() {\n        if (overrideResult !== undefined) {\n            return overrideResult;\n        }\n        if (!lastArguments) {\n            lastResult = projectionFn.apply(null, arguments);\n            lastArguments = arguments;\n            return lastResult;\n        }\n        if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n            return lastResult;\n        }\n        var newResult = projectionFn.apply(null, arguments);\n        lastArguments = arguments;\n        if (isResultEqual(lastResult, newResult)) {\n            return lastResult;\n        }\n        lastResult = newResult;\n        return newResult;\n    }\n    return { memoized: memoized, reset: reset, setResult: setResult };\n}\nfunction createSelector() {\n    var input = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        input[_i] = arguments[_i];\n    }\n    return createSelectorFactory(defaultMemoize).apply(void 0, __spread(input));\n}\nfunction defaultStateFn(state, selectors, props, memoizedProjector) {\n    if (props === undefined) {\n        var args_1 = selectors.map(function (fn) { return fn(state); });\n        return memoizedProjector.memoized.apply(null, args_1);\n    }\n    var args = selectors.map(function (fn) {\n        return fn(state, props);\n    });\n    return memoizedProjector.memoized.apply(null, __spread(args, [props]));\n}\nfunction createSelectorFactory(memoize, options) {\n    if (options === void 0) { options = {\n        stateFn: defaultStateFn,\n    }; }\n    return function () {\n        var input = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            input[_i] = arguments[_i];\n        }\n        var args = input;\n        if (Array.isArray(args[0])) {\n            var _a = __read(args), head = _a[0], tail = _a.slice(1);\n            args = __spread(head, tail);\n        }\n        var selectors = args.slice(0, args.length - 1);\n        var projector = args[args.length - 1];\n        var memoizedSelectors = selectors.filter(function (selector) {\n            return selector.release && typeof selector.release === 'function';\n        });\n        var memoizedProjector = memoize(function () {\n            var selectors = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                selectors[_i] = arguments[_i];\n            }\n            return projector.apply(null, selectors);\n        });\n        var memoizedState = defaultMemoize(function (state, props) {\n            return options.stateFn.apply(null, [\n                state,\n                selectors,\n                props,\n                memoizedProjector,\n            ]);\n        });\n        function release() {\n            memoizedState.reset();\n            memoizedProjector.reset();\n            memoizedSelectors.forEach(function (selector) { return selector.release(); });\n        }\n        return Object.assign(memoizedState.memoized, {\n            release: release,\n            projector: memoizedProjector.memoized,\n            setResult: memoizedState.setResult,\n        });\n    };\n}\nfunction createFeatureSelector(featureName) {\n    return createSelector(function (state) {\n        var featureState = state[featureName];\n        if (isDevMode() && !(featureName in state)) {\n            console.warn(\"@ngrx/store: The feature name \\\"\" + featureName + \"\\\" does \" +\n                'not exist in the state, therefore createFeatureSelector ' +\n                'cannot access it.  Be sure it is imported in a loaded module ' +\n                (\"using StoreModule.forRoot('\" + featureName + \"', ...) or \") +\n                (\"StoreModule.forFeature('\" + featureName + \"', ...).  If the default \") +\n                'state is intended to be undefined, as is the case with router ' +\n                'state, this development-only warning message can be ignored.');\n        }\n        return featureState;\n    }, function (featureState) { return featureState; });\n}\n\nfunction isUndefined(target) {\n    return target === undefined;\n}\nfunction isNull(target) {\n    return target === null;\n}\nfunction isArray(target) {\n    return Array.isArray(target);\n}\nfunction isString(target) {\n    return typeof target === 'string';\n}\nfunction isBoolean(target) {\n    return typeof target === 'boolean';\n}\nfunction isNumber(target) {\n    return typeof target === 'number';\n}\nfunction isObjectLike(target) {\n    return typeof target === 'object' && target !== null;\n}\nfunction isObject(target) {\n    return isObjectLike(target) && !isArray(target);\n}\nfunction isPlainObject(target) {\n    if (!isObject(target)) {\n        return false;\n    }\n    var targetPrototype = Object.getPrototypeOf(target);\n    return targetPrototype === Object.prototype || targetPrototype === null;\n}\nfunction isFunction(target) {\n    return typeof target === 'function';\n}\nfunction hasOwnProperty(target, propertyName) {\n    return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\n\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n    return function (state, action) {\n        var act = checks.action ? freeze(action) : action;\n        var nextState = reducer(state, act);\n        return checks.state ? freeze(nextState) : nextState;\n    };\n}\nfunction freeze(target) {\n    Object.freeze(target);\n    var targetIsFunction = isFunction(target);\n    Object.getOwnPropertyNames(target).forEach(function (prop) {\n        if (hasOwnProperty(target, prop) &&\n            (targetIsFunction\n                ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments'\n                : true)) {\n            var propValue = target[prop];\n            if ((isObjectLike(propValue) || isFunction(propValue)) &&\n                !Object.isFrozen(propValue)) {\n                freeze(propValue);\n            }\n        }\n    });\n    return target;\n}\n\nfunction serializationCheckMetaReducer(reducer, checks) {\n    return function (state, action) {\n        if (checks.action) {\n            var unserializableAction = getUnserializable(action);\n            throwIfUnserializable(unserializableAction, 'action');\n        }\n        var nextState = reducer(state, action);\n        if (checks.state) {\n            var unserializableState = getUnserializable(nextState);\n            throwIfUnserializable(unserializableState, 'state');\n        }\n        return nextState;\n    };\n}\nfunction getUnserializable(target, path) {\n    if (path === void 0) { path = []; }\n    // Guard against undefined and null, e.g. a reducer that returns undefined\n    if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n        return {\n            path: ['root'],\n            value: target,\n        };\n    }\n    var keys = Object.keys(target);\n    return keys.reduce(function (result, key) {\n        if (result) {\n            return result;\n        }\n        var value = target[key];\n        if (isUndefined(value) ||\n            isNull(value) ||\n            isNumber(value) ||\n            isBoolean(value) ||\n            isString(value) ||\n            isArray(value)) {\n            return false;\n        }\n        if (isPlainObject(value)) {\n            return getUnserializable(value, __spread(path, [key]));\n        }\n        return {\n            path: __spread(path, [key]),\n            value: value,\n        };\n    }, false);\n}\nfunction throwIfUnserializable(unserializable, context) {\n    if (unserializable === false) {\n        return;\n    }\n    var unserializablePath = unserializable.path.join('.');\n    var error = new Error(\"Detected unserializable \" + context + \" at \\\"\" + unserializablePath + \"\\\"\");\n    error.value = unserializable.value;\n    error.unserializablePath = unserializablePath;\n    throw error;\n}\n\nfunction createActiveRuntimeChecks(runtimeChecks) {\n    if (isDevMode()) {\n        if (runtimeChecks === undefined) {\n            console.warn('@ngrx/store: runtime checks are currently opt-in but will be the default in the next major version with the possibility to opt-out, see https://ngrx.io/guide/migration/v8 for more information.');\n        }\n        return __assign({ strictStateSerializability: false, strictActionSerializability: false, strictStateImmutability: false, strictActionImmutability: false }, runtimeChecks);\n    }\n    return {\n        strictStateSerializability: false,\n        strictActionSerializability: false,\n        strictStateImmutability: false,\n        strictActionImmutability: false,\n    };\n}\nfunction createSerializationCheckMetaReducer(_a) {\n    var strictActionSerializability = _a.strictActionSerializability, strictStateSerializability = _a.strictStateSerializability;\n    return function (reducer) {\n        return strictActionSerializability || strictStateSerializability\n            ? serializationCheckMetaReducer(reducer, {\n                action: strictActionSerializability,\n                state: strictStateSerializability,\n            })\n            : reducer;\n    };\n}\nfunction createImmutabilityCheckMetaReducer(_a) {\n    var strictActionImmutability = _a.strictActionImmutability, strictStateImmutability = _a.strictStateImmutability;\n    return function (reducer) {\n        return strictActionImmutability || strictStateImmutability\n            ? immutabilityCheckMetaReducer(reducer, {\n                action: strictActionImmutability,\n                state: strictStateImmutability,\n            })\n            : reducer;\n    };\n}\nfunction provideRuntimeChecks(runtimeChecks) {\n    return [\n        {\n            provide: _USER_RUNTIME_CHECKS,\n            useValue: runtimeChecks,\n        },\n        {\n            provide: USER_RUNTIME_CHECKS,\n            useFactory: _runtimeChecksFactory,\n            deps: [_USER_RUNTIME_CHECKS],\n        },\n        {\n            provide: _ACTIVE_RUNTIME_CHECKS,\n            deps: [USER_RUNTIME_CHECKS],\n            useFactory: createActiveRuntimeChecks,\n        },\n        {\n            provide: META_REDUCERS,\n            multi: true,\n            deps: [_ACTIVE_RUNTIME_CHECKS],\n            useFactory: createImmutabilityCheckMetaReducer,\n        },\n        {\n            provide: META_REDUCERS,\n            multi: true,\n            deps: [_ACTIVE_RUNTIME_CHECKS],\n            useFactory: createSerializationCheckMetaReducer,\n        },\n    ];\n}\nfunction _runtimeChecksFactory(runtimeChecks) {\n    return runtimeChecks;\n}\n\nvar StoreRootModule = /** @class */ (function () {\n    function StoreRootModule(actions$, reducer$, scannedActions$, store, guard) {\n    }\n    StoreRootModule = __decorate([\n        NgModule({}),\n        __param(4, Optional()),\n        __param(4, Inject(_ROOT_STORE_GUARD)),\n        __metadata(\"design:paramtypes\", [ActionsSubject,\n            ReducerObservable,\n            ScannedActionsSubject,\n            Store, Object])\n    ], StoreRootModule);\n    return StoreRootModule;\n}());\nvar StoreFeatureModule = /** @class */ (function () {\n    function StoreFeatureModule(features, featureReducers, reducerManager, root) {\n        this.features = features;\n        this.featureReducers = featureReducers;\n        this.reducerManager = reducerManager;\n        var feats = features.map(function (feature, index) {\n            var featureReducerCollection = featureReducers.shift();\n            var reducers = featureReducerCollection /*TODO(#823)*/[index];\n            return __assign({}, feature, { reducers: reducers, initialState: _initialStateFactory(feature.initialState) });\n        });\n        reducerManager.addFeatures(feats);\n    }\n    StoreFeatureModule.prototype.ngOnDestroy = function () {\n        this.reducerManager.removeFeatures(this.features);\n    };\n    StoreFeatureModule = __decorate([\n        NgModule({}),\n        __param(0, Inject(_STORE_FEATURES)),\n        __param(1, Inject(FEATURE_REDUCERS)),\n        __metadata(\"design:paramtypes\", [Array, Array, ReducerManager,\n            StoreRootModule])\n    ], StoreFeatureModule);\n    return StoreFeatureModule;\n}());\nvar StoreModule = /** @class */ (function () {\n    function StoreModule() {\n    }\n    StoreModule.forRoot = function (reducers, config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: StoreRootModule,\n            providers: [\n                {\n                    provide: _ROOT_STORE_GUARD,\n                    useFactory: _provideForRootGuard,\n                    deps: [[Store, new Optional(), new SkipSelf()]],\n                },\n                { provide: _INITIAL_STATE, useValue: config.initialState },\n                {\n                    provide: INITIAL_STATE,\n                    useFactory: _initialStateFactory,\n                    deps: [_INITIAL_STATE],\n                },\n                { provide: _INITIAL_REDUCERS, useValue: reducers },\n                {\n                    provide: _STORE_REDUCERS,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS,\n                },\n                {\n                    provide: INITIAL_REDUCERS,\n                    deps: [Injector, _INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n                    useFactory: _createStoreReducers,\n                },\n                {\n                    provide: USER_PROVIDED_META_REDUCERS,\n                    useValue: config.metaReducers ? config.metaReducers : [],\n                },\n                {\n                    provide: _RESOLVED_META_REDUCERS,\n                    deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n                    useFactory: _concatMetaReducers,\n                },\n                {\n                    provide: _REDUCER_FACTORY,\n                    useValue: config.reducerFactory\n                        ? config.reducerFactory\n                        : combineReducers,\n                },\n                {\n                    provide: REDUCER_FACTORY,\n                    deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n                    useFactory: createReducerFactory,\n                },\n                ACTIONS_SUBJECT_PROVIDERS,\n                REDUCER_MANAGER_PROVIDERS,\n                SCANNED_ACTIONS_SUBJECT_PROVIDERS,\n                STATE_PROVIDERS,\n                STORE_PROVIDERS,\n                provideRuntimeChecks(config.runtimeChecks),\n            ],\n        };\n    };\n    StoreModule.forFeature = function (featureName, reducers, config) {\n        if (config === void 0) { config = {}; }\n        return {\n            ngModule: StoreFeatureModule,\n            providers: [\n                {\n                    provide: _FEATURE_CONFIGS,\n                    multi: true,\n                    useValue: config,\n                },\n                {\n                    provide: STORE_FEATURES,\n                    multi: true,\n                    useValue: {\n                        key: featureName,\n                        reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory\n                            ? config.reducerFactory\n                            : combineReducers,\n                        metaReducers: !(config instanceof InjectionToken) && config.metaReducers\n                            ? config.metaReducers\n                            : [],\n                        initialState: !(config instanceof InjectionToken) && config.initialState\n                            ? config.initialState\n                            : undefined,\n                    },\n                },\n                {\n                    provide: _STORE_FEATURES,\n                    deps: [Injector, _FEATURE_CONFIGS, STORE_FEATURES],\n                    useFactory: _createFeatureStore,\n                },\n                { provide: _FEATURE_REDUCERS, multi: true, useValue: reducers },\n                {\n                    provide: _FEATURE_REDUCERS_TOKEN,\n                    multi: true,\n                    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS,\n                },\n                {\n                    provide: FEATURE_REDUCERS,\n                    multi: true,\n                    deps: [\n                        Injector,\n                        _FEATURE_REDUCERS,\n                        [new Inject(_FEATURE_REDUCERS_TOKEN)],\n                    ],\n                    useFactory: _createFeatureReducers,\n                },\n            ],\n        };\n    };\n    StoreModule = __decorate([\n        NgModule({})\n    ], StoreModule);\n    return StoreModule;\n}());\nfunction _createStoreReducers(injector, reducers) {\n    return reducers instanceof InjectionToken ? injector.get(reducers) : reducers;\n}\nfunction _createFeatureStore(injector, configs, featureStores) {\n    return featureStores.map(function (feat, index) {\n        if (configs[index] instanceof InjectionToken) {\n            var conf = injector.get(configs[index]);\n            return {\n                key: feat.key,\n                reducerFactory: conf.reducerFactory\n                    ? conf.reducerFactory\n                    : combineReducers,\n                metaReducers: conf.metaReducers ? conf.metaReducers : [],\n                initialState: conf.initialState,\n            };\n        }\n        return feat;\n    });\n}\nfunction _createFeatureReducers(injector, reducerCollection) {\n    var reducers = reducerCollection.map(function (reducer) {\n        return reducer instanceof InjectionToken ? injector.get(reducer) : reducer;\n    });\n    return reducers;\n}\nfunction _initialStateFactory(initialState) {\n    if (typeof initialState === 'function') {\n        return initialState();\n    }\n    return initialState;\n}\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n    return metaReducers.concat(userProvidedMetaReducers);\n}\nfunction _provideForRootGuard(store) {\n    if (store) {\n        throw new TypeError(\"StoreModule.forRoot() called twice. Feature modules should use StoreModule.forFeature() instead.\");\n    }\n    return 'guarded';\n}\n\n/**\n * @description\n * Associates actions with a given state change function.\n * A state change function must be provided as the last parameter.\n *\n * @param args `ActionCreator`'s followed by a state change function.\n *\n * **To maintain type-safety**: pass 10 or less `ActionCreator`'s.\n * @returns an association of action types with a state change function.\n */\nfunction on() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var reducer = args.pop();\n    var types = args.reduce(function (result, creator) { return __spread(result, [creator.type]); }, []);\n    return { reducer: reducer, types: types };\n}\n/**\n * @description\n * Creates a reducer function to handle state transitions.\n *\n * Reducer creators reduce the explicitness of reducer functions with switch statements.\n *\n * @param initialState Provides a state value if the current state is `undefined`, as it is initially.\n * @param ons Associations between actions and state changes.\n * @returns A reducer function.\n *\n * @usageNotes\n *\n * - Must be used with `ActionCreator`'s (returned by `createAction`).  Cannot be used with class-based action creators.\n * - An action can be associated with multiple state change functions. In this case the functions will be executed in the specified order.\n * - The returned `ActionReducer` should additionally be returned from an exported `reducer` function.\n * This is because [function calls are not supported](https://angular.io/guide/aot-compiler#function-calls-are-not-supported) by the AOT compiler.\n *\n * **Declaring a reducer creator with an exported reducer function**\n *\n * ```ts\n * const featureReducer = createReducer(\n *   initialState,\n *   on(\n *     featureActions.actionOne,\n *     featureActions.actionTwo,\n *     (state, { updatedValue }) => ({ ...state, prop: updatedValue })\n *   ),\n *   on(featureActions.actionThree, () => initialState);\n * );\n *\n * export function reducer(state: State | undefined, action: Action) {\n *   return featureReducer(state, action);\n * }\n * ```\n */\nfunction createReducer(initialState) {\n    var e_1, _a;\n    var ons = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        ons[_i - 1] = arguments[_i];\n    }\n    var map = new Map();\n    var _loop_1 = function (on_1) {\n        var e_2, _a;\n        var _loop_2 = function (type) {\n            if (map.has(type)) {\n                var existingReducer_1 = map.get(type);\n                var newReducer = function (state, action) {\n                    return on_1.reducer(existingReducer_1(state, action), action);\n                };\n                map.set(type, newReducer);\n            }\n            else {\n                map.set(type, on_1.reducer);\n            }\n        };\n        try {\n            for (var _b = __values(on_1.types), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var type = _c.value;\n                _loop_2(type);\n            }\n        }\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_2) throw e_2.error; }\n        }\n    };\n    try {\n        for (var ons_1 = __values(ons), ons_1_1 = ons_1.next(); !ons_1_1.done; ons_1_1 = ons_1.next()) {\n            var on_1 = ons_1_1.value;\n            _loop_1(on_1);\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (ons_1_1 && !ons_1_1.done && (_a = ons_1.return)) _a.call(ons_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return function (state, action) {\n        if (state === void 0) { state = initialState; }\n        var reducer = map.get(action.type);\n        return reducer ? reducer(state, action) : state;\n    };\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ACTIONS_SUBJECT_PROVIDERS as ɵngrx_modules_store_store_c, REDUCER_MANAGER_PROVIDERS as ɵngrx_modules_store_store_d, _runtimeChecksFactory as ɵngrx_modules_store_store_bd, createActiveRuntimeChecks as ɵngrx_modules_store_store_z, createImmutabilityCheckMetaReducer as ɵngrx_modules_store_store_bb, createSerializationCheckMetaReducer as ɵngrx_modules_store_store_ba, provideRuntimeChecks as ɵngrx_modules_store_store_bc, SCANNED_ACTIONS_SUBJECT_PROVIDERS as ɵngrx_modules_store_store_e, isEqualCheck as ɵngrx_modules_store_store_f, STATE_PROVIDERS as ɵngrx_modules_store_store_g, STORE_PROVIDERS as ɵngrx_modules_store_store_b, _concatMetaReducers as ɵngrx_modules_store_store_x, _createFeatureReducers as ɵngrx_modules_store_store_v, _createFeatureStore as ɵngrx_modules_store_store_u, _createStoreReducers as ɵngrx_modules_store_store_t, _initialStateFactory as ɵngrx_modules_store_store_w, _provideForRootGuard as ɵngrx_modules_store_store_y, _ACTIVE_RUNTIME_CHECKS as ɵngrx_modules_store_store_s, _FEATURE_CONFIGS as ɵngrx_modules_store_store_n, _FEATURE_REDUCERS as ɵngrx_modules_store_store_m, _FEATURE_REDUCERS_TOKEN as ɵngrx_modules_store_store_p, _INITIAL_REDUCERS as ɵngrx_modules_store_store_k, _INITIAL_STATE as ɵngrx_modules_store_store_i, _REDUCER_FACTORY as ɵngrx_modules_store_store_j, _RESOLVED_META_REDUCERS as ɵngrx_modules_store_store_q, _ROOT_STORE_GUARD as ɵngrx_modules_store_store_h, _STORE_FEATURES as ɵngrx_modules_store_store_o, _STORE_REDUCERS as ɵngrx_modules_store_store_l, _USER_RUNTIME_CHECKS as ɵngrx_modules_store_store_r, createAction, props, union, Store, select, combineReducers, compose, createReducerFactory, ActionsSubject, INIT, ReducerManager, ReducerObservable, ReducerManagerDispatcher, UPDATE, ScannedActionsSubject, createSelector, createSelectorFactory, createFeatureSelector, defaultMemoize, defaultStateFn, resultMemoize, State, StateObservable, reduceState, INITIAL_STATE, REDUCER_FACTORY, INITIAL_REDUCERS, STORE_FEATURES, META_REDUCERS, FEATURE_REDUCERS, USER_PROVIDED_META_REDUCERS, USER_RUNTIME_CHECKS, StoreModule, StoreRootModule, StoreFeatureModule, on, createReducer };\n"]}
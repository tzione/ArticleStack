{"version":3,"sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/@ngrx/effects/fesm5/effects.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;sCAsKsC,AACjB;;;;;;;;;;oCAGL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAkFgB,AACX;;;;;;8GAEC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAgDU,AACX;;;;;;;mKAGC;;;;;;;;;;;;;;;;;;oCAkBc,AACf;;;;;;;;;;;;;;;;;;;;;;;;;;;;oYAUK;;;;;;;;;;;;uCAYa,AAClB;;;;;;;;;;;;;;;;;;;mTAMQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAyCvB;;;;;;6IAGgB","file":"effects.js","sourcesContent":["/**\n * @license NgRx 8.5.2\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { __assign, __spread, __extends, __decorate, __param, __metadata } from 'tslib';\nimport { compose, ScannedActionsSubject, Store, createAction, StoreRootModule, StoreFeatureModule } from '@ngrx/store';\nimport { merge, Observable, Subject, defer, Notification } from 'rxjs';\nimport { catchError, ignoreElements, materialize, map, filter, groupBy, mergeMap, exhaustMap, dematerialize, concatMap, finalize } from 'rxjs/operators';\nimport { Injectable, Inject, ErrorHandler, InjectionToken, NgModule, Optional, SkipSelf } from '@angular/core';\n\nvar DEFAULT_EFFECT_CONFIG = {\n    dispatch: true,\n    resubscribeOnError: true,\n};\nvar CREATE_EFFECT_METADATA_KEY = '__@ngrx/effects_create__';\n\n/**\n * @description\n * Creates an effect from an `Observable` and an `EffectConfig`.\n *\n * @param source A function which returns an `Observable`.\n * @param config A `Partial<EffectConfig>` to configure the effect.  By default, `dispatch` is true and `resubscribeOnError` is true.\n * @returns If `EffectConfig`#`dispatch` is true, returns `Observable<Action>`.  Else, returns `Observable<unknown>`.\n *\n * @usageNotes\n *\n * ** Mapping to a different action **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     map(() => FeatureActions.actionTwo())\n *   )\n * );\n * ```\n *\n *  ** Non-dispatching effects **\n * ```ts\n * effectName$ = createEffect(\n *   () => this.actions$.pipe(\n *     ofType(FeatureActions.actionOne),\n *     tap(() => console.log('Action One Dispatched'))\n *   ),\n *   { dispatch: false }\n *   // FeatureActions.actionOne is not dispatched\n * );\n * ```\n */\nfunction createEffect(source, config) {\n    var effect = source();\n    var value = __assign({}, DEFAULT_EFFECT_CONFIG, config);\n    Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n        value: value,\n    });\n    return effect;\n}\nfunction getCreateEffectMetadata(instance) {\n    var propertyNames = Object.getOwnPropertyNames(instance);\n    var metadata = propertyNames\n        .filter(function (propertyName) {\n        return instance[propertyName] &&\n            instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY);\n    })\n        .map(function (propertyName) {\n        var metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n        return __assign({ propertyName: propertyName }, metaData);\n    });\n    return metadata;\n}\n\nfunction getSourceForInstance(instance) {\n    return Object.getPrototypeOf(instance);\n}\n\nvar METADATA_KEY = '__@ngrx/effects__';\nfunction Effect(config) {\n    if (config === void 0) { config = {}; }\n    return function (target, propertyName) {\n        var metadata = __assign({}, DEFAULT_EFFECT_CONFIG, config, { // Overrides any defaults if values are provided\n            propertyName: propertyName });\n        addEffectMetadataEntry(target, metadata);\n    };\n}\nfunction getEffectDecoratorMetadata(instance) {\n    var effectsDecorators = compose(getEffectMetadataEntries, getSourceForInstance)(instance);\n    return effectsDecorators;\n}\n/**\n * Type guard to detemine whether METADATA_KEY is already present on the Class\n * constructor\n */\nfunction hasMetadataEntries(sourceProto) {\n    return sourceProto.constructor.hasOwnProperty(METADATA_KEY);\n}\n/** Add Effect Metadata to the Effect Class constructor under specific key */\nfunction addEffectMetadataEntry(sourceProto, metadata) {\n    if (hasMetadataEntries(sourceProto)) {\n        sourceProto.constructor[METADATA_KEY].push(metadata);\n    }\n    else {\n        Object.defineProperty(sourceProto.constructor, METADATA_KEY, {\n            value: [metadata],\n        });\n    }\n}\nfunction getEffectMetadataEntries(sourceProto) {\n    return hasMetadataEntries(sourceProto)\n        ? sourceProto.constructor[METADATA_KEY]\n        : [];\n}\n\nfunction getEffectsMetadata(instance) {\n    return getSourceMetadata(instance).reduce(function (acc, _a) {\n        var propertyName = _a.propertyName, dispatch = _a.dispatch, resubscribeOnError = _a.resubscribeOnError;\n        acc[propertyName] = { dispatch: dispatch, resubscribeOnError: resubscribeOnError };\n        return acc;\n    }, {});\n}\nfunction getSourceMetadata(instance) {\n    var effects = [\n        getEffectDecoratorMetadata,\n        getCreateEffectMetadata,\n    ];\n    return effects.reduce(function (sources, source) { return sources.concat(source(instance)); }, []);\n}\n\nfunction mergeEffects(sourceInstance, errorHandler) {\n    var sourceName = getSourceForInstance(sourceInstance).constructor.name;\n    var observables$ = getSourceMetadata(sourceInstance).map(function (_a) {\n        var propertyName = _a.propertyName, dispatch = _a.dispatch, resubscribeOnError = _a.resubscribeOnError;\n        var observable$ = typeof sourceInstance[propertyName] === 'function'\n            ? sourceInstance[propertyName]()\n            : sourceInstance[propertyName];\n        var resubscribable$ = resubscribeOnError\n            ? resubscribeInCaseOfError(observable$, errorHandler)\n            : observable$;\n        if (dispatch === false) {\n            return resubscribable$.pipe(ignoreElements());\n        }\n        var materialized$ = resubscribable$.pipe(materialize());\n        return materialized$.pipe(map(function (notification) { return ({\n            effect: sourceInstance[propertyName],\n            notification: notification,\n            propertyName: propertyName,\n            sourceName: sourceName,\n            sourceInstance: sourceInstance,\n        }); }));\n    });\n    return merge.apply(void 0, __spread(observables$));\n}\nfunction resubscribeInCaseOfError(observable$, errorHandler) {\n    return observable$.pipe(catchError(function (error) {\n        if (errorHandler)\n            errorHandler.handleError(error);\n        // Return observable that produces this particular effect\n        return resubscribeInCaseOfError(observable$, errorHandler);\n    }));\n}\n\nvar Actions = /** @class */ (function (_super) {\n    __extends(Actions, _super);\n    function Actions(source) {\n        var _this = _super.call(this) || this;\n        if (source) {\n            _this.source = source;\n        }\n        return _this;\n    }\n    Actions_1 = Actions;\n    Actions.prototype.lift = function (operator) {\n        var observable = new Actions_1();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    var Actions_1;\n    Actions = Actions_1 = __decorate([\n        Injectable(),\n        __param(0, Inject(ScannedActionsSubject)),\n        __metadata(\"design:paramtypes\", [Observable])\n    ], Actions);\n    return Actions;\n}(Observable));\nfunction ofType() {\n    var allowedTypes = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        allowedTypes[_i] = arguments[_i];\n    }\n    return filter(function (action) {\n        return allowedTypes.some(function (typeOrActionCreator) {\n            if (typeof typeOrActionCreator === 'string') {\n                // Comparing the string to type\n                return typeOrActionCreator === action.type;\n            }\n            // We are filtering by ActionCreator\n            return typeOrActionCreator.type === action.type;\n        });\n    });\n}\n\nfunction reportInvalidActions(output, reporter) {\n    if (output.notification.kind === 'N') {\n        var action = output.notification.value;\n        var isInvalidAction = !isAction(action);\n        if (isInvalidAction) {\n            reporter.handleError(new Error(\"Effect \" + getEffectName(output) + \" dispatched an invalid action: \" + stringify(action)));\n        }\n    }\n}\nfunction isAction(action) {\n    return (typeof action !== 'function' &&\n        action &&\n        action.type &&\n        typeof action.type === 'string');\n}\nfunction getEffectName(_a) {\n    var propertyName = _a.propertyName, sourceInstance = _a.sourceInstance, sourceName = _a.sourceName;\n    var isMethod = typeof sourceInstance[propertyName] === 'function';\n    return \"\\\"\" + sourceName + \".\" + String(propertyName) + (isMethod ? '()' : '') + \"\\\"\";\n}\nfunction stringify(action) {\n    try {\n        return JSON.stringify(action);\n    }\n    catch (_a) {\n        return action;\n    }\n}\n\nvar onIdentifyEffectsKey = 'ngrxOnIdentifyEffects';\nvar onRunEffectsKey = 'ngrxOnRunEffects';\nvar onInitEffects = 'ngrxOnInitEffects';\n\nvar EffectSources = /** @class */ (function (_super) {\n    __extends(EffectSources, _super);\n    function EffectSources(errorHandler, store) {\n        var _this = _super.call(this) || this;\n        _this.errorHandler = errorHandler;\n        _this.store = store;\n        return _this;\n    }\n    EffectSources.prototype.addEffects = function (effectSourceInstance) {\n        this.next(effectSourceInstance);\n        if (onInitEffects in effectSourceInstance &&\n            typeof effectSourceInstance[onInitEffects] === 'function') {\n            this.store.dispatch(effectSourceInstance[onInitEffects]());\n        }\n    };\n    /**\n     * @internal\n     */\n    EffectSources.prototype.toActions = function () {\n        var _this = this;\n        return this.pipe(groupBy(getSourceForInstance), mergeMap(function (source$) { return source$.pipe(groupBy(effectsInstance)); }), mergeMap(function (source$) {\n            return source$.pipe(exhaustMap(resolveEffectSource(_this.errorHandler)), map(function (output) {\n                reportInvalidActions(output, _this.errorHandler);\n                return output.notification;\n            }), filter(function (notification) {\n                return notification.kind === 'N';\n            }), dematerialize());\n        }));\n    };\n    EffectSources = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [ErrorHandler, Store])\n    ], EffectSources);\n    return EffectSources;\n}(Subject));\nfunction effectsInstance(sourceInstance) {\n    if (onIdentifyEffectsKey in sourceInstance &&\n        typeof sourceInstance[onIdentifyEffectsKey] === 'function') {\n        return sourceInstance[onIdentifyEffectsKey]();\n    }\n    return '';\n}\nfunction resolveEffectSource(errorHandler) {\n    return function (sourceInstance) {\n        var mergedEffects$ = mergeEffects(sourceInstance, errorHandler);\n        if (isOnRunEffects(sourceInstance)) {\n            return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n        }\n        return mergedEffects$;\n    };\n}\nfunction isOnRunEffects(sourceInstance) {\n    var source = getSourceForInstance(sourceInstance);\n    return (onRunEffectsKey in source && typeof source[onRunEffectsKey] === 'function');\n}\n\nvar _ROOT_EFFECTS_GUARD = new InjectionToken('@ngrx/effects Internal Root Guard');\nvar IMMEDIATE_EFFECTS = new InjectionToken('ngrx/effects: Immediate Effects');\nvar ROOT_EFFECTS = new InjectionToken('ngrx/effects: Root Effects');\nvar FEATURE_EFFECTS = new InjectionToken('ngrx/effects: Feature Effects');\n\nvar EffectsRunner = /** @class */ (function () {\n    function EffectsRunner(effectSources, store) {\n        this.effectSources = effectSources;\n        this.store = store;\n        this.effectsSubscription = null;\n    }\n    EffectsRunner.prototype.start = function () {\n        if (!this.effectsSubscription) {\n            this.effectsSubscription = this.effectSources\n                .toActions()\n                .subscribe(this.store);\n        }\n    };\n    EffectsRunner.prototype.ngOnDestroy = function () {\n        if (this.effectsSubscription) {\n            this.effectsSubscription.unsubscribe();\n            this.effectsSubscription = null;\n        }\n    };\n    EffectsRunner = __decorate([\n        Injectable(),\n        __metadata(\"design:paramtypes\", [EffectSources,\n            Store])\n    ], EffectsRunner);\n    return EffectsRunner;\n}());\n\nvar ROOT_EFFECTS_INIT = '@ngrx/effects/init';\nvar rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\nvar EffectsRootModule = /** @class */ (function () {\n    function EffectsRootModule(sources, runner, store, rootEffects, storeRootModule, storeFeatureModule, guard) {\n        this.sources = sources;\n        runner.start();\n        rootEffects.forEach(function (effectSourceInstance) {\n            return sources.addEffects(effectSourceInstance);\n        });\n        store.dispatch({ type: ROOT_EFFECTS_INIT });\n    }\n    EffectsRootModule.prototype.addEffects = function (effectSourceInstance) {\n        this.sources.addEffects(effectSourceInstance);\n    };\n    EffectsRootModule = __decorate([\n        NgModule({}),\n        __param(3, Inject(ROOT_EFFECTS)),\n        __param(4, Optional()),\n        __param(5, Optional()),\n        __param(6, Optional()),\n        __param(6, Inject(_ROOT_EFFECTS_GUARD)),\n        __metadata(\"design:paramtypes\", [EffectSources,\n            EffectsRunner,\n            Store, Array, StoreRootModule,\n            StoreFeatureModule, Object])\n    ], EffectsRootModule);\n    return EffectsRootModule;\n}());\n\nvar EffectsFeatureModule = /** @class */ (function () {\n    function EffectsFeatureModule(root, effectSourceGroups, storeRootModule, storeFeatureModule) {\n        effectSourceGroups.forEach(function (group) {\n            return group.forEach(function (effectSourceInstance) {\n                return root.addEffects(effectSourceInstance);\n            });\n        });\n    }\n    EffectsFeatureModule = __decorate([\n        NgModule({}),\n        __param(1, Inject(FEATURE_EFFECTS)),\n        __param(2, Optional()),\n        __param(3, Optional()),\n        __metadata(\"design:paramtypes\", [EffectsRootModule, Array, StoreRootModule,\n            StoreFeatureModule])\n    ], EffectsFeatureModule);\n    return EffectsFeatureModule;\n}());\n\nvar EffectsModule = /** @class */ (function () {\n    function EffectsModule() {\n    }\n    EffectsModule.forFeature = function (featureEffects) {\n        return {\n            ngModule: EffectsFeatureModule,\n            providers: [\n                featureEffects,\n                {\n                    provide: FEATURE_EFFECTS,\n                    multi: true,\n                    deps: featureEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    EffectsModule.forRoot = function (rootEffects) {\n        return {\n            ngModule: EffectsRootModule,\n            providers: [\n                {\n                    provide: _ROOT_EFFECTS_GUARD,\n                    useFactory: _provideForRootGuard,\n                    deps: [[EffectsRunner, new Optional(), new SkipSelf()]],\n                },\n                EffectsRunner,\n                EffectSources,\n                Actions,\n                rootEffects,\n                {\n                    provide: ROOT_EFFECTS,\n                    deps: rootEffects,\n                    useFactory: createSourceInstances,\n                },\n            ],\n        };\n    };\n    EffectsModule = __decorate([\n        NgModule({})\n    ], EffectsModule);\n    return EffectsModule;\n}());\nfunction createSourceInstances() {\n    var instances = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        instances[_i] = arguments[_i];\n    }\n    return instances;\n}\nfunction _provideForRootGuard(runner) {\n    if (runner) {\n        throw new TypeError(\"EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.\");\n    }\n    return 'guarded';\n}\n\nfunction act(\n/** Allow to take either config object or project/error functions */\nconfigOrProject, errorFn) {\n    var _a = typeof configOrProject === 'function'\n        ? {\n            project: configOrProject,\n            error: errorFn,\n            operator: concatMap,\n            complete: undefined,\n            unsubscribe: undefined,\n        }\n        : __assign({}, configOrProject, { operator: configOrProject.operator || concatMap }), project = _a.project, error = _a.error, complete = _a.complete, operator = _a.operator, unsubscribe = _a.unsubscribe;\n    return function (source) {\n        return defer(function () {\n            var subject = new Subject();\n            return merge(source.pipe(operator(function (input, index) {\n                return defer(function () {\n                    var completed = false;\n                    var errored = false;\n                    var projectedCount = 0;\n                    return project(input, index).pipe(materialize(), map(function (notification) {\n                        switch (notification.kind) {\n                            case 'E':\n                                errored = true;\n                                return new Notification(\n                                // TODO: remove any in RxJS 6.5\n                                'N', error(notification.error, input));\n                            case 'C':\n                                completed = true;\n                                return complete\n                                    ? new Notification(\n                                    // TODO: remove any in RxJS 6.5\n                                    'N', complete(projectedCount, input))\n                                    : undefined;\n                            default:\n                                ++projectedCount;\n                                return notification;\n                        }\n                    }), filter(function (n) { return n != null; }), dematerialize(), finalize(function () {\n                        if (!completed && !errored && unsubscribe) {\n                            subject.next(unsubscribe(projectedCount, input));\n                        }\n                    }));\n                });\n            })), subject);\n        });\n    };\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { getSourceMetadata as ɵngrx_modules_effects_effects_a, _provideForRootGuard as ɵngrx_modules_effects_effects_c, createSourceInstances as ɵngrx_modules_effects_effects_b, EffectsRunner as ɵngrx_modules_effects_effects_g, FEATURE_EFFECTS as ɵngrx_modules_effects_effects_f, ROOT_EFFECTS as ɵngrx_modules_effects_effects_e, _ROOT_EFFECTS_GUARD as ɵngrx_modules_effects_effects_d, createEffect, Effect, getEffectsMetadata, mergeEffects, Actions, ofType, EffectsModule, EffectSources, EffectsFeatureModule, ROOT_EFFECTS_INIT, rootEffectsInit, EffectsRootModule, act };\n"]}
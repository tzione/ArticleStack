import * as tslib_1 from "tslib";
import { Inject, InjectionToken, NgModule, ErrorHandler, } from '@angular/core';
import { NavigationCancel, NavigationError, NavigationEnd, Router, RoutesRecognized, NavigationStart, } from '@angular/router';
import { select, Store } from '@ngrx/store';
import { withLatestFrom } from 'rxjs/operators';
import { ROUTER_CANCEL, ROUTER_ERROR, ROUTER_NAVIGATED, ROUTER_NAVIGATION, ROUTER_REQUEST, } from './actions';
import { RouterStateSerializer, } from './serializers/base';
import { DefaultRouterStateSerializer, } from './serializers/default_serializer';
import { MinimalRouterStateSerializer } from './serializers/minimal_serializer';
import * as ɵngcc0 from '@angular/core';
export var NavigationActionTiming;
(function (NavigationActionTiming) {
    NavigationActionTiming[NavigationActionTiming["PreActivation"] = 1] = "PreActivation";
    NavigationActionTiming[NavigationActionTiming["PostActivation"] = 2] = "PostActivation";
})(NavigationActionTiming || (NavigationActionTiming = {}));
export var _ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Internal Configuration');
export var ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Configuration');
export var DEFAULT_ROUTER_FEATURENAME = 'router';
export function _createRouterConfig(config) {
    return tslib_1.__assign({ stateKey: DEFAULT_ROUTER_FEATURENAME, serializer: DefaultRouterStateSerializer, navigationActionTiming: NavigationActionTiming.PreActivation }, config);
}
var RouterTrigger;
(function (RouterTrigger) {
    RouterTrigger[RouterTrigger["NONE"] = 1] = "NONE";
    RouterTrigger[RouterTrigger["ROUTER"] = 2] = "ROUTER";
    RouterTrigger[RouterTrigger["STORE"] = 3] = "STORE";
})(RouterTrigger || (RouterTrigger = {}));
/**
 * Connects RouterModule with StoreModule.
 *
 * During the navigation, before any guards or resolvers run, the router will dispatch
 * a ROUTER_NAVIGATION action, which has the following signature:
 *
 * ```
 * export type RouterNavigationPayload = {
 *   routerState: SerializedRouterStateSnapshot,
 *   event: RoutesRecognized
 * }
 * ```
 *
 * Either a reducer or an effect can be invoked in response to this action.
 * If the invoked reducer throws, the navigation will be canceled.
 *
 * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be
 * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.
 *
 * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation
 * which can be used to restore the consistency of the store.
 *
 * Usage:
 *
 * ```typescript
 * @NgModule({
 *   declarations: [AppCmp, SimpleCmp],
 *   imports: [
 *     BrowserModule,
 *     StoreModule.forRoot(mapOfReducers),
 *     RouterModule.forRoot([
 *       { path: '', component: SimpleCmp },
 *       { path: 'next', component: SimpleCmp }
 *     ]),
 *     StoreRouterConnectingModule.forRoot()
 *   ],
 *   bootstrap: [AppCmp]
 * })
 * export class AppModule {
 * }
 * ```
 */
var StoreRouterConnectingModule = /** @class */ (function () {
    function StoreRouterConnectingModule(store, router, serializer, errorHandler, config) {
        this.store = store;
        this.router = router;
        this.serializer = serializer;
        this.errorHandler = errorHandler;
        this.config = config;
        this.lastEvent = null;
        this.trigger = RouterTrigger.NONE;
        this.stateKey = this.config.stateKey;
        this.setUpStoreStateListener();
        this.setUpRouterEventsListener();
    }
    StoreRouterConnectingModule_1 = StoreRouterConnectingModule;
    StoreRouterConnectingModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: StoreRouterConnectingModule_1,
            providers: [
                { provide: _ROUTER_CONFIG, useValue: config },
                {
                    provide: ROUTER_CONFIG,
                    useFactory: _createRouterConfig,
                    deps: [_ROUTER_CONFIG],
                },
                {
                    provide: RouterStateSerializer,
                    useClass: config.serializer
                        ? config.serializer
                        : config.routerState === 1 /* Minimal */
                            ? MinimalRouterStateSerializer
                            : DefaultRouterStateSerializer,
                },
            ],
        };
    };
    StoreRouterConnectingModule.prototype.setUpStoreStateListener = function () {
        var _this = this;
        this.store
            .pipe(select(this.stateKey), withLatestFrom(this.store))
            .subscribe(function (_a) {
            var _b = tslib_1.__read(_a, 2), routerStoreState = _b[0], storeState = _b[1];
            _this.navigateIfNeeded(routerStoreState, storeState);
        });
    };
    StoreRouterConnectingModule.prototype.navigateIfNeeded = function (routerStoreState, storeState) {
        var _this = this;
        if (!routerStoreState || !routerStoreState.state) {
            return;
        }
        if (this.trigger === RouterTrigger.ROUTER) {
            return;
        }
        if (this.lastEvent instanceof NavigationStart) {
            return;
        }
        var url = routerStoreState.state.url;
        if (this.router.url !== url) {
            this.storeState = storeState;
            this.trigger = RouterTrigger.STORE;
            this.router.navigateByUrl(url).catch(function (error) {
                _this.errorHandler.handleError(error);
            });
        }
    };
    StoreRouterConnectingModule.prototype.setUpRouterEventsListener = function () {
        var _this = this;
        var dispatchNavLate = this.config.navigationActionTiming ===
            NavigationActionTiming.PostActivation;
        var routesRecognized;
        this.router.events
            .pipe(withLatestFrom(this.store))
            .subscribe(function (_a) {
            var _b = tslib_1.__read(_a, 2), event = _b[0], storeState = _b[1];
            _this.lastEvent = event;
            if (event instanceof NavigationStart) {
                _this.routerState = _this.serializer.serialize(_this.router.routerState.snapshot);
                if (_this.trigger !== RouterTrigger.STORE) {
                    _this.storeState = storeState;
                    _this.dispatchRouterRequest(event);
                }
            }
            else if (event instanceof RoutesRecognized) {
                routesRecognized = event;
                if (!dispatchNavLate && _this.trigger !== RouterTrigger.STORE) {
                    _this.dispatchRouterNavigation(event);
                }
            }
            else if (event instanceof NavigationCancel) {
                _this.dispatchRouterCancel(event);
                _this.reset();
            }
            else if (event instanceof NavigationError) {
                _this.dispatchRouterError(event);
                _this.reset();
            }
            else if (event instanceof NavigationEnd) {
                if (_this.trigger !== RouterTrigger.STORE) {
                    if (dispatchNavLate) {
                        _this.dispatchRouterNavigation(routesRecognized);
                    }
                    _this.dispatchRouterNavigated(event);
                }
                _this.reset();
            }
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterRequest = function (event) {
        this.dispatchRouterAction(ROUTER_REQUEST, { event: event });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterNavigation = function (lastRoutesRecognized) {
        var nextRouterState = this.serializer.serialize(lastRoutesRecognized.state);
        this.dispatchRouterAction(ROUTER_NAVIGATION, {
            routerState: nextRouterState,
            event: new RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState),
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterCancel = function (event) {
        this.dispatchRouterAction(ROUTER_CANCEL, {
            storeState: this.storeState,
            event: event,
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterError = function (event) {
        this.dispatchRouterAction(ROUTER_ERROR, {
            storeState: this.storeState,
            event: new NavigationError(event.id, event.url, "" + event),
        });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterNavigated = function (event) {
        var routerState = this.serializer.serialize(this.router.routerState.snapshot);
        this.dispatchRouterAction(ROUTER_NAVIGATED, { event: event, routerState: routerState });
    };
    StoreRouterConnectingModule.prototype.dispatchRouterAction = function (type, payload) {
        this.trigger = RouterTrigger.ROUTER;
        try {
            this.store.dispatch({
                type: type,
                payload: tslib_1.__assign({ routerState: this.routerState }, payload, { event: this.config.routerState === 1 /* Minimal */
                        ? { id: payload.event.id, url: payload.event.url }
                        : payload.event }),
            });
        }
        finally {
            this.trigger = RouterTrigger.NONE;
        }
    };
    StoreRouterConnectingModule.prototype.reset = function () {
        this.trigger = RouterTrigger.NONE;
        this.storeState = null;
        this.routerState = null;
    };
    var StoreRouterConnectingModule_1;
    StoreRouterConnectingModule = StoreRouterConnectingModule_1 = tslib_1.__decorate([
        tslib_1.__param(4, Inject(ROUTER_CONFIG)),
        tslib_1.__metadata("design:paramtypes", [Store,
            Router,
            RouterStateSerializer,
            ErrorHandler, Object])
    ], StoreRouterConnectingModule);
StoreRouterConnectingModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: StoreRouterConnectingModule });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(StoreRouterConnectingModule, [{
        type: NgModule,
        args: [{}]
    }], function () { return [{ type: Store }, { type: Router }, { type: RouterStateSerializer }, { type: ErrorHandler }, { type: Object, decorators: [{
                type: Inject,
                args: [ROUTER_CONFIG]
            }] }]; }, { store: [], router: [], serializer: [], errorHandler: [], config: [], lastEvent: [], trigger: [], stateKey: [], setUpStoreStateListener: [], navigateIfNeeded: [], storeState: [], setUpRouterEventsListener: [], dispatchRouterRequest: [], dispatchRouterNavigation: [], dispatchRouterCancel: [], dispatchRouterError: [], dispatchRouterNavigated: [], dispatchRouterAction: [], reset: [], routerState: [] });
StoreRouterConnectingModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function StoreRouterConnectingModule_Factory(t) { return new (t || StoreRouterConnectingModule)(ɵngcc0.ɵɵinject(Store), ɵngcc0.ɵɵinject(Router), ɵngcc0.ɵɵinject(RouterStateSerializer), ɵngcc0.ɵɵinject(ErrorHandler), ɵngcc0.ɵɵinject(ROUTER_CONFIG)); } });
    return StoreRouterConnectingModule;
}());
export { StoreRouterConnectingModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3R6aW9uL09uZURyaXZlL9ee16HXnteb15nXnS9Qcml2YXRlL0FydGljbGVTdGFjay1tYXN0ZXIvQXJ0aWNsZVN0YWNrLW1hc3Rlci9ub2RlX21vZHVsZXMvQG5ncngvcm91dGVyLXN0b3JlL2VzbTUvc3JjL3JvdXRlcl9zdG9yZV9tb2R1bGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0ZBb05zRixBQUNqRTs7Ozs7Ozs7Ozs7Ozs7OzZVQU1lIiwiZmlsZSI6InJvdXRlcl9zdG9yZV9tb2R1bGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0c2xpYl8xIGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgTmdNb2R1bGUsIEVycm9ySGFuZGxlciwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5hdmlnYXRpb25DYW5jZWwsIE5hdmlnYXRpb25FcnJvciwgTmF2aWdhdGlvbkVuZCwgUm91dGVyLCBSb3V0ZXNSZWNvZ25pemVkLCBOYXZpZ2F0aW9uU3RhcnQsIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IHNlbGVjdCwgU3RvcmUgfSBmcm9tICdAbmdyeC9zdG9yZSc7XG5pbXBvcnQgeyB3aXRoTGF0ZXN0RnJvbSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFJPVVRFUl9DQU5DRUwsIFJPVVRFUl9FUlJPUiwgUk9VVEVSX05BVklHQVRFRCwgUk9VVEVSX05BVklHQVRJT04sIFJPVVRFUl9SRVFVRVNULCB9IGZyb20gJy4vYWN0aW9ucyc7XG5pbXBvcnQgeyBSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXIsIH0gZnJvbSAnLi9zZXJpYWxpemVycy9iYXNlJztcbmltcG9ydCB7IERlZmF1bHRSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXIsIH0gZnJvbSAnLi9zZXJpYWxpemVycy9kZWZhdWx0X3NlcmlhbGl6ZXInO1xuaW1wb3J0IHsgTWluaW1hbFJvdXRlclN0YXRlU2VyaWFsaXplciB9IGZyb20gJy4vc2VyaWFsaXplcnMvbWluaW1hbF9zZXJpYWxpemVyJztcbmV4cG9ydCB2YXIgTmF2aWdhdGlvbkFjdGlvblRpbWluZztcbihmdW5jdGlvbiAoTmF2aWdhdGlvbkFjdGlvblRpbWluZykge1xuICAgIE5hdmlnYXRpb25BY3Rpb25UaW1pbmdbTmF2aWdhdGlvbkFjdGlvblRpbWluZ1tcIlByZUFjdGl2YXRpb25cIl0gPSAxXSA9IFwiUHJlQWN0aXZhdGlvblwiO1xuICAgIE5hdmlnYXRpb25BY3Rpb25UaW1pbmdbTmF2aWdhdGlvbkFjdGlvblRpbWluZ1tcIlBvc3RBY3RpdmF0aW9uXCJdID0gMl0gPSBcIlBvc3RBY3RpdmF0aW9uXCI7XG59KShOYXZpZ2F0aW9uQWN0aW9uVGltaW5nIHx8IChOYXZpZ2F0aW9uQWN0aW9uVGltaW5nID0ge30pKTtcbmV4cG9ydCB2YXIgX1JPVVRFUl9DT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0BuZ3J4L3JvdXRlci1zdG9yZSBJbnRlcm5hbCBDb25maWd1cmF0aW9uJyk7XG5leHBvcnQgdmFyIFJPVVRFUl9DT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0BuZ3J4L3JvdXRlci1zdG9yZSBDb25maWd1cmF0aW9uJyk7XG5leHBvcnQgdmFyIERFRkFVTFRfUk9VVEVSX0ZFQVRVUkVOQU1FID0gJ3JvdXRlcic7XG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlckNvbmZpZyhjb25maWcpIHtcbiAgICByZXR1cm4gdHNsaWJfMS5fX2Fzc2lnbih7IHN0YXRlS2V5OiBERUZBVUxUX1JPVVRFUl9GRUFUVVJFTkFNRSwgc2VyaWFsaXplcjogRGVmYXVsdFJvdXRlclN0YXRlU2VyaWFsaXplciwgbmF2aWdhdGlvbkFjdGlvblRpbWluZzogTmF2aWdhdGlvbkFjdGlvblRpbWluZy5QcmVBY3RpdmF0aW9uIH0sIGNvbmZpZyk7XG59XG52YXIgUm91dGVyVHJpZ2dlcjtcbihmdW5jdGlvbiAoUm91dGVyVHJpZ2dlcikge1xuICAgIFJvdXRlclRyaWdnZXJbUm91dGVyVHJpZ2dlcltcIk5PTkVcIl0gPSAxXSA9IFwiTk9ORVwiO1xuICAgIFJvdXRlclRyaWdnZXJbUm91dGVyVHJpZ2dlcltcIlJPVVRFUlwiXSA9IDJdID0gXCJST1VURVJcIjtcbiAgICBSb3V0ZXJUcmlnZ2VyW1JvdXRlclRyaWdnZXJbXCJTVE9SRVwiXSA9IDNdID0gXCJTVE9SRVwiO1xufSkoUm91dGVyVHJpZ2dlciB8fCAoUm91dGVyVHJpZ2dlciA9IHt9KSk7XG4vKipcbiAqIENvbm5lY3RzIFJvdXRlck1vZHVsZSB3aXRoIFN0b3JlTW9kdWxlLlxuICpcbiAqIER1cmluZyB0aGUgbmF2aWdhdGlvbiwgYmVmb3JlIGFueSBndWFyZHMgb3IgcmVzb2x2ZXJzIHJ1biwgdGhlIHJvdXRlciB3aWxsIGRpc3BhdGNoXG4gKiBhIFJPVVRFUl9OQVZJR0FUSU9OIGFjdGlvbiwgd2hpY2ggaGFzIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICpcbiAqIGBgYFxuICogZXhwb3J0IHR5cGUgUm91dGVyTmF2aWdhdGlvblBheWxvYWQgPSB7XG4gKiAgIHJvdXRlclN0YXRlOiBTZXJpYWxpemVkUm91dGVyU3RhdGVTbmFwc2hvdCxcbiAqICAgZXZlbnQ6IFJvdXRlc1JlY29nbml6ZWRcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEVpdGhlciBhIHJlZHVjZXIgb3IgYW4gZWZmZWN0IGNhbiBiZSBpbnZva2VkIGluIHJlc3BvbnNlIHRvIHRoaXMgYWN0aW9uLlxuICogSWYgdGhlIGludm9rZWQgcmVkdWNlciB0aHJvd3MsIHRoZSBuYXZpZ2F0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXG4gKlxuICogSWYgbmF2aWdhdGlvbiBnZXRzIGNhbmNlbGVkIGJlY2F1c2Ugb2YgYSBndWFyZCwgYSBST1VURVJfQ0FOQ0VMIGFjdGlvbiB3aWxsIGJlXG4gKiBkaXNwYXRjaGVkLiBJZiBuYXZpZ2F0aW9uIHJlc3VsdHMgaW4gYW4gZXJyb3IsIGEgUk9VVEVSX0VSUk9SIGFjdGlvbiB3aWxsIGJlIGRpc3BhdGNoZWQuXG4gKlxuICogQm90aCBST1VURVJfQ0FOQ0VMIGFuZCBST1VURVJfRVJST1IgY29udGFpbiB0aGUgc3RvcmUgc3RhdGUgYmVmb3JlIHRoZSBuYXZpZ2F0aW9uXG4gKiB3aGljaCBjYW4gYmUgdXNlZCB0byByZXN0b3JlIHRoZSBjb25zaXN0ZW5jeSBvZiB0aGUgc3RvcmUuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQE5nTW9kdWxlKHtcbiAqICAgZGVjbGFyYXRpb25zOiBbQXBwQ21wLCBTaW1wbGVDbXBdLFxuICogICBpbXBvcnRzOiBbXG4gKiAgICAgQnJvd3Nlck1vZHVsZSxcbiAqICAgICBTdG9yZU1vZHVsZS5mb3JSb290KG1hcE9mUmVkdWNlcnMpLFxuICogICAgIFJvdXRlck1vZHVsZS5mb3JSb290KFtcbiAqICAgICAgIHsgcGF0aDogJycsIGNvbXBvbmVudDogU2ltcGxlQ21wIH0sXG4gKiAgICAgICB7IHBhdGg6ICduZXh0JywgY29tcG9uZW50OiBTaW1wbGVDbXAgfVxuICogICAgIF0pLFxuICogICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5mb3JSb290KClcbiAqICAgXSxcbiAqICAgYm9vdHN0cmFwOiBbQXBwQ21wXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xuICogfVxuICogYGBgXG4gKi9cbnZhciBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlKHN0b3JlLCByb3V0ZXIsIHNlcmlhbGl6ZXIsIGVycm9ySGFuZGxlciwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IHNlcmlhbGl6ZXI7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBSb3V0ZXJUcmlnZ2VyLk5PTkU7XG4gICAgICAgIHRoaXMuc3RhdGVLZXkgPSB0aGlzLmNvbmZpZy5zdGF0ZUtleTtcbiAgICAgICAgdGhpcy5zZXRVcFN0b3JlU3RhdGVMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnNldFVwUm91dGVyRXZlbnRzTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlXzEgPSBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGU7XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgPT09IHZvaWQgMCkgeyBjb25maWcgPSB7fTsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZV8xLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBfUk9VVEVSX0NPTkZJRywgdXNlVmFsdWU6IGNvbmZpZyB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUk9VVEVSX0NPTkZJRyxcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogX2NyZWF0ZVJvdXRlckNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgZGVwczogW19ST1VURVJfQ09ORklHXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogUm91dGVyU3RhdGVTZXJpYWxpemVyLFxuICAgICAgICAgICAgICAgICAgICB1c2VDbGFzczogY29uZmlnLnNlcmlhbGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29uZmlnLnNlcmlhbGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY29uZmlnLnJvdXRlclN0YXRlID09PSAxIC8qIE1pbmltYWwgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE1pbmltYWxSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IERlZmF1bHRSb3V0ZXJTdGF0ZVNlcmlhbGl6ZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUucHJvdG90eXBlLnNldFVwU3RvcmVTdGF0ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnN0b3JlXG4gICAgICAgICAgICAucGlwZShzZWxlY3QodGhpcy5zdGF0ZUtleSksIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKF9hLCAyKSwgcm91dGVyU3RvcmVTdGF0ZSA9IF9iWzBdLCBzdG9yZVN0YXRlID0gX2JbMV07XG4gICAgICAgICAgICBfdGhpcy5uYXZpZ2F0ZUlmTmVlZGVkKHJvdXRlclN0b3JlU3RhdGUsIHN0b3JlU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZS5wcm90b3R5cGUubmF2aWdhdGVJZk5lZWRlZCA9IGZ1bmN0aW9uIChyb3V0ZXJTdG9yZVN0YXRlLCBzdG9yZVN0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghcm91dGVyU3RvcmVTdGF0ZSB8fCAhcm91dGVyU3RvcmVTdGF0ZS5zdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgPT09IFJvdXRlclRyaWdnZXIuUk9VVEVSKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFzdEV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IHJvdXRlclN0b3JlU3RhdGUuc3RhdGUudXJsO1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXIudXJsICE9PSB1cmwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVTdGF0ZSA9IHN0b3JlU3RhdGU7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIgPSBSb3V0ZXJUcmlnZ2VyLlNUT1JFO1xuICAgICAgICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybCh1cmwpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLmVycm9ySGFuZGxlci5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5zZXRVcFJvdXRlckV2ZW50c0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGlzcGF0Y2hOYXZMYXRlID0gdGhpcy5jb25maWcubmF2aWdhdGlvbkFjdGlvblRpbWluZyA9PT1cbiAgICAgICAgICAgIE5hdmlnYXRpb25BY3Rpb25UaW1pbmcuUG9zdEFjdGl2YXRpb247XG4gICAgICAgIHZhciByb3V0ZXNSZWNvZ25pemVkO1xuICAgICAgICB0aGlzLnJvdXRlci5ldmVudHNcbiAgICAgICAgICAgIC5waXBlKHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IHRzbGliXzEuX19yZWFkKF9hLCAyKSwgZXZlbnQgPSBfYlswXSwgc3RvcmVTdGF0ZSA9IF9iWzFdO1xuICAgICAgICAgICAgX3RoaXMubGFzdEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yb3V0ZXJTdGF0ZSA9IF90aGlzLnNlcmlhbGl6ZXIuc2VyaWFsaXplKF90aGlzLnJvdXRlci5yb3V0ZXJTdGF0ZS5zbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnRyaWdnZXIgIT09IFJvdXRlclRyaWdnZXIuU1RPUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RvcmVTdGF0ZSA9IHN0b3JlU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoUm91dGVyUmVxdWVzdChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBSb3V0ZXNSZWNvZ25pemVkKSB7XG4gICAgICAgICAgICAgICAgcm91dGVzUmVjb2duaXplZCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgIGlmICghZGlzcGF0Y2hOYXZMYXRlICYmIF90aGlzLnRyaWdnZXIgIT09IFJvdXRlclRyaWdnZXIuU1RPUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hSb3V0ZXJOYXZpZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25DYW5jZWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaFJvdXRlckNhbmNlbChldmVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2hSb3V0ZXJFcnJvcihldmVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy50cmlnZ2VyICE9PSBSb3V0ZXJUcmlnZ2VyLlNUT1JFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaE5hdkxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoUm91dGVyTmF2aWdhdGlvbihyb3V0ZXNSZWNvZ25pemVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaFJvdXRlck5hdmlnYXRlZChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5kaXNwYXRjaFJvdXRlclJlcXVlc3QgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJvdXRlckFjdGlvbihST1VURVJfUkVRVUVTVCwgeyBldmVudDogZXZlbnQgfSk7XG4gICAgfTtcbiAgICBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUucHJvdG90eXBlLmRpc3BhdGNoUm91dGVyTmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChsYXN0Um91dGVzUmVjb2duaXplZCkge1xuICAgICAgICB2YXIgbmV4dFJvdXRlclN0YXRlID0gdGhpcy5zZXJpYWxpemVyLnNlcmlhbGl6ZShsYXN0Um91dGVzUmVjb2duaXplZC5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSb3V0ZXJBY3Rpb24oUk9VVEVSX05BVklHQVRJT04sIHtcbiAgICAgICAgICAgIHJvdXRlclN0YXRlOiBuZXh0Um91dGVyU3RhdGUsXG4gICAgICAgICAgICBldmVudDogbmV3IFJvdXRlc1JlY29nbml6ZWQobGFzdFJvdXRlc1JlY29nbml6ZWQuaWQsIGxhc3RSb3V0ZXNSZWNvZ25pemVkLnVybCwgbGFzdFJvdXRlc1JlY29nbml6ZWQudXJsQWZ0ZXJSZWRpcmVjdHMsIG5leHRSb3V0ZXJTdGF0ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5kaXNwYXRjaFJvdXRlckNhbmNlbCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoUm91dGVyQWN0aW9uKFJPVVRFUl9DQU5DRUwsIHtcbiAgICAgICAgICAgIHN0b3JlU3RhdGU6IHRoaXMuc3RvcmVTdGF0ZSxcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUucHJvdG90eXBlLmRpc3BhdGNoUm91dGVyRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJvdXRlckFjdGlvbihST1VURVJfRVJST1IsIHtcbiAgICAgICAgICAgIHN0b3JlU3RhdGU6IHRoaXMuc3RvcmVTdGF0ZSxcbiAgICAgICAgICAgIGV2ZW50OiBuZXcgTmF2aWdhdGlvbkVycm9yKGV2ZW50LmlkLCBldmVudC51cmwsIFwiXCIgKyBldmVudCksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5kaXNwYXRjaFJvdXRlck5hdmlnYXRlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcm91dGVyU3RhdGUgPSB0aGlzLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHRoaXMucm91dGVyLnJvdXRlclN0YXRlLnNuYXBzaG90KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFJvdXRlckFjdGlvbihST1VURVJfTkFWSUdBVEVELCB7IGV2ZW50OiBldmVudCwgcm91dGVyU3RhdGU6IHJvdXRlclN0YXRlIH0pO1xuICAgIH07XG4gICAgU3RvcmVSb3V0ZXJDb25uZWN0aW5nTW9kdWxlLnByb3RvdHlwZS5kaXNwYXRjaFJvdXRlckFjdGlvbiA9IGZ1bmN0aW9uICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlciA9IFJvdXRlclRyaWdnZXIuUk9VVEVSO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB0c2xpYl8xLl9fYXNzaWduKHsgcm91dGVyU3RhdGU6IHRoaXMucm91dGVyU3RhdGUgfSwgcGF5bG9hZCwgeyBldmVudDogdGhpcy5jb25maWcucm91dGVyU3RhdGUgPT09IDEgLyogTWluaW1hbCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGlkOiBwYXlsb2FkLmV2ZW50LmlkLCB1cmw6IHBheWxvYWQuZXZlbnQudXJsIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGF5bG9hZC5ldmVudCB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyID0gUm91dGVyVHJpZ2dlci5OT05FO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIgPSBSb3V0ZXJUcmlnZ2VyLk5PTkU7XG4gICAgICAgIHRoaXMuc3RvcmVTdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMucm91dGVyU3RhdGUgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZV8xO1xuICAgIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZSA9IFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZV8xID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICAgICAgTmdNb2R1bGUoe30pLFxuICAgICAgICB0c2xpYl8xLl9fcGFyYW0oNCwgSW5qZWN0KFJPVVRFUl9DT05GSUcpKSxcbiAgICAgICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0b3JlLFxuICAgICAgICAgICAgUm91dGVyLFxuICAgICAgICAgICAgUm91dGVyU3RhdGVTZXJpYWxpemVyLFxuICAgICAgICAgICAgRXJyb3JIYW5kbGVyLCBPYmplY3RdKVxuICAgIF0sIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZSk7XG4gICAgcmV0dXJuIFN0b3JlUm91dGVyQ29ubmVjdGluZ01vZHVsZTtcbn0oKSk7XG5leHBvcnQgeyBTdG9yZVJvdXRlckNvbm5lY3RpbmdNb2R1bGUgfTtcbiJdfQ==
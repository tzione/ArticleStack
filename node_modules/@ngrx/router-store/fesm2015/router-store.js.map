{"version":3,"sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/@ngrx/router-store/fesm2015/router-store.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+cC,4UAGC","file":"router-store.js","sourcesContent":["/**\n * @license NgRx 8.5.2\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { InjectionToken, NgModule, ErrorHandler, Inject } from '@angular/core';\nimport { NavigationStart, RoutesRecognized, NavigationCancel, NavigationError, NavigationEnd, Router } from '@angular/router';\nimport { select, Store, createSelector } from '@ngrx/store';\nimport { withLatestFrom } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An action dispatched when a router navigation request is fired.\n * @type {?}\n */\nconst ROUTER_REQUEST = '@ngrx/router-store/request';\n/**\n * An action dispatched when the router navigates.\n * @type {?}\n */\nconst ROUTER_NAVIGATION = '@ngrx/router-store/navigation';\n/**\n * An action dispatched when the router cancels navigation.\n * @type {?}\n */\nconst ROUTER_CANCEL = '@ngrx/router-store/cancel';\n/**\n * An action dispatched when the router errors.\n * @type {?}\n */\nconst ROUTER_ERROR = '@ngrx/router-store/error';\n/**\n * An action dispatched after navigation has ended and new route is active.\n * @type {?}\n */\nconst ROUTER_NAVIGATED = '@ngrx/router-store/navigated';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template T\n * @param {?} state\n * @param {?} action\n * @return {?}\n */\nfunction routerReducer(state, action) {\n    // Allow compilation with strictFunctionTypes - ref: #1344\n    /** @type {?} */\n    const routerAction = (/** @type {?} */ (action));\n    switch (routerAction.type) {\n        case ROUTER_NAVIGATION:\n        case ROUTER_ERROR:\n        case ROUTER_CANCEL:\n            return {\n                state: routerAction.payload.routerState,\n                navigationId: routerAction.payload.event.id,\n            };\n        default:\n            return (/** @type {?} */ (state));\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n * @template T\n */\nclass RouterStateSerializer {\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DefaultRouterStateSerializer {\n    /**\n     * @param {?} routerState\n     * @return {?}\n     */\n    serialize(routerState) {\n        return {\n            root: this.serializeRoute(routerState.root),\n            url: routerState.url,\n        };\n    }\n    /**\n     * @private\n     * @param {?} route\n     * @return {?}\n     */\n    serializeRoute(route) {\n        /** @type {?} */\n        const children = route.children.map((/**\n         * @param {?} c\n         * @return {?}\n         */\n        c => this.serializeRoute(c)));\n        return {\n            params: route.params,\n            paramMap: route.paramMap,\n            data: route.data,\n            url: route.url,\n            outlet: route.outlet,\n            routeConfig: route.routeConfig\n                ? {\n                    component: route.routeConfig.component,\n                    path: route.routeConfig.path,\n                    pathMatch: route.routeConfig.pathMatch,\n                    redirectTo: route.routeConfig.redirectTo,\n                    outlet: route.routeConfig.outlet,\n                }\n                : null,\n            queryParams: route.queryParams,\n            queryParamMap: route.queryParamMap,\n            fragment: route.fragment,\n            component: (/** @type {?} */ ((route.routeConfig\n                ? route.routeConfig.component\n                : undefined))),\n            root: (/** @type {?} */ (undefined)),\n            parent: (/** @type {?} */ (undefined)),\n            firstChild: children[0],\n            pathFromRoot: (/** @type {?} */ (undefined)),\n            children,\n        };\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass MinimalRouterStateSerializer {\n    /**\n     * @param {?} routerState\n     * @return {?}\n     */\n    serialize(routerState) {\n        return {\n            root: this.serializeRoute(routerState.root),\n            url: routerState.url,\n        };\n    }\n    /**\n     * @private\n     * @param {?} route\n     * @return {?}\n     */\n    serializeRoute(route) {\n        /** @type {?} */\n        const children = route.children.map((/**\n         * @param {?} c\n         * @return {?}\n         */\n        c => this.serializeRoute(c)));\n        return {\n            params: route.params,\n            data: route.data,\n            url: route.url,\n            outlet: route.outlet,\n            routeConfig: route.routeConfig\n                ? {\n                    path: route.routeConfig.path,\n                    pathMatch: route.routeConfig.pathMatch,\n                    redirectTo: route.routeConfig.redirectTo,\n                    outlet: route.routeConfig.outlet,\n                }\n                : null,\n            queryParams: route.queryParams,\n            fragment: route.fragment,\n            firstChild: children[0],\n            children,\n        };\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst NavigationActionTiming = {\n    PreActivation: 1,\n    PostActivation: 2,\n};\nNavigationActionTiming[NavigationActionTiming.PreActivation] = 'PreActivation';\nNavigationActionTiming[NavigationActionTiming.PostActivation] = 'PostActivation';\n/** @type {?} */\nconst _ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Internal Configuration');\n/** @type {?} */\nconst ROUTER_CONFIG = new InjectionToken('@ngrx/router-store Configuration');\n/** @type {?} */\nconst DEFAULT_ROUTER_FEATURENAME = 'router';\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createRouterConfig(config) {\n    return Object.assign({ stateKey: DEFAULT_ROUTER_FEATURENAME, serializer: DefaultRouterStateSerializer, navigationActionTiming: NavigationActionTiming.PreActivation }, config);\n}\n/** @enum {number} */\nconst RouterTrigger = {\n    NONE: 1,\n    ROUTER: 2,\n    STORE: 3,\n};\nRouterTrigger[RouterTrigger.NONE] = 'NONE';\nRouterTrigger[RouterTrigger.ROUTER] = 'ROUTER';\nRouterTrigger[RouterTrigger.STORE] = 'STORE';\n/**\n * Connects RouterModule with StoreModule.\n *\n * During the navigation, before any guards or resolvers run, the router will dispatch\n * a ROUTER_NAVIGATION action, which has the following signature:\n *\n * ```\n * export type RouterNavigationPayload = {\n *   routerState: SerializedRouterStateSnapshot,\n *   event: RoutesRecognized\n * }\n * ```\n *\n * Either a reducer or an effect can be invoked in response to this action.\n * If the invoked reducer throws, the navigation will be canceled.\n *\n * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be\n * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.\n *\n * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation\n * which can be used to restore the consistency of the store.\n *\n * Usage:\n *\n * ```typescript\n * \\@NgModule({\n *   declarations: [AppCmp, SimpleCmp],\n *   imports: [\n *     BrowserModule,\n *     StoreModule.forRoot(mapOfReducers),\n *     RouterModule.forRoot([\n *       { path: '', component: SimpleCmp },\n *       { path: 'next', component: SimpleCmp }\n *     ]),\n *     StoreRouterConnectingModule.forRoot()\n *   ],\n *   bootstrap: [AppCmp]\n * })\n * export class AppModule {\n * }\n * ```\n */\nclass StoreRouterConnectingModule {\n    /**\n     * @param {?} store\n     * @param {?} router\n     * @param {?} serializer\n     * @param {?} errorHandler\n     * @param {?} config\n     */\n    constructor(store, router, serializer, errorHandler, config) {\n        this.store = store;\n        this.router = router;\n        this.serializer = serializer;\n        this.errorHandler = errorHandler;\n        this.config = config;\n        this.lastEvent = null;\n        this.trigger = RouterTrigger.NONE;\n        this.stateKey = (/** @type {?} */ (this.config.stateKey));\n        this.setUpStoreStateListener();\n        this.setUpRouterEventsListener();\n    }\n    /**\n     * @template T\n     * @param {?=} config\n     * @return {?}\n     */\n    static forRoot(config = {}) {\n        return {\n            ngModule: StoreRouterConnectingModule,\n            providers: [\n                { provide: _ROUTER_CONFIG, useValue: config },\n                {\n                    provide: ROUTER_CONFIG,\n                    useFactory: _createRouterConfig,\n                    deps: [_ROUTER_CONFIG],\n                },\n                {\n                    provide: RouterStateSerializer,\n                    useClass: config.serializer\n                        ? config.serializer\n                        : config.routerState === 1 /* Minimal */\n                            ? MinimalRouterStateSerializer\n                            : DefaultRouterStateSerializer,\n                },\n            ],\n        };\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    setUpStoreStateListener() {\n        this.store\n            .pipe(select((/** @type {?} */ (this.stateKey))), withLatestFrom(this.store))\n            .subscribe((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ([routerStoreState, storeState]) => {\n            this.navigateIfNeeded(routerStoreState, storeState);\n        }));\n    }\n    /**\n     * @private\n     * @param {?} routerStoreState\n     * @param {?} storeState\n     * @return {?}\n     */\n    navigateIfNeeded(routerStoreState, storeState) {\n        if (!routerStoreState || !routerStoreState.state) {\n            return;\n        }\n        if (this.trigger === RouterTrigger.ROUTER) {\n            return;\n        }\n        if (this.lastEvent instanceof NavigationStart) {\n            return;\n        }\n        /** @type {?} */\n        const url = routerStoreState.state.url;\n        if (this.router.url !== url) {\n            this.storeState = storeState;\n            this.trigger = RouterTrigger.STORE;\n            this.router.navigateByUrl(url).catch((/**\n             * @param {?} error\n             * @return {?}\n             */\n            error => {\n                this.errorHandler.handleError(error);\n            }));\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    setUpRouterEventsListener() {\n        /** @type {?} */\n        const dispatchNavLate = this.config.navigationActionTiming ===\n            NavigationActionTiming.PostActivation;\n        /** @type {?} */\n        let routesRecognized;\n        this.router.events\n            .pipe(withLatestFrom(this.store))\n            .subscribe((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ([event, storeState]) => {\n            this.lastEvent = event;\n            if (event instanceof NavigationStart) {\n                this.routerState = this.serializer.serialize(this.router.routerState.snapshot);\n                if (this.trigger !== RouterTrigger.STORE) {\n                    this.storeState = storeState;\n                    this.dispatchRouterRequest(event);\n                }\n            }\n            else if (event instanceof RoutesRecognized) {\n                routesRecognized = event;\n                if (!dispatchNavLate && this.trigger !== RouterTrigger.STORE) {\n                    this.dispatchRouterNavigation(event);\n                }\n            }\n            else if (event instanceof NavigationCancel) {\n                this.dispatchRouterCancel(event);\n                this.reset();\n            }\n            else if (event instanceof NavigationError) {\n                this.dispatchRouterError(event);\n                this.reset();\n            }\n            else if (event instanceof NavigationEnd) {\n                if (this.trigger !== RouterTrigger.STORE) {\n                    if (dispatchNavLate) {\n                        this.dispatchRouterNavigation(routesRecognized);\n                    }\n                    this.dispatchRouterNavigated(event);\n                }\n                this.reset();\n            }\n        }));\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterRequest(event) {\n        this.dispatchRouterAction(ROUTER_REQUEST, { event });\n    }\n    /**\n     * @private\n     * @param {?} lastRoutesRecognized\n     * @return {?}\n     */\n    dispatchRouterNavigation(lastRoutesRecognized) {\n        /** @type {?} */\n        const nextRouterState = this.serializer.serialize(lastRoutesRecognized.state);\n        this.dispatchRouterAction(ROUTER_NAVIGATION, {\n            routerState: nextRouterState,\n            event: new RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState),\n        });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterCancel(event) {\n        this.dispatchRouterAction(ROUTER_CANCEL, {\n            storeState: this.storeState,\n            event,\n        });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterError(event) {\n        this.dispatchRouterAction(ROUTER_ERROR, {\n            storeState: this.storeState,\n            event: new NavigationError(event.id, event.url, `${event}`),\n        });\n    }\n    /**\n     * @private\n     * @param {?} event\n     * @return {?}\n     */\n    dispatchRouterNavigated(event) {\n        /** @type {?} */\n        const routerState = this.serializer.serialize(this.router.routerState.snapshot);\n        this.dispatchRouterAction(ROUTER_NAVIGATED, { event, routerState });\n    }\n    /**\n     * @private\n     * @param {?} type\n     * @param {?} payload\n     * @return {?}\n     */\n    dispatchRouterAction(type, payload) {\n        this.trigger = RouterTrigger.ROUTER;\n        try {\n            this.store.dispatch({\n                type,\n                payload: Object.assign({ routerState: this.routerState }, payload, { event: this.config.routerState === 1 /* Minimal */\n                        ? { id: payload.event.id, url: payload.event.url }\n                        : payload.event }),\n            });\n        }\n        finally {\n            this.trigger = RouterTrigger.NONE;\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    reset() {\n        this.trigger = RouterTrigger.NONE;\n        this.storeState = null;\n        this.routerState = null;\n    }\n}\nStoreRouterConnectingModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n/** @nocollapse */\nStoreRouterConnectingModule.ctorParameters = () => [\n    { type: Store },\n    { type: Router },\n    { type: RouterStateSerializer },\n    { type: ErrorHandler },\n    { type: undefined, decorators: [{ type: Inject, args: [ROUTER_CONFIG,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @template V\n * @param {?} selectState\n * @return {?}\n */\nfunction getSelectors(selectState) {\n    /** @type {?} */\n    const selectRouterState = createSelector(selectState, (/**\n     * @param {?} router\n     * @return {?}\n     */\n    router => router && router.state));\n    /** @type {?} */\n    const selectCurrentRoute = createSelector(selectRouterState, (/**\n     * @param {?} routerState\n     * @return {?}\n     */\n    routerState => {\n        if (!routerState) {\n            return undefined;\n        }\n        /** @type {?} */\n        let route = routerState.root;\n        while (route.firstChild) {\n            route = route.firstChild;\n        }\n        return route;\n    }));\n    /** @type {?} */\n    const selectQueryParams = createSelector(selectCurrentRoute, (/**\n     * @param {?} route\n     * @return {?}\n     */\n    route => route && route.queryParams));\n    /** @type {?} */\n    const selectQueryParam = (/**\n     * @param {?} param\n     * @return {?}\n     */\n    (param) => createSelector(selectQueryParams, (/**\n     * @param {?} params\n     * @return {?}\n     */\n    params => params && params[param])));\n    /** @type {?} */\n    const selectRouteParams = createSelector(selectCurrentRoute, (/**\n     * @param {?} route\n     * @return {?}\n     */\n    route => route && route.params));\n    /** @type {?} */\n    const selectRouteParam = (/**\n     * @param {?} param\n     * @return {?}\n     */\n    (param) => createSelector(selectRouteParams, (/**\n     * @param {?} params\n     * @return {?}\n     */\n    params => params && params[param])));\n    /** @type {?} */\n    const selectRouteData = createSelector(selectCurrentRoute, (/**\n     * @param {?} route\n     * @return {?}\n     */\n    route => route && route.data));\n    /** @type {?} */\n    const selectUrl = createSelector(selectRouterState, (/**\n     * @param {?} routerState\n     * @return {?}\n     */\n    routerState => routerState && routerState.url));\n    return {\n        selectCurrentRoute,\n        selectQueryParams,\n        selectQueryParam,\n        selectRouteParams,\n        selectRouteParam,\n        selectRouteData,\n        selectUrl,\n    };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { _ROUTER_CONFIG as ɵngrx_modules_router_store_router_store_a, _createRouterConfig as ɵngrx_modules_router_store_router_store_b, ROUTER_ERROR, ROUTER_CANCEL, ROUTER_NAVIGATION, ROUTER_NAVIGATED, ROUTER_REQUEST, routerReducer, StoreRouterConnectingModule, NavigationActionTiming, ROUTER_CONFIG, DEFAULT_ROUTER_FEATURENAME, RouterStateSerializer, DefaultRouterStateSerializer, MinimalRouterStateSerializer, getSelectors };\n"]}
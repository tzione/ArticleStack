import { __decorate, __metadata, __param } from 'tslib';
import { EventEmitter, Input, Output, Component, Inject, PLATFORM_ID, ElementRef, Directive, forwardRef, NgModule } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';

import * as ɵngcc0 from '@angular/core';

const _c0 = ["ngx-masonry", ""];
const _c1 = ["*"];
let imagesLoaded;
let masonryConstructor;
let NgxMasonryComponent = class NgxMasonryComponent {
    constructor(platformId, _element) {
        this.platformId = platformId;
        this._element = _element;
        this.useImagesLoaded = false;
        this.updateLayout = false;
        // Outputs
        this.layoutComplete = new EventEmitter();
        this.removeComplete = new EventEmitter();
    }
    ngOnInit() {
        if (this.useImagesLoaded && imagesLoaded === undefined) {
            imagesLoaded = require('imagesloaded');
        }
        if (isPlatformBrowser(this.platformId) && masonryConstructor === undefined) {
            masonryConstructor = require('masonry-layout');
        }
        // Create masonry options object
        if (!this.options) {
            this.options = {};
        }
        // Set default itemSelector
        if (!this.options.itemSelector) {
            this.options.itemSelector = '[ngxMasonryItem], ngxMasonryItem';
        }
        if (isPlatformBrowser(this.platformId)) {
            // Initialize Masonry
            this._msnry = new masonryConstructor(this._element.nativeElement, this.options);
            // Bind to events
            this._msnry.on('layoutComplete', (items) => {
                this.layoutComplete.emit(items);
            });
            this._msnry.on('removeComplete', (items) => {
                this.removeComplete.emit(items);
            });
        }
    }
    ngOnChanges(changes) {
        // only update layout if it's not the first change
        if (changes.updateLayout) {
            if (!changes.updateLayout.firstChange) {
                this.layout();
            }
        }
    }
    ngOnDestroy() {
        if (this._msnry) {
            this._msnry.destroy();
        }
    }
    layout() {
        setTimeout(() => {
            this._msnry.layout();
        });
    }
    reloadItems() {
        setTimeout(() => {
            this._msnry.reloadItems();
        });
    }
    // public add(element: HTMLElement, prepend: boolean = false) {
    add(element) {
        let isFirstItem = false;
        // Check if first item
        if (this._msnry.items.length === 0) {
            isFirstItem = true;
        }
        if (this.useImagesLoaded) {
            imagesLoaded(element, (instance) => {
                this._element.nativeElement.appendChild(element);
                // Tell Masonry that a child element has been added
                this._msnry.appended(element);
                // layout if first item
                if (isFirstItem) {
                    this.layout();
                }
            });
            this._element.nativeElement.removeChild(element);
        }
        else {
            // Tell Masonry that a child element has been added
            this._msnry.appended(element);
            // layout if first item
            if (isFirstItem) {
                this.layout();
            }
        }
    }
    remove(element) {
        // Tell Masonry that a child element has been removed
        this._msnry.remove(element);
        // Layout items
        this.layout();
    }
}
NgxMasonryComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NgxMasonryComponent, selectors: [["", "ngx-masonry", ""], ["ngx-masonry"]], factory: function NgxMasonryComponent_Factory(t) { return new (t || NgxMasonryComponent)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, inputs: { useImagesLoaded: "useImagesLoaded", updateLayout: "updateLayout", options: "options" }, outputs: { layoutComplete: "layoutComplete", removeComplete: "removeComplete" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, ngContentSelectors: _c1, consts: 1, vars: 0, template: function NgxMasonryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n\t\t\tdisplay: block;\n\t\t}"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgxMasonryComponent, [{
        type: Component,
        args: [{
                selector: '[ngx-masonry], ngx-masonry',
                template: '<ng-content></ng-content>',
                styles: [`
		:host {
			display: block;
		}
	`]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ElementRef }]; }, { constructor: [], platformId: [], _element: [], useImagesLoaded: [{
            type: Input
        }], updateLayout: [{
            type: Input
        }], layoutComplete: [{
            type: Output
        }], removeComplete: [{
            type: Output
        }], ngOnInit: [], options: [{
            type: Input
        }], _msnry: [], ngOnChanges: [], ngOnDestroy: [], layout: [], reloadItems: [], add: [], remove: [] });;
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxMasonryComponent.prototype, "options", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NgxMasonryComponent.prototype, "useImagesLoaded", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NgxMasonryComponent.prototype, "updateLayout", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NgxMasonryComponent.prototype, "layoutComplete", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NgxMasonryComponent.prototype, "removeComplete", void 0);
NgxMasonryComponent = __decorate([
    __param(0, Inject(PLATFORM_ID)),
    __metadata("design:paramtypes", [Object, ElementRef])
], NgxMasonryComponent);

let NgxMasonryDirective = class NgxMasonryDirective {
    constructor(_element, _parent, platformId) {
        this._element = _element;
        this._parent = _parent;
        this.platformId = platformId;
    }
    ngAfterViewInit() {
        if (isPlatformBrowser(this.platformId)) {
            this._parent.add(this._element.nativeElement);
            this.watchForHtmlChanges();
        }
    }
    ngOnDestroy() {
        if (isPlatformBrowser(this.platformId)) {
            this._parent.remove(this._element.nativeElement);
        }
    }
    /** When HTML in brick changes dinamically, observe that and change layout */
    watchForHtmlChanges() {
        MutationObserver = window.MutationObserver || window.WebKitMutationObserver;
        if (MutationObserver) {
            /** Watch for any changes to subtree */
            const self = this;
            const observer = new MutationObserver(function (mutations, observerFromElement) {
                self._parent.layout();
            });
            // define what element should be observed by the observer
            // and what types of mutations trigger the callback
            observer.observe(this._element.nativeElement, {
                subtree: true,
                childList: true
            });
        }
    }
}
NgxMasonryDirective.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: NgxMasonryDirective, selectors: [["", "ngxMasonryItem", ""], ["ngxMasonryItem"]], factory: function NgxMasonryDirective_Factory(t) { return new (t || NgxMasonryDirective)(ɵngcc0.ɵɵdirectiveInject(ElementRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(() => NgxMasonryComponent)), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgxMasonryDirective, [{
        type: Directive,
        args: [{
                selector: '[ngxMasonryItem], ngxMasonryItem'
            }]
    }], function () { return [{ type: ElementRef }, { type: NgxMasonryComponent, decorators: [{
                type: Inject,
                args: [forwardRef(() => NgxMasonryComponent)]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { constructor: [], _element: [], _parent: [], platformId: [], ngAfterViewInit: [], ngOnDestroy: [], watchForHtmlChanges: [] });;
NgxMasonryDirective = __decorate([
    __param(1, Inject(forwardRef(() => NgxMasonryComponent))),
    __param(2, Inject(PLATFORM_ID)),
    __metadata("design:paramtypes", [ElementRef,
        NgxMasonryComponent, Object])
], NgxMasonryDirective);

let NgxMasonryModule = class NgxMasonryModule {
}
NgxMasonryModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: NgxMasonryModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(NgxMasonryModule, { declarations: [NgxMasonryComponent,
        NgxMasonryDirective], exports: [NgxMasonryComponent,
        NgxMasonryDirective] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgxMasonryModule, [{
        type: NgModule,
        args: [{
                imports: [],
                declarations: [NgxMasonryComponent, NgxMasonryDirective],
                exports: [NgxMasonryComponent, NgxMasonryDirective]
            }]
    }], null, null);
NgxMasonryModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function NgxMasonryModule_Factory(t) { return new (t || NgxMasonryModule)(); }, imports: [[]] });;

export { NgxMasonryComponent, NgxMasonryDirective, NgxMasonryModule };

//# sourceMappingURL=ngx-masonry.js.map
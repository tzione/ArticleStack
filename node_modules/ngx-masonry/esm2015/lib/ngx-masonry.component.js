import * as tslib_1 from "tslib";
import { Component, Input, Output, ElementRef, EventEmitter, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import * as ɵngcc0 from '@angular/core';

const _c0 = ["ngx-masonry", ""];
const _c1 = ["*"];
let imagesLoaded;
let masonryConstructor;
let NgxMasonryComponent = class NgxMasonryComponent {
    constructor(platformId, _element) {
        this.platformId = platformId;
        this._element = _element;
        this.useImagesLoaded = false;
        this.updateLayout = false;
        // Outputs
        this.layoutComplete = new EventEmitter();
        this.removeComplete = new EventEmitter();
    }
    ngOnInit() {
        if (this.useImagesLoaded && imagesLoaded === undefined) {
            imagesLoaded = require('imagesloaded');
        }
        if (isPlatformBrowser(this.platformId) && masonryConstructor === undefined) {
            masonryConstructor = require('masonry-layout');
        }
        // Create masonry options object
        if (!this.options) {
            this.options = {};
        }
        // Set default itemSelector
        if (!this.options.itemSelector) {
            this.options.itemSelector = '[ngxMasonryItem], ngxMasonryItem';
        }
        if (isPlatformBrowser(this.platformId)) {
            // Initialize Masonry
            this._msnry = new masonryConstructor(this._element.nativeElement, this.options);
            // Bind to events
            this._msnry.on('layoutComplete', (items) => {
                this.layoutComplete.emit(items);
            });
            this._msnry.on('removeComplete', (items) => {
                this.removeComplete.emit(items);
            });
        }
    }
    ngOnChanges(changes) {
        // only update layout if it's not the first change
        if (changes.updateLayout) {
            if (!changes.updateLayout.firstChange) {
                this.layout();
            }
        }
    }
    ngOnDestroy() {
        if (this._msnry) {
            this._msnry.destroy();
        }
    }
    layout() {
        setTimeout(() => {
            this._msnry.layout();
        });
    }
    reloadItems() {
        setTimeout(() => {
            this._msnry.reloadItems();
        });
    }
    // public add(element: HTMLElement, prepend: boolean = false) {
    add(element) {
        let isFirstItem = false;
        // Check if first item
        if (this._msnry.items.length === 0) {
            isFirstItem = true;
        }
        if (this.useImagesLoaded) {
            imagesLoaded(element, (instance) => {
                this._element.nativeElement.appendChild(element);
                // Tell Masonry that a child element has been added
                this._msnry.appended(element);
                // layout if first item
                if (isFirstItem) {
                    this.layout();
                }
            });
            this._element.nativeElement.removeChild(element);
        }
        else {
            // Tell Masonry that a child element has been added
            this._msnry.appended(element);
            // layout if first item
            if (isFirstItem) {
                this.layout();
            }
        }
    }
    remove(element) {
        // Tell Masonry that a child element has been removed
        this._msnry.remove(element);
        // Layout items
        this.layout();
    }
}
NgxMasonryComponent.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: NgxMasonryComponent, selectors: [["", "ngx-masonry", ""], ["ngx-masonry"]], factory: function NgxMasonryComponent_Factory(t) { return new (t || NgxMasonryComponent)(ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(ElementRef)); }, inputs: { useImagesLoaded: "useImagesLoaded", updateLayout: "updateLayout", options: "options" }, outputs: { layoutComplete: "layoutComplete", removeComplete: "removeComplete" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], attrs: _c0, ngContentSelectors: _c1, consts: 1, vars: 0, template: function NgxMasonryComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%] {\n\t\t\tdisplay: block;\n\t\t}"] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(NgxMasonryComponent, [{
        type: Component,
        args: [{
                selector: '[ngx-masonry], ngx-masonry',
                template: '<ng-content></ng-content>',
                styles: [`
		:host {
			display: block;
		}
	`]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: ElementRef }]; }, { constructor: [], platformId: [], _element: [], useImagesLoaded: [{
            type: Input
        }], updateLayout: [{
            type: Input
        }], layoutComplete: [{
            type: Output
        }], removeComplete: [{
            type: Output
        }], ngOnInit: [], options: [{
            type: Input
        }], _msnry: [], ngOnChanges: [], ngOnDestroy: [], layout: [], reloadItems: [], add: [], remove: [] });;
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object)
], NgxMasonryComponent.prototype, "options", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], NgxMasonryComponent.prototype, "useImagesLoaded", void 0);
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Boolean)
], NgxMasonryComponent.prototype, "updateLayout", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], NgxMasonryComponent.prototype, "layoutComplete", void 0);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], NgxMasonryComponent.prototype, "removeComplete", void 0);
NgxMasonryComponent = tslib_1.__decorate([
    tslib_1.__param(0, Inject(PLATFORM_ID)),
    tslib_1.__metadata("design:paramtypes", [Object, ElementRef])
], NgxMasonryComponent);
export { NgxMasonryComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3R6aW9uL09uZURyaXZlL9ee16HXnteb15nXnS9Qcml2YXRlL0FydGljbGVTdGFjay1tYXN0ZXIvQXJ0aWNsZVN0YWNrLW1hc3Rlci9ub2RlX21vZHVsZXMvbmd4LW1hc29ucnkvZXNtMjAxNS9saWIvbmd4LW1hc29ucnkuY29tcG9uZW50LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhHQWdHQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQXFCeUMsQUFTbkMiLCJmaWxlIjoibmd4LW1hc29ucnkuY29tcG9uZW50LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgdHNsaWJfMSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBQTEFURk9STV9JRCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5sZXQgaW1hZ2VzTG9hZGVkO1xubGV0IG1hc29ucnlDb25zdHJ1Y3RvcjtcbmxldCBOZ3hNYXNvbnJ5Q29tcG9uZW50ID0gY2xhc3MgTmd4TWFzb25yeUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm1JZCwgX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybUlkID0gcGxhdGZvcm1JZDtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLnVzZUltYWdlc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUxheW91dCA9IGZhbHNlO1xuICAgICAgICAvLyBPdXRwdXRzXG4gICAgICAgIHRoaXMubGF5b3V0Q29tcGxldGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ29tcGxldGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy51c2VJbWFnZXNMb2FkZWQgJiYgaW1hZ2VzTG9hZGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGltYWdlc0xvYWRlZCA9IHJlcXVpcmUoJ2ltYWdlc2xvYWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpICYmIG1hc29ucnlDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXNvbnJ5Q29uc3RydWN0b3IgPSByZXF1aXJlKCdtYXNvbnJ5LWxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBtYXNvbnJ5IG9wdGlvbnMgb2JqZWN0XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgZGVmYXVsdCBpdGVtU2VsZWN0b3JcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXRlbVNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaXRlbVNlbGVjdG9yID0gJ1tuZ3hNYXNvbnJ5SXRlbV0sIG5neE1hc29ucnlJdGVtJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBNYXNvbnJ5XG4gICAgICAgICAgICB0aGlzLl9tc25yeSA9IG5ldyBtYXNvbnJ5Q29uc3RydWN0b3IodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gQmluZCB0byBldmVudHNcbiAgICAgICAgICAgIHRoaXMuX21zbnJ5Lm9uKCdsYXlvdXRDb21wbGV0ZScsIChpdGVtcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0Q29tcGxldGUuZW1pdChpdGVtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX21zbnJ5Lm9uKCdyZW1vdmVDb21wbGV0ZScsIChpdGVtcykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29tcGxldGUuZW1pdChpdGVtcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIGxheW91dCBpZiBpdCdzIG5vdCB0aGUgZmlyc3QgY2hhbmdlXG4gICAgICAgIGlmIChjaGFuZ2VzLnVwZGF0ZUxheW91dCkge1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VzLnVwZGF0ZUxheW91dC5maXJzdENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9tc25yeSkge1xuICAgICAgICAgICAgdGhpcy5fbXNucnkuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxheW91dCgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9tc25yeS5sYXlvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbG9hZEl0ZW1zKCkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX21zbnJ5LnJlbG9hZEl0ZW1zKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgYWRkKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwcmVwZW5kOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICBhZGQoZWxlbWVudCkge1xuICAgICAgICBsZXQgaXNGaXJzdEl0ZW0gPSBmYWxzZTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgZmlyc3QgaXRlbVxuICAgICAgICBpZiAodGhpcy5fbXNucnkuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpc0ZpcnN0SXRlbSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlSW1hZ2VzTG9hZGVkKSB7XG4gICAgICAgICAgICBpbWFnZXNMb2FkZWQoZWxlbWVudCwgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIFRlbGwgTWFzb25yeSB0aGF0IGEgY2hpbGQgZWxlbWVudCBoYXMgYmVlbiBhZGRlZFxuICAgICAgICAgICAgICAgIHRoaXMuX21zbnJ5LmFwcGVuZGVkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIGxheW91dCBpZiBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKGlzRmlyc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUZWxsIE1hc29ucnkgdGhhdCBhIGNoaWxkIGVsZW1lbnQgaGFzIGJlZW4gYWRkZWRcbiAgICAgICAgICAgIHRoaXMuX21zbnJ5LmFwcGVuZGVkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gbGF5b3V0IGlmIGZpcnN0IGl0ZW1cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0SXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gVGVsbCBNYXNvbnJ5IHRoYXQgYSBjaGlsZCBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgdGhpcy5fbXNucnkucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgICAvLyBMYXlvdXQgaXRlbXNcbiAgICAgICAgdGhpcy5sYXlvdXQoKTtcbiAgICB9XG59O1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5neE1hc29ucnlDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbnRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmd4TWFzb25yeUNvbXBvbmVudC5wcm90b3R5cGUsIFwidXNlSW1hZ2VzTG9hZGVkXCIsIHZvaWQgMCk7XG50c2xpYl8xLl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgdHNsaWJfMS5fX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5neE1hc29ucnlDb21wb25lbnQucHJvdG90eXBlLCBcInVwZGF0ZUxheW91dFwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOZ3hNYXNvbnJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsYXlvdXRDb21wbGV0ZVwiLCB2b2lkIDApO1xudHNsaWJfMS5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICB0c2xpYl8xLl9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOZ3hNYXNvbnJ5Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZW1vdmVDb21wbGV0ZVwiLCB2b2lkIDApO1xuTmd4TWFzb25yeUNvbXBvbmVudCA9IHRzbGliXzEuX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmd4LW1hc29ucnldLCBuZ3gtbWFzb25yeScsXG4gICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgICAgIHN0eWxlczogW2Bcblx0XHQ6aG9zdCB7XG5cdFx0XHRkaXNwbGF5OiBibG9jaztcblx0XHR9XG5cdGBdXG4gICAgfSksXG4gICAgdHNsaWJfMS5fX3BhcmFtKDAsIEluamVjdChQTEFURk9STV9JRCkpLFxuICAgIHRzbGliXzEuX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIEVsZW1lbnRSZWZdKVxuXSwgTmd4TWFzb25yeUNvbXBvbmVudCk7XG5leHBvcnQgeyBOZ3hNYXNvbnJ5Q29tcG9uZW50IH07XG4iXX0=
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/animations'), require('@angular/cdk/accordion'), require('@angular/cdk/coercion'), require('@angular/cdk/collections'), require('@angular/cdk/portal'), require('@angular/common'), require('@angular/platform-browser/animations'), require('rxjs'), require('rxjs/operators'), require('@angular/cdk/a11y'), require('@angular/cdk/keycodes'),require('@angular/core'),require('@angular/cdk/portal'),require('@angular/common'),require('@angular/cdk/accordion')) :
	typeof define === 'function' && define.amd ? define('@angular/material/expansion', ['exports', '@angular/core', '@angular/animations', '@angular/cdk/accordion', '@angular/cdk/coercion', '@angular/cdk/collections', '@angular/cdk/portal', '@angular/common', '@angular/platform-browser/animations', 'rxjs', 'rxjs/operators', '@angular/cdk/a11y', '@angular/cdk/keycodes','@angular/core','@angular/cdk/portal','@angular/common','@angular/cdk/accordion'], factory) :
	(factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.expansion = {}),global.ng.core,global.ng.animations,global.ng.cdk.accordion,global.ng.cdk.coercion,global.ng.cdk.collections,global.ng.cdk.portal,global.ng.common,global.ng.platformBrowser.animations,global.rxjs,global.rxjs.operators,global.ng.cdk.a11y,global.ng.cdk.keycodes,global.ng.core,global.ng.cdk/portal,global.ng.common,global.ng.cdk/accordion));
}(this, (function (exports,core,animations,accordion,coercion,collections,portal,common,animations$1,rxjs,operators,a11y,keycodes,ɵngcc0,ɵngcc1,ɵngcc2,ɵngcc3) { 
const _c0 = ["body"];
const _c1 = [1, "mat-expansion-panel"];
const _c2 = ["role", "region", 1, "mat-expansion-panel-content", 3, "id"];
const _c3 = ["body", ""];
const _c4 = [1, "mat-expansion-panel-body"];
const _c5 = [3, "cdkPortalOutlet"];
function MatExpansionPanel_ng_template_5_Template(rf, ctx) { }
const _c6 = [[["mat-expansion-panel-header"]], "*", [["mat-action-row"]]];
const _c7 = ["mat-expansion-panel-header", "*", "mat-action-row"];
const _c8 = [1, "mat-action-row"];
const _c9 = function (a0, a1) { return { collapsedHeight: a0, expandedHeight: a1 }; };
const _c10 = function (a0, a1) { return { value: a0, params: a1 }; };
const _c11 = ["role", "button", 1, "mat-expansion-panel-header"];
const _c12 = [1, "mat-content"];
const _c13 = ["class", "mat-expansion-indicator", 4, "ngIf"];
const _c14 = [1, "mat-expansion-indicator"];
function MatExpansionPanelHeader_span_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", _c14);
} if (rf & 2) {
    const ctx_r179 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@indicatorRotate", ctx_r179._getExpandedState());
} }
const _c15 = [[["mat-panel-title"]], [["mat-panel-description"]], "*"];
const _c16 = ["mat-panel-title", "mat-panel-description", "*"];
const _c17 = [1, "mat-expansion-panel-header-description"];
const _c18 = [1, "mat-expansion-panel-header-title"];
const _c19 = [1, "mat-accordion"];
'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Token used to provide a `MatAccordion` to `MatExpansionPanel`.
 * Used primarily to avoid circular imports between `MatAccordion` and `MatExpansionPanel`.
 * @type {?}
 */
var MAT_ACCORDION = new core.InjectionToken('MAT_ACCORDION');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Time and timing curve for expansion panel animations.
 * @type {?}
 */
var EXPANSION_PANEL_ANIMATION_TIMING = '225ms cubic-bezier(0.4,0.0,0.2,1)';
/**
 * Animations used by the Material expansion panel.
 *
 * A bug in angular animation's `state` when ViewContainers are moved using ViewContainerRef.move()
 * causes the animation state of moved components to become `void` upon exit, and not update again
 * upon reentry into the DOM.  This can lead a to situation for the expansion panel where the state
 * of the panel is `expanded` or `collapsed` but the animation state is `void`.
 *
 * To correctly handle animating to the next state, we animate between `void` and `collapsed` which
 * are defined to have the same styles. Since angular animates from the current styles to the
 * destination state's style definition, in situations where we are moving from `void`'s styles to
 * `collapsed` this acts a noop since no style values change.
 *
 * In the case where angular's animation state is out of sync with the expansion panel's state, the
 * expansion panel being `expanded` and angular animations being `void`, the animation from the
 * `expanded`'s effective styles (though in a `void` animation state) to the collapsed state will
 * occur as expected.
 *
 * Angular Bug: https://github.com/angular/angular/issues/18847
 *
 * \@docs-private
 * @type {?}
 */
var matExpansionAnimations = {
    /**
     * Animation that rotates the indicator arrow.
     */
    indicatorRotate: animations.trigger('indicatorRotate', [
        animations.state('collapsed, void', animations.style({ transform: 'rotate(0deg)' })),
        animations.state('expanded', animations.style({ transform: 'rotate(180deg)' })),
        animations.transition('expanded <=> collapsed, void => collapsed', animations.animate(EXPANSION_PANEL_ANIMATION_TIMING)),
    ]),
    /**
     * Animation that expands and collapses the panel header height.
     */
    expansionHeaderHeight: animations.trigger('expansionHeight', [
        animations.state('collapsed, void', animations.style({
            height: '{{collapsedHeight}}',
        }), {
            params: { collapsedHeight: '48px' },
        }),
        animations.state('expanded', animations.style({
            height: '{{expandedHeight}}'
        }), {
            params: { expandedHeight: '64px' }
        }),
        animations.transition('expanded <=> collapsed, void => collapsed', animations.group([
            animations.query('@indicatorRotate', animations.animateChild(), { optional: true }),
            animations.animate(EXPANSION_PANEL_ANIMATION_TIMING),
        ])),
    ]),
    /**
     * Animation that expands and collapses the panel content.
     */
    bodyExpansion: animations.trigger('bodyExpansion', [
        animations.state('collapsed, void', animations.style({ height: '0px', visibility: 'hidden' })),
        animations.state('expanded', animations.style({ height: '*', visibility: 'visible' })),
        animations.transition('expanded <=> collapsed, void => collapsed', animations.animate(EXPANSION_PANEL_ANIMATION_TIMING)),
    ])
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Expansion panel content that will be rendered lazily
 * after the panel is opened for the first time.
 */
var MatExpansionPanelContent = /** @class */ (function () {
    function MatExpansionPanelContent(_template) {
        this._template = _template;
    }
    /** @nocollapse */
    MatExpansionPanelContent.ctorParameters = function () { return [
        { type: core.TemplateRef }
    ]; };
MatExpansionPanelContent.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: MatExpansionPanelContent, selectors: [["ng-template", "matExpansionPanelContent", ""]], factory: function MatExpansionPanelContent_Factory(t) { return new (t || MatExpansionPanelContent)(ɵngcc0.ɵɵdirectiveInject(core.TemplateRef)); } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatExpansionPanelContent, [{
        type: core.Directive,
        args: [{
                selector: 'ng-template[matExpansionPanelContent]'
            }]
    }], function () { return [{ type: core.TemplateRef }]; }, { _template: [] });
    return MatExpansionPanelContent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Counter for generating unique element ids.
 * @type {?}
 */
var uniqueId = 0;
/**
 * Injection token that can be used to configure the defalt
 * options for the expansion panel component.
 * @type {?}
 */
var MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new core.InjectionToken('MAT_EXPANSION_PANEL_DEFAULT_OPTIONS');
var ɵ0 = undefined;
/**
 * `<mat-expansion-panel>`
 *
 * This component can be used as a single element to show expandable content, or as one of
 * multiple children of an element with the MatAccordion directive attached.
 */
var MatExpansionPanel = /** @class */ (function (_super) {
    __extends(MatExpansionPanel, _super);
    function MatExpansionPanel(accordion$$1, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {
        var _this = _super.call(this, accordion$$1, _changeDetectorRef, _uniqueSelectionDispatcher) || this;
        _this._viewContainerRef = _viewContainerRef;
        _this._animationMode = _animationMode;
        _this._hideToggle = false;
        /**
         * An event emitted after the body's expansion animation happens.
         */
        _this.afterExpand = new core.EventEmitter();
        /**
         * An event emitted after the body's collapse animation happens.
         */
        _this.afterCollapse = new core.EventEmitter();
        /**
         * Stream that emits for changes in `\@Input` properties.
         */
        _this._inputChanges = new rxjs.Subject();
        /**
         * ID for the associated header element. Used for a11y labelling.
         */
        _this._headerId = "mat-expansion-panel-header-" + uniqueId++;
        /**
         * Stream of body animation done events.
         */
        _this._bodyAnimationDone = new rxjs.Subject();
        _this.accordion = accordion$$1;
        _this._document = _document;
        // We need a Subject with distinctUntilChanged, because the `done` event
        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084
        _this._bodyAnimationDone.pipe(operators.distinctUntilChanged((/**
         * @param {?} x
         * @param {?} y
         * @return {?}
         */
        function (x, y) {
            return x.fromState === y.fromState && x.toState === y.toState;
        }))).subscribe((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (event.fromState !== 'void') {
                if (event.toState === 'expanded') {
                    _this.afterExpand.emit();
                }
                else if (event.toState === 'collapsed') {
                    _this.afterCollapse.emit();
                }
            }
        }));
        if (defaultOptions) {
            _this.hideToggle = defaultOptions.hideToggle;
        }
        return _this;
    }
    Object.defineProperty(MatExpansionPanel.prototype, "hideToggle", {
        /** Whether the toggle indicator should be hidden. */
        get: /**
         * Whether the toggle indicator should be hidden.
         * @return {?}
         */
        function () {
            return this._hideToggle || (this.accordion && this.accordion.hideToggle);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hideToggle = coercion.coerceBooleanProperty(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatExpansionPanel.prototype, "togglePosition", {
        /** The position of the expansion indicator. */
        get: /**
         * The position of the expansion indicator.
         * @return {?}
         */
        function () {
            return this._togglePosition || (this.accordion && this.accordion.togglePosition);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._togglePosition = value;
        },
        enumerable: true,
        configurable: true
    });
    /** Determines whether the expansion panel should have spacing between it and its siblings. */
    /**
     * Determines whether the expansion panel should have spacing between it and its siblings.
     * @return {?}
     */
    MatExpansionPanel.prototype._hasSpacing = /**
     * Determines whether the expansion panel should have spacing between it and its siblings.
     * @return {?}
     */
    function () {
        if (this.accordion) {
            // We don't need to subscribe to the `stateChanges` of the parent accordion because each time
            // the [displayMode] input changes, the change detection will also cover the host bindings
            // of this expansion panel.
            return (this.expanded ? this.accordion.displayMode : this._getExpandedState()) === 'default';
        }
        return false;
    };
    /** Gets the expanded state string. */
    /**
     * Gets the expanded state string.
     * @return {?}
     */
    MatExpansionPanel.prototype._getExpandedState = /**
     * Gets the expanded state string.
     * @return {?}
     */
    function () {
        return this.expanded ? 'expanded' : 'collapsed';
    };
    /**
     * @return {?}
     */
    MatExpansionPanel.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._lazyContent) {
            // Render the content as soon as the panel becomes open.
            this.opened.pipe(operators.startWith((/** @type {?} */ (null))), operators.filter((/**
             * @return {?}
             */
            function () { return _this.expanded && !_this._portal; })), operators.take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._portal = new portal.TemplatePortal(_this._lazyContent._template, _this._viewContainerRef);
            }));
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MatExpansionPanel.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this._inputChanges.next(changes);
    };
    /**
     * @return {?}
     */
    MatExpansionPanel.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        this._bodyAnimationDone.complete();
        this._inputChanges.complete();
    };
    /** Checks whether the expansion panel's content contains the currently-focused element. */
    /**
     * Checks whether the expansion panel's content contains the currently-focused element.
     * @return {?}
     */
    MatExpansionPanel.prototype._containsFocus = /**
     * Checks whether the expansion panel's content contains the currently-focused element.
     * @return {?}
     */
    function () {
        if (this._body) {
            /** @type {?} */
            var focusedElement = this._document.activeElement;
            /** @type {?} */
            var bodyElement = this._body.nativeElement;
            return focusedElement === bodyElement || bodyElement.contains(focusedElement);
        }
        return false;
    };
    /** @nocollapse */
    MatExpansionPanel.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.SkipSelf }, { type: core.Inject, args: [MAT_ACCORDION,] }] },
        { type: core.ChangeDetectorRef },
        { type: collections.UniqueSelectionDispatcher },
        { type: core.ViewContainerRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
        { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations$1.ANIMATION_MODULE_TYPE,] }] },
        { type: undefined, decorators: [{ type: core.Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: core.Optional }] }
    ]; };
    MatExpansionPanel.propDecorators = {
        hideToggle: [{ type: core.Input }],
        togglePosition: [{ type: core.Input }],
        afterExpand: [{ type: core.Output }],
        afterCollapse: [{ type: core.Output }],
        _lazyContent: [{ type: core.ContentChild, args: [MatExpansionPanelContent, { static: false },] }],
        _body: [{ type: core.ViewChild, args: ['body', { static: false },] }]
    };
MatExpansionPanel.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: MatExpansionPanel, selectors: [["mat-expansion-panel"]], factory: function MatExpansionPanel_Factory(t) { return new (t || MatExpansionPanel)(ɵngcc0.ɵɵdirectiveInject(MAT_ACCORDION, 12), ɵngcc0.ɵɵdirectiveInject(core.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(collections.UniqueSelectionDispatcher), ɵngcc0.ɵɵdirectiveInject(core.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(common.DOCUMENT), ɵngcc0.ɵɵdirectiveInject(animations$1.ANIMATION_MODULE_TYPE, 8), ɵngcc0.ɵɵdirectiveInject(MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, 8)); }, contentQueries: function MatExpansionPanel_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MatExpansionPanelContent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx._lazyContent = _t.first);
    } }, viewQuery: function MatExpansionPanel_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadViewQuery()) && (ctx._body = _t.first);
    } }, hostBindings: function MatExpansionPanel_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(3);
        ɵngcc0.ɵɵelementHostAttrs(_c1);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("mat-expanded", ctx.expanded);
        ɵngcc0.ɵɵclassProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
        ɵngcc0.ɵɵclassProp("mat-expansion-panel-spacing", ctx._hasSpacing());
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { disabled: "disabled", expanded: "expanded", hideToggle: "hideToggle", togglePosition: "togglePosition" }, outputs: { opened: "opened", closed: "closed", expandedChange: "expandedChange", afterExpand: "afterExpand", afterCollapse: "afterCollapse" }, exportAs: ["matExpansionPanel"], features: [ɵngcc0.ɵɵProvidersFeature([
            // Provide MatAccordion as undefined to prevent nested expansion panels from registering
            // to the same accordion.
            { provide: MAT_ACCORDION, useValue: ɵ0 },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c7, consts: 7, vars: 4, template: function MatExpansionPanel_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c6);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", _c2, _c3);
        ɵngcc0.ɵɵlistener("@bodyExpansion.done", function MatExpansionPanel_Template_div_animation_bodyExpansion_done_1_listener($event) { return ctx._bodyAnimationDone.next($event); });
        ɵngcc0.ɵɵelementStart(3, "div", _c4);
        ɵngcc0.ɵɵprojection(4, 1);
        ɵngcc0.ɵɵtemplate(5, MatExpansionPanel_ng_template_5_Template, 0, 0, "ng-template", _c5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(6, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(1);
        ɵngcc0.ɵɵproperty("@bodyExpansion", ctx._getExpandedState())("id", ctx.id);
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx._headerId);
        ɵngcc0.ɵɵselect(5);
        ɵngcc0.ɵɵproperty("cdkPortalOutlet", ctx._portal);
    } }, directives: [ɵngcc1.CdkPortalOutlet], styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(.4,0,.2,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}@media (-ms-high-contrast:active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel._mat-animation-noopable,.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}"], encapsulation: 2, data: { animation: [matExpansionAnimations.bodyExpansion] }, changeDetection: 0 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatExpansionPanel, [{
        type: core.Component,
        args: [{ styles: [".mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(.4,0,.2,1),box-shadow 280ms cubic-bezier(.4,0,.2,1)}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}@media (-ms-high-contrast:active){.mat-expansion-panel{outline:solid 1px}}.mat-expansion-panel._mat-animation-noopable,.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row button.mat-button-base{margin-left:8px}[dir=rtl] .mat-action-row button.mat-button-base{margin-left:0;margin-right:8px}"],
                selector: 'mat-expansion-panel',
                exportAs: 'matExpansionPanel',
                template: "<ng-content select=\"mat-expansion-panel-header\"></ng-content><div class=\"mat-expansion-panel-content\" role=\"region\" [@bodyExpansion]=\"_getExpandedState()\" (@bodyExpansion.done)=\"_bodyAnimationDone.next($event)\" [attr.aria-labelledby]=\"_headerId\" [id]=\"id\" #body><div class=\"mat-expansion-panel-body\"><ng-content></ng-content><ng-template [cdkPortalOutlet]=\"_portal\"></ng-template></div><ng-content select=\"mat-action-row\"></ng-content></div>",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                inputs: ['disabled', 'expanded'],
                outputs: ['opened', 'closed', 'expandedChange'],
                animations: [matExpansionAnimations.bodyExpansion],
                providers: [
                    // Provide MatAccordion as undefined to prevent nested expansion panels from registering
                    // to the same accordion.
                    { provide: MAT_ACCORDION, useValue: ɵ0 },
                ],
                host: {
                    'class': 'mat-expansion-panel',
                    '[class.mat-expanded]': 'expanded',
                    '[class._mat-animation-noopable]': '_animationMode === "NoopAnimations"',
                    '[class.mat-expansion-panel-spacing]': '_hasSpacing()'
                }
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: core.Optional
            }, {
                type: core.SkipSelf
            }, {
                type: core.Inject,
                args: [MAT_ACCORDION]
            }] }, { type: core.ChangeDetectorRef }, { type: collections.UniqueSelectionDispatcher }, { type: core.ViewContainerRef }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [common.DOCUMENT]
            }] }, { type: String, decorators: [{
                type: core.Optional
            }, {
                type: core.Inject,
                args: [animations$1.ANIMATION_MODULE_TYPE]
            }] }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS]
            }, {
                type: core.Optional
            }] }]; }, { hideToggle: [{
            type: core.Input
        }], hideToggle: [], togglePosition: [{
            type: core.Input
        }], togglePosition: [], _hasSpacing: [], _getExpandedState: [], ngAfterContentInit: [], ngOnChanges: [], ngOnDestroy: [], _containsFocus: [], afterExpand: [{
            type: core.Output
        }], afterCollapse: [{
            type: core.Output
        }], _lazyContent: [{
            type: core.ContentChild,
            args: [MatExpansionPanelContent, { static: false }]
        }], _body: [{
            type: core.ViewChild,
            args: ['body', { static: false }]
        }] });
    return MatExpansionPanel;
}(accordion.CdkAccordionItem));
var MatExpansionPanelActionRow = /** @class */ (function () {
    function MatExpansionPanelActionRow() {
    }
MatExpansionPanelActionRow.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: MatExpansionPanelActionRow, selectors: [["mat-action-row"]], factory: function MatExpansionPanelActionRow_Factory(t) { return new (t || MatExpansionPanelActionRow)(); }, hostBindings: function MatExpansionPanelActionRow_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵelementHostAttrs(_c8);
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatExpansionPanelActionRow, [{
        type: core.Directive,
        args: [{
                selector: 'mat-action-row',
                host: {
                    class: 'mat-action-row'
                }
            }]
    }], function () { return []; }, null);
    return MatExpansionPanelActionRow;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * `<mat-expansion-panel-header>`
 *
 * This component corresponds to the header element of an `<mat-expansion-panel>`.
 */
var MatExpansionPanelHeader = /** @class */ (function () {
    function MatExpansionPanelHeader(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions) {
        var _this = this;
        this.panel = panel;
        this._element = _element;
        this._focusMonitor = _focusMonitor;
        this._changeDetectorRef = _changeDetectorRef;
        this._parentChangeSubscription = rxjs.Subscription.EMPTY;
        /**
         * Whether Angular animations in the panel header should be disabled.
         */
        this._animationsDisabled = true;
        /** @type {?} */
        var accordionHideToggleChange = panel.accordion ?
            panel.accordion._stateChanges.pipe(operators.filter((/**
             * @param {?} changes
             * @return {?}
             */
            function (changes) { return !!(changes['hideToggle'] || changes['togglePosition']); }))) :
            rxjs.EMPTY;
        // Since the toggle state depends on an @Input on the panel, we
        // need to subscribe and trigger change detection manually.
        this._parentChangeSubscription =
            rxjs.merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(operators.filter((/**
             * @param {?} changes
             * @return {?}
             */
            function (changes) {
                return !!(changes['hideToggle'] ||
                    changes['disabled'] ||
                    changes['togglePosition']);
            }))))
                .subscribe((/**
             * @return {?}
             */
            function () { return _this._changeDetectorRef.markForCheck(); }));
        // Avoids focus being lost if the panel contained the focused element and was closed.
        panel.closed
            .pipe(operators.filter((/**
         * @return {?}
         */
        function () { return panel._containsFocus(); })))
            .subscribe((/**
         * @return {?}
         */
        function () { return _focusMonitor.focusVia(_element, 'program'); }));
        _focusMonitor.monitor(_element).subscribe((/**
         * @param {?} origin
         * @return {?}
         */
        function (origin) {
            if (origin && panel.accordion) {
                panel.accordion._handleHeaderFocus(_this);
            }
        }));
        if (defaultOptions) {
            this.expandedHeight = defaultOptions.expandedHeight;
            this.collapsedHeight = defaultOptions.collapsedHeight;
        }
    }
    /**
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._animationStarted = /**
     * @return {?}
     */
    function () {
        // Currently the `expansionHeight` animation has a `void => collapsed` transition which is
        // there to work around a bug in Angular (see #13088), however this introduces a different
        // issue. The new transition will cause the header to animate in on init (see #16067), if the
        // consumer has set a header height that is different from the default one. We work around it
        // by disabling animations on the header and re-enabling them after the first animation has run.
        // Note that Angular dispatches animation events even if animations are disabled. Ideally this
        // wouldn't be necessary if we remove the `void => collapsed` transition, but we have to wait
        // for https://github.com/angular/angular/issues/18847 to be resolved.
        this._animationsDisabled = false;
    };
    Object.defineProperty(MatExpansionPanelHeader.prototype, "disabled", {
        /**
         * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
         * @docs-private
         */
        get: /**
         * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
         * \@docs-private
         * @return {?}
         */
        function () {
            return this.panel.disabled;
        },
        enumerable: true,
        configurable: true
    });
    /** Toggles the expanded state of the panel. */
    /**
     * Toggles the expanded state of the panel.
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._toggle = /**
     * Toggles the expanded state of the panel.
     * @return {?}
     */
    function () {
        this.panel.toggle();
    };
    /** Gets whether the panel is expanded. */
    /**
     * Gets whether the panel is expanded.
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._isExpanded = /**
     * Gets whether the panel is expanded.
     * @return {?}
     */
    function () {
        return this.panel.expanded;
    };
    /** Gets the expanded state string of the panel. */
    /**
     * Gets the expanded state string of the panel.
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._getExpandedState = /**
     * Gets the expanded state string of the panel.
     * @return {?}
     */
    function () {
        return this.panel._getExpandedState();
    };
    /** Gets the panel id. */
    /**
     * Gets the panel id.
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._getPanelId = /**
     * Gets the panel id.
     * @return {?}
     */
    function () {
        return this.panel.id;
    };
    /** Gets the toggle position for the header. */
    /**
     * Gets the toggle position for the header.
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._getTogglePosition = /**
     * Gets the toggle position for the header.
     * @return {?}
     */
    function () {
        return this.panel.togglePosition;
    };
    /** Gets whether the expand indicator should be shown. */
    /**
     * Gets whether the expand indicator should be shown.
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._showToggle = /**
     * Gets whether the expand indicator should be shown.
     * @return {?}
     */
    function () {
        return !this.panel.hideToggle && !this.panel.disabled;
    };
    /** Handle keydown event calling to toggle() if appropriate. */
    /**
     * Handle keydown event calling to toggle() if appropriate.
     * @param {?} event
     * @return {?}
     */
    MatExpansionPanelHeader.prototype._keydown = /**
     * Handle keydown event calling to toggle() if appropriate.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.keyCode) {
            // Toggle for space and enter keys.
            case keycodes.SPACE:
            case keycodes.ENTER:
                if (!keycodes.hasModifierKey(event)) {
                    event.preventDefault();
                    this._toggle();
                }
                break;
            default:
                if (this.panel.accordion) {
                    this.panel.accordion._handleHeaderKeydown(event);
                }
                return;
        }
    };
    /**
     * Focuses the panel header. Implemented as a part of `FocusableOption`.
     * @param origin Origin of the action that triggered the focus.
     * @docs-private
     */
    /**
     * Focuses the panel header. Implemented as a part of `FocusableOption`.
     * \@docs-private
     * @param {?=} origin Origin of the action that triggered the focus.
     * @param {?=} options
     * @return {?}
     */
    MatExpansionPanelHeader.prototype.focus = /**
     * Focuses the panel header. Implemented as a part of `FocusableOption`.
     * \@docs-private
     * @param {?=} origin Origin of the action that triggered the focus.
     * @param {?=} options
     * @return {?}
     */
    function (origin, options) {
        if (origin === void 0) { origin = 'program'; }
        this._focusMonitor.focusVia(this._element, origin, options);
    };
    /**
     * @return {?}
     */
    MatExpansionPanelHeader.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._parentChangeSubscription.unsubscribe();
        this._focusMonitor.stopMonitoring(this._element);
    };
    /** @nocollapse */
    MatExpansionPanelHeader.ctorParameters = function () { return [
        { type: MatExpansionPanel, decorators: [{ type: core.Host }] },
        { type: core.ElementRef },
        { type: a11y.FocusMonitor },
        { type: core.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS,] }, { type: core.Optional }] }
    ]; };
    MatExpansionPanelHeader.propDecorators = {
        expandedHeight: [{ type: core.Input }],
        collapsedHeight: [{ type: core.Input }]
    };
MatExpansionPanelHeader.ngComponentDef = ɵngcc0.ɵɵdefineComponent({ type: MatExpansionPanelHeader, selectors: [["mat-expansion-panel-header"]], factory: function MatExpansionPanelHeader_Factory(t) { return new (t || MatExpansionPanelHeader)(ɵngcc0.ɵɵdirectiveInject(MatExpansionPanel, 1), ɵngcc0.ɵɵdirectiveInject(core.ElementRef), ɵngcc0.ɵɵdirectiveInject(a11y.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(core.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, 8)); }, hostBindings: function MatExpansionPanelHeader_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵallocHostVars(16);
        ɵngcc0.ɵɵlistener("click", function MatExpansionPanelHeader_click_HostBindingHandler($event) { return ctx._toggle(); });
        ɵngcc0.ɵɵlistener("keydown", function MatExpansionPanelHeader_keydown_HostBindingHandler($event) { return ctx._keydown($event); });
        ɵngcc0.ɵɵcomponentHostSyntheticListener("@expansionHeight.start", function MatExpansionPanelHeader_animation_expansionHeight_start_HostBindingHandler($event) { return ctx._animationStarted(); });
        ɵngcc0.ɵɵelementHostAttrs(_c11);
        ɵngcc0.ɵɵstyling();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("id", ctx.panel._headerId)("tabindex", ctx.disabled ? 0 - 1 : 0)("aria-controls", ctx._getPanelId())("aria-expanded", ctx._isExpanded())("aria-disabled", ctx.panel.disabled);
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@.disabled", ctx._animationsDisabled)("@expansionHeight", ɵngcc0.ɵɵpureFunction2(13, _c10, ctx._getExpandedState(), ɵngcc0.ɵɵpureFunction2(10, _c9, ctx.collapsedHeight, ctx.expandedHeight)));
        ɵngcc0.ɵɵclassProp("mat-expanded", ctx._isExpanded());
        ɵngcc0.ɵɵclassProp("mat-expansion-toggle-indicator-after", ctx._getTogglePosition() === "after");
        ɵngcc0.ɵɵclassProp("mat-expansion-toggle-indicator-before", ctx._getTogglePosition() === "before");
        ɵngcc0.ɵɵstylingApply();
    } }, inputs: { expandedHeight: "expandedHeight", collapsedHeight: "collapsedHeight" }, ngContentSelectors: _c16, consts: 5, vars: 1, template: function MatExpansionPanelHeader_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c15);
        ɵngcc0.ɵɵelementStart(0, "span", _c12);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵprojection(3, 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(4, MatExpansionPanelHeader_span_4_Template, 1, 1, "span", _c13);
    } if (rf & 2) {
        ɵngcc0.ɵɵselect(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx._showToggle());
    } }, directives: [ɵngcc2.NgIf], styles: [".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-description,.mat-expansion-panel-header-title{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-description,[dir=rtl] .mat-expansion-panel-header-title{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:'';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}"], encapsulation: 2, data: { animation: [
            matExpansionAnimations.indicatorRotate,
            matExpansionAnimations.expansionHeaderHeight
        ] }, changeDetection: 0 });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatExpansionPanelHeader, [{
        type: core.Component,
        args: [{ selector: 'mat-expansion-panel-header',
                styles: [".mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:0}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-description,.mat-expansion-panel-header-title{display:flex;flex-grow:1;margin-right:16px}[dir=rtl] .mat-expansion-panel-header-description,[dir=rtl] .mat-expansion-panel-header-title{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:'';display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}"],
                template: "<span class=\"mat-content\"><ng-content select=\"mat-panel-title\"></ng-content><ng-content select=\"mat-panel-description\"></ng-content><ng-content></ng-content></span><span [@indicatorRotate]=\"_getExpandedState()\" *ngIf=\"_showToggle()\" class=\"mat-expansion-indicator\"></span>",
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                animations: [
                    matExpansionAnimations.indicatorRotate,
                    matExpansionAnimations.expansionHeaderHeight
                ],
                host: {
                    'class': 'mat-expansion-panel-header',
                    'role': 'button',
                    '[attr.id]': 'panel._headerId',
                    '[attr.tabindex]': 'disabled ? -1 : 0',
                    '[attr.aria-controls]': '_getPanelId()',
                    '[attr.aria-expanded]': '_isExpanded()',
                    '[attr.aria-disabled]': 'panel.disabled',
                    '[class.mat-expanded]': '_isExpanded()',
                    '[class.mat-expansion-toggle-indicator-after]': "_getTogglePosition() === 'after'",
                    '[class.mat-expansion-toggle-indicator-before]': "_getTogglePosition() === 'before'",
                    '(click)': '_toggle()',
                    '(keydown)': '_keydown($event)',
                    '[@.disabled]': '_animationsDisabled',
                    '(@expansionHeight.start)': '_animationStarted()',
                    '[@expansionHeight]': "{\n        value: _getExpandedState(),\n        params: {\n          collapsedHeight: collapsedHeight,\n          expandedHeight: expandedHeight\n        }\n    }"
                }
            }]
    }], function () { return [{ type: MatExpansionPanel, decorators: [{
                type: core.Host
            }] }, { type: core.ElementRef }, { type: a11y.FocusMonitor }, { type: core.ChangeDetectorRef }, { type: undefined, decorators: [{
                type: core.Inject,
                args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS]
            }, {
                type: core.Optional
            }] }]; }, { panel: [], _element: [], _focusMonitor: [], _changeDetectorRef: [], _parentChangeSubscription: [], _animationsDisabled: [], expandedHeight: [{
            type: core.Input
        }], collapsedHeight: [{
            type: core.Input
        }], _animationStarted: [], disabled: [], _toggle: [], _isExpanded: [], _getExpandedState: [], _getPanelId: [], _getTogglePosition: [], _showToggle: [], _keydown: [], focus: [], ngOnDestroy: [] });
    return MatExpansionPanelHeader;
}());
/**
 * `<mat-panel-description>`
 *
 * This directive is to be used inside of the MatExpansionPanelHeader component.
 */
var MatExpansionPanelDescription = /** @class */ (function () {
    function MatExpansionPanelDescription() {
    }
MatExpansionPanelDescription.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: MatExpansionPanelDescription, selectors: [["mat-panel-description"]], factory: function MatExpansionPanelDescription_Factory(t) { return new (t || MatExpansionPanelDescription)(); }, hostBindings: function MatExpansionPanelDescription_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵelementHostAttrs(_c17);
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatExpansionPanelDescription, [{
        type: core.Directive,
        args: [{
                selector: 'mat-panel-description',
                host: {
                    class: 'mat-expansion-panel-header-description'
                }
            }]
    }], function () { return []; }, null);
    return MatExpansionPanelDescription;
}());
/**
 * `<mat-panel-title>`
 *
 * This directive is to be used inside of the MatExpansionPanelHeader component.
 */
var MatExpansionPanelTitle = /** @class */ (function () {
    function MatExpansionPanelTitle() {
    }
MatExpansionPanelTitle.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: MatExpansionPanelTitle, selectors: [["mat-panel-title"]], factory: function MatExpansionPanelTitle_Factory(t) { return new (t || MatExpansionPanelTitle)(); }, hostBindings: function MatExpansionPanelTitle_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵelementHostAttrs(_c18);
    } } });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatExpansionPanelTitle, [{
        type: core.Directive,
        args: [{
                selector: 'mat-panel-title',
                host: {
                    class: 'mat-expansion-panel-header-title'
                }
            }]
    }], function () { return []; }, null);
    return MatExpansionPanelTitle;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive for a Material Design Accordion.
 */
var MatAccordion = /** @class */ (function (_super) {
    __extends(MatAccordion, _super);
    function MatAccordion() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._hideToggle = false;
        /**
         * Display mode used for all expansion panels in the accordion. Currently two display
         * modes exist:
         *  default - a gutter-like spacing is placed around any expanded panel, placing the expanded
         *     panel at a different elevation from the rest of the accordion.
         *  flat - no spacing is placed around expanded panels, showing all panels at the same
         *     elevation.
         */
        _this.displayMode = 'default';
        /**
         * The position of the expansion indicator.
         */
        _this.togglePosition = 'after';
        return _this;
    }
    Object.defineProperty(MatAccordion.prototype, "hideToggle", {
        /** Whether the expansion indicator should be hidden. */
        get: /**
         * Whether the expansion indicator should be hidden.
         * @return {?}
         */
        function () { return this._hideToggle; },
        set: /**
         * @param {?} show
         * @return {?}
         */
        function (show) { this._hideToggle = coercion.coerceBooleanProperty(show); },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MatAccordion.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this._keyManager = new a11y.FocusKeyManager(this._headers).withWrap();
    };
    /** Handles keyboard events coming in from the panel headers. */
    /**
     * Handles keyboard events coming in from the panel headers.
     * @param {?} event
     * @return {?}
     */
    MatAccordion.prototype._handleHeaderKeydown = /**
     * Handles keyboard events coming in from the panel headers.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var keyCode = event.keyCode;
        /** @type {?} */
        var manager = this._keyManager;
        if (keyCode === keycodes.HOME) {
            if (!keycodes.hasModifierKey(event)) {
                manager.setFirstItemActive();
                event.preventDefault();
            }
        }
        else if (keyCode === keycodes.END) {
            if (!keycodes.hasModifierKey(event)) {
                manager.setLastItemActive();
                event.preventDefault();
            }
        }
        else {
            this._keyManager.onKeydown(event);
        }
    };
    /**
     * @param {?} header
     * @return {?}
     */
    MatAccordion.prototype._handleHeaderFocus = /**
     * @param {?} header
     * @return {?}
     */
    function (header) {
        this._keyManager.updateActiveItem(header);
    };
    MatAccordion.propDecorators = {
        _headers: [{ type: core.ContentChildren, args: [MatExpansionPanelHeader, { descendants: true },] }],
        hideToggle: [{ type: core.Input }],
        displayMode: [{ type: core.Input }],
        togglePosition: [{ type: core.Input }]
    };
MatAccordion.ngDirectiveDef = ɵngcc0.ɵɵdefineDirective({ type: MatAccordion, selectors: [["mat-accordion"]], factory: function MatAccordion_Factory(t) { return ɵMatAccordion_BaseFactory(t || MatAccordion); }, contentQueries: function MatAccordion_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, MatExpansionPanelHeader, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadContentQuery()) && (ctx._headers = _t);
    } }, hostBindings: function MatAccordion_HostBindings(rf, ctx, elIndex) { if (rf & 1) {
        ɵngcc0.ɵɵelementHostAttrs(_c19);
    } }, inputs: { multi: "multi", hideToggle: "hideToggle", displayMode: "displayMode", togglePosition: "togglePosition" }, exportAs: ["matAccordion"], features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: MAT_ACCORDION,
                useExisting: MatAccordion
            }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵMatAccordion_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatAccordion);
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatAccordion, [{
        type: core.Directive,
        args: [{
                selector: 'mat-accordion',
                exportAs: 'matAccordion',
                inputs: ['multi'],
                providers: [{
                        provide: MAT_ACCORDION,
                        useExisting: MatAccordion
                    }],
                host: {
                    class: 'mat-accordion'
                }
            }]
    }], null, { hideToggle: [{
            type: core.Input
        }], hideToggle: [], ngAfterContentInit: [], _keyManager: [], _handleHeaderKeydown: [], _handleHeaderFocus: [], _headers: [{
            type: core.ContentChildren,
            args: [MatExpansionPanelHeader, { descendants: true }]
        }], displayMode: [{
            type: core.Input
        }], togglePosition: [{
            type: core.Input
        }] });
    return MatAccordion;
}(accordion.CdkAccordion));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MatExpansionModule = /** @class */ (function () {
    function MatExpansionModule() {
    }
MatExpansionModule.ngModuleDef = ɵngcc0.ɵɵdefineNgModule({ type: MatExpansionModule });
/*@__PURE__*/ ɵngcc0.ɵɵsetNgModuleScope(MatExpansionModule, { declarations: [MatAccordion,
        MatExpansionPanel,
        MatExpansionPanelActionRow,
        MatExpansionPanelHeader,
        MatExpansionPanelTitle,
        MatExpansionPanelDescription,
        MatExpansionPanelContent], imports: [ɵngcc2.CommonModule, ɵngcc3.CdkAccordionModule, ɵngcc1.PortalModule], exports: [MatAccordion,
        MatExpansionPanel,
        MatExpansionPanelActionRow,
        MatExpansionPanelHeader,
        MatExpansionPanelTitle,
        MatExpansionPanelDescription,
        MatExpansionPanelContent] });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(MatExpansionModule, [{
        type: core.NgModule,
        args: [{
                imports: [common.CommonModule, accordion.CdkAccordionModule, portal.PortalModule],
                exports: [
                    MatAccordion,
                    MatExpansionPanel,
                    MatExpansionPanelActionRow,
                    MatExpansionPanelHeader,
                    MatExpansionPanelTitle,
                    MatExpansionPanelDescription,
                    MatExpansionPanelContent,
                ],
                declarations: [
                    MatAccordion,
                    MatExpansionPanel,
                    MatExpansionPanelActionRow,
                    MatExpansionPanelHeader,
                    MatExpansionPanelTitle,
                    MatExpansionPanelDescription,
                    MatExpansionPanelContent,
                ]
            }]
    }], function () { return []; }, null);
MatExpansionModule.ngInjectorDef = ɵngcc0.ɵɵdefineInjector({ factory: function MatExpansionModule_Factory(t) { return new (t || MatExpansionModule)(); }, imports: [[common.CommonModule, accordion.CdkAccordionModule, portal.PortalModule]] });
    return MatExpansionModule;
}());

exports.MatExpansionModule = MatExpansionModule;
exports.MatAccordion = MatAccordion;
exports.MAT_ACCORDION = MAT_ACCORDION;
exports.MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = MAT_EXPANSION_PANEL_DEFAULT_OPTIONS;
exports.MatExpansionPanel = MatExpansionPanel;
exports.MatExpansionPanelActionRow = MatExpansionPanelActionRow;
exports.MatExpansionPanelHeader = MatExpansionPanelHeader;
exports.MatExpansionPanelDescription = MatExpansionPanelDescription;
exports.MatExpansionPanelTitle = MatExpansionPanelTitle;
exports.MatExpansionPanelContent = MatExpansionPanelContent;
exports.EXPANSION_PANEL_ANIMATION_TIMING = EXPANSION_PANEL_ANIMATION_TIMING;
exports.matExpansionAnimations = matExpansionAnimations;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=material-expansion.umd.js.map
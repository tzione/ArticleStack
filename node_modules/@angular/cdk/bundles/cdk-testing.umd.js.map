{"version":3,"sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/@angular/cdk/bundles/cdk-testing.umd.js"],"names":[],"mappings":"AAAA","file":"cdk-testing.umd.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define('@angular/cdk/testing', ['exports'], factory) :\n\t(factory((global.ng = global.ng || {}, global.ng.cdk = global.ng.cdk || {}, global.ng.cdk.testing = {})));\n}(this, (function (exports) { 'use strict';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Creates a browser MouseEvent with the specified options.\n * \\@docs-private\n * @param {?} type\n * @param {?=} x\n * @param {?=} y\n * @param {?=} button\n * @return {?}\n */\nfunction createMouseEvent(type, x, y, button) {\n    if (x === void 0) { x = 0; }\n    if (y === void 0) { y = 0; }\n    if (button === void 0) { button = 0; }\n    /** @type {?} */\n    var event = document.createEvent('MouseEvent');\n    /** @type {?} */\n    var originalPreventDefault = event.preventDefault;\n    event.initMouseEvent(type, true, /* canBubble */ true, /* cancelable */ window, /* view */ 0, /* detail */ x, /* screenX */ y, /* screenY */ x, /* clientX */ y, /* clientY */ false, /* ctrlKey */ false, /* altKey */ false, /* shiftKey */ false, /* metaKey */ button, /* button */ null /* relatedTarget */);\n    // `initMouseEvent` doesn't allow us to pass the `buttons` and\n    // defaults it to 0 which looks like a fake event.\n    Object.defineProperty(event, 'buttons', { get: (/**\n         * @return {?}\n         */\n        function () { return 1; }) });\n    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.\n    event.preventDefault = (/**\n     * @return {?}\n     */\n    function () {\n        Object.defineProperty(event, 'defaultPrevented', { get: (/**\n             * @return {?}\n             */\n            function () { return true; }) });\n        return originalPreventDefault.apply(this, arguments);\n    });\n    return event;\n}\n/**\n * Creates a browser TouchEvent with the specified pointer coordinates.\n * \\@docs-private\n * @param {?} type\n * @param {?=} pageX\n * @param {?=} pageY\n * @return {?}\n */\nfunction createTouchEvent(type, pageX, pageY) {\n    if (pageX === void 0) { pageX = 0; }\n    if (pageY === void 0) { pageY = 0; }\n    // In favor of creating events that work for most of the browsers, the event is created\n    // as a basic UI Event. The necessary details for the event will be set manually.\n    /** @type {?} */\n    var event = document.createEvent('UIEvent');\n    /** @type {?} */\n    var touchDetails = { pageX: pageX, pageY: pageY };\n    // TS3.6 removes the initUIEvent method and suggests porting to \"new UIEvent()\".\n    ((/** @type {?} */ (event))).initUIEvent(type, true, true, window, 0);\n    // Most of the browsers don't have a \"initTouchEvent\" method that can be used to define\n    // the touch details.\n    Object.defineProperties(event, {\n        touches: { value: [touchDetails] },\n        targetTouches: { value: [touchDetails] },\n        changedTouches: { value: [touchDetails] }\n    });\n    return event;\n}\n/**\n * Dispatches a keydown event from an element.\n * \\@docs-private\n * @param {?} type\n * @param {?=} keyCode\n * @param {?=} key\n * @param {?=} target\n * @param {?=} modifiers\n * @return {?}\n */\nfunction createKeyboardEvent(type, keyCode, key, target, modifiers) {\n    if (keyCode === void 0) { keyCode = 0; }\n    if (key === void 0) { key = ''; }\n    if (modifiers === void 0) { modifiers = {}; }\n    /** @type {?} */\n    var event = (/** @type {?} */ (document.createEvent('KeyboardEvent')));\n    /** @type {?} */\n    var originalPreventDefault = event.preventDefault;\n    // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.\n    if (event.initKeyEvent) {\n        event.initKeyEvent(type, true, true, window, modifiers.control, modifiers.alt, modifiers.shift, modifiers.meta, keyCode);\n    }\n    else {\n        // `initKeyboardEvent` expects to receive modifiers as a whitespace-delimited string\n        // See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent\n        /** @type {?} */\n        var modifiersStr = (modifiers.control ? 'Control ' : '' + modifiers.alt ? 'Alt ' : '' +\n            modifiers.shift ? 'Shift ' : '' + modifiers.meta ? 'Meta' : '').trim();\n        event.initKeyboardEvent(type, true, /* canBubble */ true, /* cancelable */ window, /* view */ 0, /* char */ key, /* key */ 0, /* location */ modifiersStr, /* modifiersList */ false /* repeat */);\n    }\n    // Webkit Browsers don't set the keyCode when calling the init function.\n    // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735\n    Object.defineProperties(event, {\n        keyCode: { get: (/**\n             * @return {?}\n             */\n            function () { return keyCode; }) },\n        key: { get: (/**\n             * @return {?}\n             */\n            function () { return key; }) },\n        target: { get: (/**\n             * @return {?}\n             */\n            function () { return target; }) },\n        ctrlKey: { get: (/**\n             * @return {?}\n             */\n            function () { return !!modifiers.control; }) },\n        altKey: { get: (/**\n             * @return {?}\n             */\n            function () { return !!modifiers.alt; }) },\n        shiftKey: { get: (/**\n             * @return {?}\n             */\n            function () { return !!modifiers.shift; }) },\n        metaKey: { get: (/**\n             * @return {?}\n             */\n            function () { return !!modifiers.meta; }) }\n    });\n    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.\n    event.preventDefault = (/**\n     * @return {?}\n     */\n    function () {\n        Object.defineProperty(event, 'defaultPrevented', { get: (/**\n             * @return {?}\n             */\n            function () { return true; }) });\n        return originalPreventDefault.apply(this, arguments);\n    });\n    return event;\n}\n/**\n * Creates a fake event object with any desired event type.\n * \\@docs-private\n * @param {?} type\n * @param {?=} canBubble\n * @param {?=} cancelable\n * @return {?}\n */\nfunction createFakeEvent(type, canBubble, cancelable) {\n    if (canBubble === void 0) { canBubble = false; }\n    if (cancelable === void 0) { cancelable = true; }\n    /** @type {?} */\n    var event = document.createEvent('Event');\n    event.initEvent(type, canBubble, cancelable);\n    return event;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Utility to dispatch any event on a Node.\n * \\@docs-private\n * @param {?} node\n * @param {?} event\n * @return {?}\n */\nfunction dispatchEvent(node, event) {\n    node.dispatchEvent(event);\n    return event;\n}\n/**\n * Shorthand to dispatch a fake event on a specified node.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} canBubble\n * @return {?}\n */\nfunction dispatchFakeEvent(node, type, canBubble) {\n    return dispatchEvent(node, createFakeEvent(type, canBubble));\n}\n/**\n * Shorthand to dispatch a keyboard event with a specified key code.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} keyCode\n * @param {?=} key\n * @param {?=} target\n * @param {?=} modifiers\n * @return {?}\n */\nfunction dispatchKeyboardEvent(node, type, keyCode, key, target, modifiers) {\n    return (/** @type {?} */ (dispatchEvent(node, createKeyboardEvent(type, keyCode, key, target, modifiers))));\n}\n/**\n * Shorthand to dispatch a mouse event on the specified coordinates.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} x\n * @param {?=} y\n * @param {?=} event\n * @return {?}\n */\nfunction dispatchMouseEvent(node, type, x, y, event) {\n    if (x === void 0) { x = 0; }\n    if (y === void 0) { y = 0; }\n    if (event === void 0) { event = createMouseEvent(type, x, y); }\n    return (/** @type {?} */ (dispatchEvent(node, event)));\n}\n/**\n * Shorthand to dispatch a touch event on the specified coordinates.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} x\n * @param {?=} y\n * @return {?}\n */\nfunction dispatchTouchEvent(node, type, x, y) {\n    if (x === void 0) { x = 0; }\n    if (y === void 0) { y = 0; }\n    return dispatchEvent(node, createTouchEvent(type, x, y));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?} event\n * @return {?}\n */\nfunction triggerFocusChange(element, event) {\n    /** @type {?} */\n    var eventFired = false;\n    /** @type {?} */\n    var handler = (/**\n     * @return {?}\n     */\n    function () { return eventFired = true; });\n    element.addEventListener(event, handler);\n    element[event]();\n    element.removeEventListener(event, handler);\n    if (!eventFired) {\n        dispatchFakeEvent(element, event);\n    }\n}\n/**\n * Patches an elements focus and blur methods to emit events consistently and predictably.\n * This is necessary, because some browsers, like IE11, will call the focus handlers asynchronously,\n * while others won't fire them at all if the browser window is not focused.\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction patchElementFocus(element) {\n    element.focus = (/**\n     * @return {?}\n     */\n    function () { return dispatchFakeEvent(element, 'focus'); });\n    element.blur = (/**\n     * @return {?}\n     */\n    function () { return dispatchFakeEvent(element, 'blur'); });\n}\n/**\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction triggerFocus(element) {\n    triggerFocusChange(element, 'focus');\n}\n/**\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction triggerBlur(element) {\n    triggerFocusChange(element, 'blur');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given Element is a text input element.\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction isTextInput(element) {\n    return element.nodeName.toLowerCase() === 'input' ||\n        element.nodeName.toLowerCase() === 'textarea';\n}\n/**\n * @param {?} element\n * @param {...?} modifiersAndKeys\n * @return {?}\n */\nfunction typeInElement(element) {\n    var modifiersAndKeys = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        modifiersAndKeys[_i - 1] = arguments[_i];\n    }\n    /** @type {?} */\n    var first = modifiersAndKeys[0];\n    /** @type {?} */\n    var modifiers;\n    /** @type {?} */\n    var rest;\n    if (typeof first !== 'string' && first.keyCode === undefined && first.key === undefined) {\n        modifiers = first;\n        rest = modifiersAndKeys.slice(1);\n    }\n    else {\n        modifiers = {};\n        rest = modifiersAndKeys;\n    }\n    /** @type {?} */\n    var keys = rest\n        .map((/**\n     * @param {?} k\n     * @return {?}\n     */\n    function (k) { return typeof k === 'string' ?\n        k.split('').map((/**\n         * @param {?} c\n         * @return {?}\n         */\n        function (c) { return ({ keyCode: c.toUpperCase().charCodeAt(0), key: c }); })) : [k]; }))\n        .reduce((/**\n     * @param {?} arr\n     * @param {?} k\n     * @return {?}\n     */\n    function (arr, k) { return arr.concat(k); }), []);\n    triggerFocus(element);\n    for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {\n        var key = keys_1[_a];\n        dispatchKeyboardEvent(element, 'keydown', key.keyCode, key.key, element, modifiers);\n        dispatchKeyboardEvent(element, 'keypress', key.keyCode, key.key, element, modifiers);\n        if (isTextInput(element) && key.key && key.key.length === 1) {\n            element.value += key.key;\n            dispatchFakeEvent(element, 'input');\n        }\n        dispatchKeyboardEvent(element, 'keyup', key.keyCode, key.key, element, modifiers);\n    }\n}\n/**\n * Clears the text in an input or textarea element.\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction clearElement(element) {\n    triggerFocus((/** @type {?} */ (element)));\n    element.value = '';\n    dispatchFakeEvent(element, 'input');\n}\n\nexports.dispatchEvent = dispatchEvent;\nexports.dispatchFakeEvent = dispatchFakeEvent;\nexports.dispatchKeyboardEvent = dispatchKeyboardEvent;\nexports.dispatchMouseEvent = dispatchMouseEvent;\nexports.dispatchTouchEvent = dispatchTouchEvent;\nexports.createMouseEvent = createMouseEvent;\nexports.createTouchEvent = createTouchEvent;\nexports.createKeyboardEvent = createKeyboardEvent;\nexports.createFakeEvent = createFakeEvent;\nexports.isTextInput = isTextInput;\nexports.typeInElement = typeInElement;\nexports.clearElement = clearElement;\nexports.patchElementFocus = patchElementFocus;\nexports.triggerFocus = triggerFocus;\nexports.triggerBlur = triggerBlur;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"]}
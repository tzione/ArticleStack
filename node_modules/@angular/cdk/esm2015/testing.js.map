{"version":3,"sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/@angular/cdk/esm2015/testing.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;AAoBA","file":"testing.js","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Creates a browser MouseEvent with the specified options.\n * \\@docs-private\n * @param {?} type\n * @param {?=} x\n * @param {?=} y\n * @param {?=} button\n * @return {?}\n */\nfunction createMouseEvent(type, x = 0, y = 0, button = 0) {\n    /** @type {?} */\n    const event = document.createEvent('MouseEvent');\n    /** @type {?} */\n    const originalPreventDefault = event.preventDefault;\n    event.initMouseEvent(type, true, /* canBubble */ true, /* cancelable */ window, /* view */ 0, /* detail */ x, /* screenX */ y, /* screenY */ x, /* clientX */ y, /* clientY */ false, /* ctrlKey */ false, /* altKey */ false, /* shiftKey */ false, /* metaKey */ button, /* button */ null /* relatedTarget */);\n    // `initMouseEvent` doesn't allow us to pass the `buttons` and\n    // defaults it to 0 which looks like a fake event.\n    Object.defineProperty(event, 'buttons', { get: (/**\n         * @return {?}\n         */\n        () => 1) });\n    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.\n    event.preventDefault = (/**\n     * @return {?}\n     */\n    function () {\n        Object.defineProperty(event, 'defaultPrevented', { get: (/**\n             * @return {?}\n             */\n            () => true) });\n        return originalPreventDefault.apply(this, arguments);\n    });\n    return event;\n}\n/**\n * Creates a browser TouchEvent with the specified pointer coordinates.\n * \\@docs-private\n * @param {?} type\n * @param {?=} pageX\n * @param {?=} pageY\n * @return {?}\n */\nfunction createTouchEvent(type, pageX = 0, pageY = 0) {\n    // In favor of creating events that work for most of the browsers, the event is created\n    // as a basic UI Event. The necessary details for the event will be set manually.\n    /** @type {?} */\n    const event = document.createEvent('UIEvent');\n    /** @type {?} */\n    const touchDetails = { pageX, pageY };\n    // TS3.6 removes the initUIEvent method and suggests porting to \"new UIEvent()\".\n    ((/** @type {?} */ (event))).initUIEvent(type, true, true, window, 0);\n    // Most of the browsers don't have a \"initTouchEvent\" method that can be used to define\n    // the touch details.\n    Object.defineProperties(event, {\n        touches: { value: [touchDetails] },\n        targetTouches: { value: [touchDetails] },\n        changedTouches: { value: [touchDetails] }\n    });\n    return event;\n}\n/**\n * Dispatches a keydown event from an element.\n * \\@docs-private\n * @param {?} type\n * @param {?=} keyCode\n * @param {?=} key\n * @param {?=} target\n * @param {?=} modifiers\n * @return {?}\n */\nfunction createKeyboardEvent(type, keyCode = 0, key = '', target, modifiers = {}) {\n    /** @type {?} */\n    const event = (/** @type {?} */ (document.createEvent('KeyboardEvent')));\n    /** @type {?} */\n    const originalPreventDefault = event.preventDefault;\n    // Firefox does not support `initKeyboardEvent`, but supports `initKeyEvent`.\n    if (event.initKeyEvent) {\n        event.initKeyEvent(type, true, true, window, modifiers.control, modifiers.alt, modifiers.shift, modifiers.meta, keyCode);\n    }\n    else {\n        // `initKeyboardEvent` expects to receive modifiers as a whitespace-delimited string\n        // See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/initKeyboardEvent\n        /** @type {?} */\n        const modifiersStr = (modifiers.control ? 'Control ' : '' + modifiers.alt ? 'Alt ' : '' +\n            modifiers.shift ? 'Shift ' : '' + modifiers.meta ? 'Meta' : '').trim();\n        event.initKeyboardEvent(type, true, /* canBubble */ true, /* cancelable */ window, /* view */ 0, /* char */ key, /* key */ 0, /* location */ modifiersStr, /* modifiersList */ false /* repeat */);\n    }\n    // Webkit Browsers don't set the keyCode when calling the init function.\n    // See related bug https://bugs.webkit.org/show_bug.cgi?id=16735\n    Object.defineProperties(event, {\n        keyCode: { get: (/**\n             * @return {?}\n             */\n            () => keyCode) },\n        key: { get: (/**\n             * @return {?}\n             */\n            () => key) },\n        target: { get: (/**\n             * @return {?}\n             */\n            () => target) },\n        ctrlKey: { get: (/**\n             * @return {?}\n             */\n            () => !!modifiers.control) },\n        altKey: { get: (/**\n             * @return {?}\n             */\n            () => !!modifiers.alt) },\n        shiftKey: { get: (/**\n             * @return {?}\n             */\n            () => !!modifiers.shift) },\n        metaKey: { get: (/**\n             * @return {?}\n             */\n            () => !!modifiers.meta) }\n    });\n    // IE won't set `defaultPrevented` on synthetic events so we need to do it manually.\n    event.preventDefault = (/**\n     * @return {?}\n     */\n    function () {\n        Object.defineProperty(event, 'defaultPrevented', { get: (/**\n             * @return {?}\n             */\n            () => true) });\n        return originalPreventDefault.apply(this, arguments);\n    });\n    return event;\n}\n/**\n * Creates a fake event object with any desired event type.\n * \\@docs-private\n * @param {?} type\n * @param {?=} canBubble\n * @param {?=} cancelable\n * @return {?}\n */\nfunction createFakeEvent(type, canBubble = false, cancelable = true) {\n    /** @type {?} */\n    const event = document.createEvent('Event');\n    event.initEvent(type, canBubble, cancelable);\n    return event;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Utility to dispatch any event on a Node.\n * \\@docs-private\n * @param {?} node\n * @param {?} event\n * @return {?}\n */\nfunction dispatchEvent(node, event) {\n    node.dispatchEvent(event);\n    return event;\n}\n/**\n * Shorthand to dispatch a fake event on a specified node.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} canBubble\n * @return {?}\n */\nfunction dispatchFakeEvent(node, type, canBubble) {\n    return dispatchEvent(node, createFakeEvent(type, canBubble));\n}\n/**\n * Shorthand to dispatch a keyboard event with a specified key code.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} keyCode\n * @param {?=} key\n * @param {?=} target\n * @param {?=} modifiers\n * @return {?}\n */\nfunction dispatchKeyboardEvent(node, type, keyCode, key, target, modifiers) {\n    return (/** @type {?} */ (dispatchEvent(node, createKeyboardEvent(type, keyCode, key, target, modifiers))));\n}\n/**\n * Shorthand to dispatch a mouse event on the specified coordinates.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} x\n * @param {?=} y\n * @param {?=} event\n * @return {?}\n */\nfunction dispatchMouseEvent(node, type, x = 0, y = 0, event = createMouseEvent(type, x, y)) {\n    return (/** @type {?} */ (dispatchEvent(node, event)));\n}\n/**\n * Shorthand to dispatch a touch event on the specified coordinates.\n * \\@docs-private\n * @param {?} node\n * @param {?} type\n * @param {?=} x\n * @param {?=} y\n * @return {?}\n */\nfunction dispatchTouchEvent(node, type, x = 0, y = 0) {\n    return dispatchEvent(node, createTouchEvent(type, x, y));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} element\n * @param {?} event\n * @return {?}\n */\nfunction triggerFocusChange(element, event) {\n    /** @type {?} */\n    let eventFired = false;\n    /** @type {?} */\n    const handler = (/**\n     * @return {?}\n     */\n    () => eventFired = true);\n    element.addEventListener(event, handler);\n    element[event]();\n    element.removeEventListener(event, handler);\n    if (!eventFired) {\n        dispatchFakeEvent(element, event);\n    }\n}\n/**\n * Patches an elements focus and blur methods to emit events consistently and predictably.\n * This is necessary, because some browsers, like IE11, will call the focus handlers asynchronously,\n * while others won't fire them at all if the browser window is not focused.\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction patchElementFocus(element) {\n    element.focus = (/**\n     * @return {?}\n     */\n    () => dispatchFakeEvent(element, 'focus'));\n    element.blur = (/**\n     * @return {?}\n     */\n    () => dispatchFakeEvent(element, 'blur'));\n}\n/**\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction triggerFocus(element) {\n    triggerFocusChange(element, 'focus');\n}\n/**\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction triggerBlur(element) {\n    triggerFocusChange(element, 'blur');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Checks whether the given Element is a text input element.\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction isTextInput(element) {\n    return element.nodeName.toLowerCase() === 'input' ||\n        element.nodeName.toLowerCase() === 'textarea';\n}\n/**\n * @param {?} element\n * @param {...?} modifiersAndKeys\n * @return {?}\n */\nfunction typeInElement(element, ...modifiersAndKeys) {\n    /** @type {?} */\n    const first = modifiersAndKeys[0];\n    /** @type {?} */\n    let modifiers;\n    /** @type {?} */\n    let rest;\n    if (typeof first !== 'string' && first.keyCode === undefined && first.key === undefined) {\n        modifiers = first;\n        rest = modifiersAndKeys.slice(1);\n    }\n    else {\n        modifiers = {};\n        rest = modifiersAndKeys;\n    }\n    /** @type {?} */\n    const keys = rest\n        .map((/**\n     * @param {?} k\n     * @return {?}\n     */\n    k => typeof k === 'string' ?\n        k.split('').map((/**\n         * @param {?} c\n         * @return {?}\n         */\n        c => ({ keyCode: c.toUpperCase().charCodeAt(0), key: c }))) : [k]))\n        .reduce((/**\n     * @param {?} arr\n     * @param {?} k\n     * @return {?}\n     */\n    (arr, k) => arr.concat(k)), []);\n    triggerFocus(element);\n    for (const key of keys) {\n        dispatchKeyboardEvent(element, 'keydown', key.keyCode, key.key, element, modifiers);\n        dispatchKeyboardEvent(element, 'keypress', key.keyCode, key.key, element, modifiers);\n        if (isTextInput(element) && key.key && key.key.length === 1) {\n            element.value += key.key;\n            dispatchFakeEvent(element, 'input');\n        }\n        dispatchKeyboardEvent(element, 'keyup', key.keyCode, key.key, element, modifiers);\n    }\n}\n/**\n * Clears the text in an input or textarea element.\n * \\@docs-private\n * @param {?} element\n * @return {?}\n */\nfunction clearElement(element) {\n    triggerFocus((/** @type {?} */ (element)));\n    element.value = '';\n    dispatchFakeEvent(element, 'input');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { dispatchEvent, dispatchFakeEvent, dispatchKeyboardEvent, dispatchMouseEvent, dispatchTouchEvent, createMouseEvent, createTouchEvent, createKeyboardEvent, createFakeEvent, isTextInput, typeInElement, clearElement, patchElementFocus, triggerFocus, triggerBlur };\n"]}
{"version":3,"file":"router.d.ts","sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/@angular/router/router.d.ts"],"sourcesContent":["/**\n * @license Angular v8.2.13\n * (c) 2010-2019 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { AfterContentInit } from '@angular/core';\nimport { ApplicationRef } from '@angular/core';\nimport { ChangeDetectorRef } from '@angular/core';\nimport { Compiler } from '@angular/core';\nimport { ComponentFactoryResolver } from '@angular/core';\nimport { ComponentRef } from '@angular/core';\nimport { ElementRef } from '@angular/core';\nimport { EventEmitter } from '@angular/core';\nimport { HashLocationStrategy } from '@angular/common';\nimport { InjectionToken } from '@angular/core';\nimport { Injector } from '@angular/core';\nimport { Location } from '@angular/common';\nimport { LocationStrategy } from '@angular/common';\nimport { ModuleWithProviders } from '@angular/core';\nimport { NgModuleFactory } from '@angular/core';\nimport { NgModuleFactoryLoader } from '@angular/core';\nimport { NgProbeToken } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { OnChanges } from '@angular/core';\nimport { OnDestroy } from '@angular/core';\nimport { OnInit } from '@angular/core';\nimport { PathLocationStrategy } from '@angular/common';\nimport { PlatformLocation } from '@angular/common';\nimport { Provider } from '@angular/core';\nimport { QueryList } from '@angular/core';\nimport { Renderer2 } from '@angular/core';\nimport { SimpleChanges } from '@angular/core';\nimport { Type } from '@angular/core';\nimport { Version } from '@angular/core';\nimport { ViewContainerRef } from '@angular/core';\nimport { ViewportScroller } from '@angular/common';\n\n/**\n * Provides access to information about a route associated with a component\n * that is loaded in an outlet.\n * Use to traverse the `RouterState` tree and extract information from nodes.\n *\n * {@example router/activated-route/module.ts region=\"activated-route\"\n *     header=\"activated-route.component.ts\"}\n *\n * @publicApi\n */\nexport declare class ActivatedRoute {\n    /** An observable of the URL segments matched by this route. */\n    url: Observable<UrlSegment[]>;\n    /** An observable of the matrix parameters scoped to this route. */\n    params: Observable<Params>;\n    /** An observable of the query parameters shared by all the routes. */\n    queryParams: Observable<Params>;\n    /** An observable of the URL fragment shared by all the routes. */\n    fragment: Observable<string>;\n    /** An observable of the static and resolved data of this route. */\n    data: Observable<Data>;\n    /** The outlet name of the route, a constant. */\n    outlet: string;\n    /** The component of the route, a constant. */\n    component: Type<any> | string | null;\n    /** The current snapshot of this route */\n    snapshot: ActivatedRouteSnapshot;\n    /** The configuration used to match this route. */\n    readonly routeConfig: Route | null;\n    /** The root of the router state. */\n    readonly root: ActivatedRoute;\n    /** The parent of this route in the router state tree. */\n    readonly parent: ActivatedRoute | null;\n    /** The first child of this route in the router state tree. */\n    readonly firstChild: ActivatedRoute | null;\n    /** The children of this route in the router state tree. */\n    readonly children: ActivatedRoute[];\n    /** The path from the root of the router state tree to this route. */\n    readonly pathFromRoot: ActivatedRoute[];\n    /** An Observable that contains a map of the required and optional parameters\n     * specific to the route.\n     * The map supports retrieving single and multiple values from the same parameter. */\n    readonly paramMap: Observable<ParamMap>;\n    /**\n     * An Observable that contains a map of the query parameters available to all routes.\n     * The map supports retrieving single and multiple values from the query parameter.\n     */\n    readonly queryParamMap: Observable<ParamMap>;\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Contains the information about a route associated with a component loaded in an\n * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to\n * traverse the router state tree.\n *\n * ```\n * @Component({templateUrl:'./my-component.html'})\n * class MyComponent {\n *   constructor(route: ActivatedRoute) {\n *     const id: string = route.snapshot.params.id;\n *     const url: string = route.snapshot.url.join('');\n *     const user = route.snapshot.data.user;\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class ActivatedRouteSnapshot {\n    /** The URL segments matched by this route */\n    url: UrlSegment[];\n    /** The matrix parameters scoped to this route */\n    params: Params;\n    /** The query parameters shared by all the routes */\n    queryParams: Params;\n    /** The URL fragment shared by all the routes */\n    fragment: string;\n    /** The static and resolved data of this route */\n    data: Data;\n    /** The outlet name of the route */\n    outlet: string;\n    /** The component of the route */\n    component: Type<any> | string | null;\n    /** The configuration used to match this route **/\n    readonly routeConfig: Route | null;\n    /** The root of the router state */\n    readonly root: ActivatedRouteSnapshot;\n    /** The parent of this route in the router state tree */\n    readonly parent: ActivatedRouteSnapshot | null;\n    /** The first child of this route in the router state tree */\n    readonly firstChild: ActivatedRouteSnapshot | null;\n    /** The children of this route in the router state tree */\n    readonly children: ActivatedRouteSnapshot[];\n    /** The path from the root of the router state tree to this route */\n    readonly pathFromRoot: ActivatedRouteSnapshot[];\n    readonly paramMap: ParamMap;\n    readonly queryParamMap: ParamMap;\n    toString(): string;\n}\n\n/**\n * An event triggered at the end of the activation part\n * of the Resolve phase of routing.\n * @see `ActivationStart`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ActivationEnd {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the activation part\n * of the Resolve phase of routing.\n * @see ActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ActivationStart {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be activated.\n * If all guards return `true`, navigation will continue. If any guard returns `false`,\n * navigation will be cancelled. If any guard returns a `UrlTree`, current navigation will\n * be cancelled and a new navigation will be kicked off to the `UrlTree` returned from the\n * guard.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivate {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivate(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: [CanActivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canActivate` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canActivate: ['canActivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanActivate {\n    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a child route can be activated.\n * If all guards return `true`, navigation will continue. If any guard returns `false`,\n * navigation will be cancelled. If any guard returns a `UrlTree`, current navigation will\n * be cancelled and a new navigation will be kicked off to the `UrlTree` returned from the\n * guard.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivateChild {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivateChild(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [CanActivateTeam],\n *         children: [\n *           {\n *              path: 'team/:id',\n *              component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canActivateChild` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: ['canActivateTeam'],\n *         children: [\n *           {\n *             path: 'team/:id',\n *             component: TeamComponent\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanActivateChild {\n    canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if a route can be deactivated.\n * If all guards return `true`, navigation will continue. If any guard returns `false`,\n * navigation will be cancelled. If any guard returns a `UrlTree`, current navigation will\n * be cancelled and a new navigation will be kicked off to the `UrlTree` returned from the\n * guard.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canDeactivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canDeactivate(\n *     component: TeamComponent,\n *     currentRoute: ActivatedRouteSnapshot,\n *     currentState: RouterStateSnapshot,\n *     nextState: RouterStateSnapshot\n *   ): Observable<boolean|UrlTree>|Promise<boolean|UrlTree>|boolean|UrlTree {\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: [CanDeactivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canDeactivate` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         canDeactivate: ['canDeactivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canDeactivateTeam',\n *       useValue: (component: TeamComponent, currentRoute: ActivatedRouteSnapshot, currentState:\n * RouterStateSnapshot, nextState: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanDeactivate<T> {\n    canDeactivate(component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot, nextState?: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree;\n}\n\n/**\n * @description\n *\n * Interface that a class can implement to be a guard deciding if children can be loaded.\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canLoadChildren(user: UserToken, id: string, segments: UrlSegment[]): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanLoadTeamSection implements CanLoad {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canLoad(route: Route, segments: UrlSegment[]): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canLoadChildren(this.currentUser, route, segments);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: 'team.js',\n *         canLoad: [CanLoadTeamSection]\n *       }\n *     ])\n *   ],\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canLoad` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamComponent,\n *         loadChildren: 'team.js',\n *         canLoad: ['canLoadTeamSection']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canLoadTeamSection',\n *       useValue: (route: Route, segments: UrlSegment[]) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface CanLoad {\n    canLoad(route: Route, segments: UrlSegment[]): Observable<boolean> | Promise<boolean> | boolean;\n}\n\n/**\n * An event triggered at the end of the child-activation part\n * of the Resolve phase of routing.\n * @see `ChildActivationStart`\n * @see `ResolveStart` *\n * @publicApi\n */\nexport declare class ChildActivationEnd {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the child-activation\n * part of the Resolve phase of routing.\n * @see  `ChildActivationEnd`\n * @see `ResolveStart`\n *\n * @publicApi\n */\nexport declare class ChildActivationStart {\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    snapshot: ActivatedRouteSnapshot);\n    toString(): string;\n}\n\n/**\n * Store contextual information about the children (= nested) `RouterOutlet`\n *\n * @publicApi\n */\nexport declare class ChildrenOutletContexts {\n    private contexts;\n    /** Called when a `RouterOutlet` directive is instantiated */\n    onChildOutletCreated(childName: string, outlet: RouterOutlet): void;\n    /**\n     * Called when a `RouterOutlet` directive is destroyed.\n     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n     * re-created later.\n     */\n    onChildOutletDestroyed(childName: string): void;\n    /**\n     * Called when the corresponding route is deactivated during navigation.\n     * Because the component get destroyed, all children outlet are destroyed.\n     */\n    onOutletDeactivated(): Map<string, OutletContext>;\n    onOutletReAttached(contexts: Map<string, OutletContext>): void;\n    getOrCreateContext(childName: string): OutletContext;\n    getContext(childName: string): OutletContext | null;\n}\n\n/**\n * Converts a `Params` instance to a `ParamMap`.\n * @param params The instance to convert.\n * @returns The new map instance.\n *\n * @publicApi\n */\nexport declare function convertToParamMap(params: Params): ParamMap;\n\n/**\n *\n * Represents static data associated with a particular route.\n *\n * @see `Route#data`\n *\n * @publicApi\n */\nexport declare type Data = {\n    [name: string]: any;\n};\n\n/**\n * @description\n *\n * A default implementation of the `UrlSerializer`.\n *\n * Example URLs:\n *\n * ```\n * /inbox/33(popup:compose)\n * /inbox/33;open=true/messages/44\n * ```\n *\n * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the\n * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to\n * specify route specific parameters.\n *\n * @publicApi\n */\nexport declare class DefaultUrlSerializer implements UrlSerializer {\n    /** Parses a url into a `UrlTree` */\n    parse(url: string): UrlTree;\n    /** Converts a `UrlTree` into a url */\n    serialize(tree: UrlTree): string;\n}\n\n/**\n * A string of the form `path/to/file#exportName` that acts as a URL for a set of routes to load.\n *\n * @see `Route#loadChildren`\n * @publicApi\n * @deprecated the `string` form of `loadChildren` is deprecated in favor of the proposed ES dynamic\n * `import()` expression, which offers a more natural and standards-based mechanism to dynamically\n * load an ES module at runtime.\n */\nexport declare type DeprecatedLoadChildren = string;\n\n/**\n * @description\n *\n * Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @publicApi\n */\nexport declare type DetachedRouteHandle = {};\n\n/**\n * Error handler that is invoked when a navigation error occurs.\n *\n * If the handler returns a value, the navigation promise is resolved with this value.\n * If the handler throws an exception, the navigation promise is rejected with\n * the exception.\n *\n * @publicApi\n */\ndeclare type ErrorHandler = (error: any) => any;\n\n/**\n * Router events that allow you to track the lifecycle of the router.\n *\n * The sequence of router events is as follows:\n *\n * - `NavigationStart`,\n * - `RouteConfigLoadStart`,\n * - `RouteConfigLoadEnd`,\n * - `RoutesRecognized`,\n * - `GuardsCheckStart`,\n * - `ChildActivationStart`,\n * - `ActivationStart`,\n * - `GuardsCheckEnd`,\n * - `ResolveStart`,\n * - `ResolveEnd`,\n * - `ActivationEnd`\n * - `ChildActivationEnd`\n * - `NavigationEnd`,\n * - `NavigationCancel`,\n * - `NavigationError`\n * - `Scroll`\n *\n * @publicApi\n */\nexport declare type Event = RouterEvent | RouteConfigLoadStart | RouteConfigLoadEnd | ChildActivationStart | ChildActivationEnd | ActivationStart | ActivationEnd | Scroll;\n\n/**\n * A set of configuration options for a router module, provided in the\n * `forRoot()` method.\n *\n * @publicApi\n */\nexport declare interface ExtraOptions {\n    /**\n     * When true, log all internal navigation events to the console.\n     * Use for debugging.\n     */\n    enableTracing?: boolean;\n    /**\n     * When true, enable the location strategy that uses the URL fragment\n     * instead of the history API.\n     */\n    useHash?: boolean;\n    /**\n     * One of `enabled` or `disabled`.\n     * When set to `enabled`, the initial navigation starts before the root component is created.\n     * The bootstrap is blocked until the initial navigation is complete. This value is required for\n     * [server-side rendering](guide/universal) to work.\n     * When set to `disabled`, the initial navigation is not performed.\n     * The location listener is set up before the root component gets created.\n     * Use if there is a reason to have more control over when the router\n     * starts its initial navigation due to some complex initialization logic.\n     *\n     * Legacy values are deprecated since v4 and should not be used for new applications:\n     *\n     * * `legacy_enabled` - Default for compatibility.\n     * The initial navigation starts after the root component has been created,\n     * but the bootstrap is not blocked until the initial navigation is complete.\n     * * `legacy_disabled` - The initial navigation is not performed.\n     * The location listener is set up after the root component gets created.\n     * * `true` - same as `legacy_enabled`.\n     * * `false` - same as `legacy_disabled`.\n     */\n    initialNavigation?: InitialNavigation;\n    /**\n     * A custom error handler for failed navigations.\n     */\n    errorHandler?: ErrorHandler;\n    /**\n     * Configures a preloading strategy.\n     * One of `PreloadAllModules` or `NoPreloading` (the default).\n     */\n    preloadingStrategy?: any;\n    /**\n     * Define what the router should do if it receives a navigation request to the current URL.\n     * Default is `ignore`, which causes the router ignores the navigation.\n     * This can disable features such as a \"refresh\" button.\n     * Use this option to configure the behavior when navigating to the\n     * current URL. Default is 'ignore'.\n     */\n    onSameUrlNavigation?: 'reload' | 'ignore';\n    /**\n     * Configures if the scroll position needs to be restored when navigating back.\n     *\n     * * 'disabled'- (Default) Does nothing. Scroll position is maintained on navigation.\n     * * 'top'- Sets the scroll position to x = 0, y = 0 on all navigation.\n     * * 'enabled'- Restores the previous scroll position on backward navigation, else sets the\n     * position to the anchor if one is provided, or sets the scroll position to [0, 0] (forward\n     * navigation). This option will be the default in the future.\n     *\n     * You can implement custom scroll restoration behavior by adapting the enabled behavior as\n     * in the following example.\n     *\n     * ```typescript\n     * class AppModule {\n     *   constructor(router: Router, viewportScroller: ViewportScroller) {\n     *     router.events.pipe(\n     *       filter((e: Event): e is Scroll => e instanceof Scroll)\n     *     ).subscribe(e => {\n     *       if (e.position) {\n     *         // backward navigation\n     *         viewportScroller.scrollToPosition(e.position);\n     *       } else if (e.anchor) {\n     *         // anchor navigation\n     *         viewportScroller.scrollToAnchor(e.anchor);\n     *       } else {\n     *         // forward navigation\n     *         viewportScroller.scrollToPosition([0, 0]);\n     *       }\n     *     });\n     *   }\n     * }\n     * ```\n     */\n    scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n    /**\n     * When set to 'enabled', scrolls to the anchor element when the URL has a fragment.\n     * Anchor scrolling is disabled by default.\n     *\n     * Anchor scrolling does not happen on 'popstate'. Instead, we restore the position\n     * that we stored or scroll to the top.\n     */\n    anchorScrolling?: 'disabled' | 'enabled';\n    /**\n     * Configures the scroll offset the router will use when scrolling to an element.\n     *\n     * When given a tuple with x and y position value,\n     * the router uses that offset each time it scrolls.\n     * When given a function, the router invokes the function every time\n     * it restores scroll position.\n     */\n    scrollOffset?: [number, number] | (() => [number, number]);\n    /**\n     * Defines how the router merges parameters, data, and resolved data from parent to child\n     * routes. By default ('emptyOnly'), inherits parent parameters only for\n     * path-less or component-less routes.\n     * Set to 'always' to enable unconditional inheritance of parent parameters.\n     */\n    paramsInheritanceStrategy?: 'emptyOnly' | 'always';\n    /**\n     * A custom handler for malformed URI errors. The handler is invoked when `encodedURI` contains\n     * invalid character sequences.\n     * The default implementation is to redirect to the root URL, dropping\n     * any path or parameter information. The function takes three parameters:\n     *\n     * - `'URIError'` - Error thrown when parsing a bad URL.\n     * - `'UrlSerializer'` - UrlSerializer that’s configured with the router.\n     * - `'url'` -  The malformed URL that caused the URIError\n     * */\n    malformedUriErrorHandler?: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n    /**\n     * Defines when the router updates the browser URL. By default ('deferred'),\n     * update after successful navigation.\n     * Set to 'eager' if prefer to update the URL at the beginning of navigation.\n     * Updating the URL early allows you to handle a failure of navigation by\n     * showing an error message with the URL that failed.\n     */\n    urlUpdateStrategy?: 'deferred' | 'eager';\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * Example:\n     *\n     * ```\n     * const routes = [\n     *   {\n     *     path: '',\n     *     component: ContainerComponent,\n     *     children: [\n     *       { path: 'a', component: AComponent },\n     *       { path: 'b', component: BComponent },\n     *     ]\n     *   }\n     * ];\n     * ```\n     *\n     * From the `ContainerComponent`, this will not work:\n     *\n     * `<a [routerLink]=\"['./a']\">Link to A</a>`\n     *\n     * However, this will work:\n     *\n     * `<a [routerLink]=\"['../a']\">Link to A</a>`\n     *\n     * In other words, you're required to use `../` rather than `./`. This is currently the default\n     * behavior. Setting this option to `corrected` enables the fix.\n     */\n    relativeLinkResolution?: 'legacy' | 'corrected';\n}\n\n/**\n * An event triggered at the end of the Guard phase of routing.\n *\n * @publicApi\n */\nexport declare class GuardsCheckEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    /** @docsNotRequired */\n    shouldActivate: boolean;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot, \n    /** @docsNotRequired */\n    shouldActivate: boolean);\n    toString(): string;\n}\n\n/**\n * An event triggered at the start of the Guard phase of routing.\n *\n * @publicApi\n */\nexport declare class GuardsCheckStart extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * Allowed values in an `ExtraOptions` object that configure\n * when the router performs the initial navigation operation.\n *\n * * 'enabled' - The initial navigation starts before the root component is created.\n * The bootstrap is blocked until the initial navigation is complete. This value is required\n * for [server-side rendering](guide/universal) to work.\n * * 'disabled' - The initial navigation is not performed. The location listener is set up before\n * the root component gets created. Use if there is a reason to have\n * more control over when the router starts its initial navigation due to some complex\n * initialization logic.\n * * 'legacy_enabled'- (Default, for compatibility.) The initial navigation starts after the root component has been created.\n * The bootstrap is not blocked until the initial navigation is complete. @deprecated\n * * 'legacy_disabled'- The initial navigation is not performed. The location listener is set up\n * after the root component gets created. @deprecated since v4\n * * `true` - same as 'legacy_enabled'. @deprecated since v4\n * * `false` - same as 'legacy_disabled'. @deprecated since v4\n *\n * The 'legacy_enabled' and 'legacy_disabled' should not be used for new applications.\n *\n * @see `forRoot()`\n *\n * @publicApi\n */\nexport declare type InitialNavigation = true | false | 'enabled' | 'disabled' | 'legacy_enabled' | 'legacy_disabled';\n\n/**\n *\n * A string of the form `path/to/file#exportName` that acts as a URL for a set of routes to load,\n * or a function that returns such a set.\n *\n * The string form of `LoadChildren` is deprecated (see `DeprecatedLoadChildren`). The function\n * form (`LoadChildrenCallback`) should be used instead.\n *\n * @see `Route#loadChildren`.\n * @publicApi\n */\nexport declare type LoadChildren = LoadChildrenCallback | DeprecatedLoadChildren;\n\n/**\n *\n * A function that is called to resolve a collection of lazy-loaded routes.\n *\n * Often this function will be implemented using an ES dynamic `import()` expression. For example:\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * This function _must_ match the form above: an arrow function of the form\n * `() => import('...').then(mod => mod.MODULE)`.\n *\n * @see `Route#loadChildren`.\n * @publicApi\n */\nexport declare type LoadChildrenCallback = () => Type<any> | NgModuleFactory<any> | Observable<Type<any>> | Promise<NgModuleFactory<any> | Type<any> | any>;\n\n/**\n * Information about a navigation operation. Retrieve the most recent\n * navigation object with the `router.getCurrentNavigation()` method.\n *\n * @publicApi\n */\nexport declare type Navigation = {\n    /**\n     * The ID of the current navigation.\n     */\n    id: number;\n    /**\n     * The target URL passed into the `Router#navigateByUrl()` call before navigation. This is\n     * the value before the router has parsed or applied redirects to it.\n     */\n    initialUrl: string | UrlTree;\n    /**\n     * The initial target URL after being parsed with `UrlSerializer.extract()`.\n     */\n    extractedUrl: UrlTree;\n    /**\n     * The extracted URL after redirects have been applied.\n     * This URL may not be available immediately, therefore this property can be `undefined`.\n     * It is guaranteed to be set after the `RoutesRecognized` event fires.\n     */\n    finalUrl?: UrlTree;\n    /**\n     * Identifies how this navigation was triggered.\n     *\n     * * 'imperative'--Triggered by `router.navigateByUrl` or `router.navigate`.\n     * * 'popstate'--Triggered by a popstate event.\n     * * 'hashchange'--Triggered by a hashchange event.\n     */\n    trigger: 'imperative' | 'popstate' | 'hashchange';\n    /**\n     * Options that controlled the strategy used for this navigation.\n     * See `NavigationExtras`.\n     */\n    extras: NavigationExtras;\n    /**\n     * The previously successful `Navigation` object. Only one previous navigation\n     * is available, therefore this previous `Navigation` object has a `null` value\n     * for its own `previousNavigation`.\n     */\n    previousNavigation: Navigation | null;\n};\n\n/**\n * An event triggered when a navigation is canceled, directly or indirectly.\n *\n * This can happen when a [route guard](guide/router#milestone-5-route-guards)\n * returns `false` or initiates a redirect by returning a `UrlTree`.\n *\n * @publicApi\n */\nexport declare class NavigationCancel extends RouterEvent {\n    /** @docsNotRequired */\n    reason: string;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    reason: string);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * An event triggered when a navigation ends successfully.\n *\n * @publicApi\n */\nexport declare class NavigationEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * An event triggered when a navigation fails due to an unexpected error.\n *\n * @publicApi\n */\nexport declare class NavigationError extends RouterEvent {\n    /** @docsNotRequired */\n    error: any;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    error: any);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Options that modify the navigation strategy.\n *\n * @publicApi\n */\nexport declare interface NavigationExtras {\n    /**\n     * Specifies a root URI to use for relative navigation.\n     *\n     * For example, consider the following route configuration where the parent route\n     * has two children.\n     *\n     * ```\n     * [{\n    *   path: 'parent',\n    *   component: ParentComponent,\n    *   children: [{\n    *     path: 'list',\n    *     component: ListComponent\n    *   },{\n    *     path: 'child',\n    *     component: ChildComponent\n    *   }]\n    * }]\n     * ```\n     *\n     * The following `go()` function navigates to the `list` route by\n     * interpreting the destination URI as relative to the activated `child`  route\n     *\n     * ```\n     *  @Component({...})\n     *  class ChildComponent {\n    *    constructor(private router: Router, private route: ActivatedRoute) {}\n    *\n    *    go() {\n    *      this.router.navigate(['../list'], { relativeTo: this.route });\n    *    }\n    *  }\n     * ```\n     */\n    relativeTo?: ActivatedRoute | null;\n    /**\n     * Sets query parameters to the URL.\n     *\n     * ```\n     * // Navigate to /results?page=1\n     * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n     * ```\n     */\n    queryParams?: Params | null;\n    /**\n     * Sets the hash fragment for the URL.\n     *\n     * ```\n     * // Navigate to /results#top\n     * this.router.navigate(['/results'], { fragment: 'top' });\n     * ```\n     */\n    fragment?: string;\n    /**\n     * **DEPRECATED**: Use `queryParamsHandling: \"preserve\"` instead to preserve\n     * query parameters for the next navigation.\n     *\n     * @deprecated since v4\n     */\n    preserveQueryParams?: boolean;\n    /**\n     * How to handle query parameters in the router link for the next navigation.\n     * One of:\n     * * `merge` : Merge new with current parameters.\n     * * `preserve` : Preserve current parameters.\n     *\n     * ```\n     * // from /results?page=1 to /view?page=1&page=2\n     * this.router.navigate(['/view'], { queryParams: { page: 2 },  queryParamsHandling: \"merge\" });\n     * ```\n     */\n    queryParamsHandling?: QueryParamsHandling | null;\n    /**\n     * When true, preserves the URL fragment for the next navigation\n     *\n     * ```\n     * // Preserve fragment from /results#top to /view#top\n     * this.router.navigate(['/view'], { preserveFragment: true });\n     * ```\n     */\n    preserveFragment?: boolean;\n    /**\n     * When true, navigates without pushing a new state into history.\n     *\n     * ```\n     * // Navigate silently to /view\n     * this.router.navigate(['/view'], { skipLocationChange: true });\n     * ```\n     */\n    skipLocationChange?: boolean;\n    /**\n     * When true, navigates while replacing the current state in history.\n     *\n     * ```\n     * // Navigate to /view\n     * this.router.navigate(['/view'], { replaceUrl: true });\n     * ```\n     */\n    replaceUrl?: boolean;\n    /**\n     * Developer-defined state that can be passed to any navigation.\n     * Access this value through the `Navigation.extras` object\n     * returned from `router.getCurrentNavigation()` while a navigation is executing.\n     *\n     * After a navigation completes, the router writes an object containing this\n     * value together with a `navigationId` to `history.state`.\n     * The value is written when `location.go()` or `location.replaceState()`\n     * is called before activating this route.\n     *\n     * Note that `history.state` does not pass an object equality test because\n     * the router adds the `navigationId` on each navigation.\n     */\n    state?: {\n        [k: string]: any;\n    };\n}\n\n/**\n * An event triggered when a navigation starts.\n *\n * @publicApi\n */\nexport declare class NavigationStart extends RouterEvent {\n    /**\n     * Identifies the call or event that triggered the navigation.\n     * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n     *\n     */\n    navigationTrigger?: 'imperative' | 'popstate' | 'hashchange';\n    /**\n     * The navigation state that was previously supplied to the `pushState` call,\n     * when the navigation is triggered by a `popstate` event. Otherwise null.\n     *\n     * The state object is defined by `NavigationExtras`, and contains any\n     * developer-defined state value, as well as a unique ID that\n     * the router assigns to every router transition/navigation.\n     *\n     * From the perspective of the router, the router never \"goes back\".\n     * When the user clicks on the back button in the browser,\n     * a new navigation ID is created.\n     *\n     * Use the ID in this previous-state object to differentiate between a newly created\n     * state and one returned to by a `popstate` event, so that you can restore some\n     * remembered state, such as scroll position.\n     *\n     */\n    restoredState?: {\n        [k: string]: any;\n        navigationId: number;\n    } | null;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    navigationTrigger?: 'imperative' | 'popstate' | 'hashchange', \n    /** @docsNotRequired */\n    restoredState?: {\n        [k: string]: any;\n        navigationId: number;\n    } | null);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy that does not preload any modules.\n *\n * This strategy is enabled by default.\n *\n * @publicApi\n */\nexport declare class NoPreloading implements PreloadingStrategy {\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * Store contextual information about a `RouterOutlet`\n *\n * @publicApi\n */\nexport declare class OutletContext {\n    outlet: RouterOutlet | null;\n    route: ActivatedRoute | null;\n    resolver: ComponentFactoryResolver | null;\n    children: ChildrenOutletContexts;\n    attachRef: ComponentRef<any> | null;\n}\n\n/**\n * A map that provides access to the required and optional parameters\n * specific to a route.\n * The map supports retrieving a single value with `get()`\n * or multiple values with `getAll()`.\n *\n * @see [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams)\n *\n * @publicApi\n */\nexport declare interface ParamMap {\n    /**\n     * Reports whether the map contains a given parameter.\n     * @param name The parameter name.\n     * @returns True if the map contains the given parameter, false otherwise.\n     */\n    has(name: string): boolean;\n    /**\n     * Retrieves a single value for a parameter.\n     * @param name The parameter name.\n     * @return The parameter's single value,\n     * or the first value if the parameter has multiple values,\n     * or `null` when there is no such parameter.\n     */\n    get(name: string): string | null;\n    /**\n     * Retrieves multiple values for a parameter.\n     * @param name The parameter name.\n     * @return An array containing one or more values,\n     * or an empty array if there is no such parameter.\n     *\n     */\n    getAll(name: string): string[];\n    /** Names of the parameters in the map. */\n    readonly keys: string[];\n}\n\n/**\n * A collection of matrix and query URL parameters.\n * @see `convertToParamMap()`\n * @see `ParamMap`\n *\n * @publicApi\n */\nexport declare type Params = {\n    [key: string]: any;\n};\n\n/**\n * @description\n *\n * Provides a preloading strategy that preloads all modules as quickly as possible.\n *\n * ```\n * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})\n * ```\n *\n * @publicApi\n */\nexport declare class PreloadAllModules implements PreloadingStrategy {\n    preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * @description\n *\n * Provides a preloading strategy.\n *\n * @publicApi\n */\nexport declare abstract class PreloadingStrategy {\n    abstract preload(route: Route, fn: () => Observable<any>): Observable<any>;\n}\n\n/**\n * The primary routing outlet.\n *\n * @publicApi\n */\nexport declare const PRIMARY_OUTLET = \"primary\";\n\n/**\n * Registers a [DI provider](guide/glossary#provider) for a set of routes.\n * @param routes The route configuration to provide.\n *\n * @usageNotes\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forChild(ROUTES)],\n *   providers: [provideRoutes(EXTRA_ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * @publicApi\n */\nexport declare function provideRoutes(routes: Routes): any;\n\n/**\n *\n * How to handle query parameters in a router link.\n * One of:\n * - `merge` : Merge new with current parameters.\n * - `preserve` : Preserve current parameters.\n *\n * @see `NavigationExtras#queryParamsHandling`\n * @see `RouterLink`\n * @publicApi\n */\nexport declare type QueryParamsHandling = 'merge' | 'preserve' | '';\n\n/**\n * @description\n *\n * Interface that classes can implement to be a data provider.\n * A data provider class can be used with the router to resolve data during navigation.\n * The interface defines a `resolve()` method that will be invoked when the navigation starts.\n * The router will then wait for the data to be resolved before the route is finally activated.\n *\n * ```\n * @Injectable({ providedIn: 'root' })\n * export class HeroResolver implements Resolve<Hero> {\n *   constructor(private service: HeroService) {}\n *\n *   resolve(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<any>|Promise<any>|any {\n *     return this.service.getHero(route.paramMap.get('id'));\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroDetailComponent,\n *         resolve: {\n *           hero: HeroResolver\n *         }\n *       }\n *     ])\n *   ],\n *   exports: [RouterModule]\n * })\n * export class AppRoutingModule {}\n * ```\n *\n * You can alternatively provide a function with the `resolve` signature:\n *\n * ```\n * export const myHero: Hero = {\n *   // ...\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'detail/:id',\n *         component: HeroComponent,\n *         resolve: {\n *           hero: 'heroResolver'\n *         }\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'heroResolver',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => myHero\n *     }\n *   ]\n * })\n * export class AppModule {}\n * ```\n *\n * @publicApi\n */\nexport declare interface Resolve<T> {\n    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T> | Promise<T> | T;\n}\n\n/**\n *\n * Represents the resolved data associated with a particular route.\n *\n * @see `Route#resolve`.\n *\n * @publicApi\n */\nexport declare type ResolveData = {\n    [name: string]: any;\n};\n\n/**\n * An event triggered at the end of the Resolve phase of routing.\n * @see `ResolveStart`.\n *\n * @publicApi\n */\nexport declare class ResolveEnd extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * An event triggered at the the start of the Resolve phase of routing.\n *\n * Runs in the \"resolve\" phase whether or not there is anything to resolve.\n * In future, may change to only run when there are things to be resolved.\n *\n * @publicApi\n */\nexport declare class ResolveStart extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    toString(): string;\n}\n\n/**\n * A configuration object that defines a single route.\n * A set of routes are collected in a `Routes` array to define a `Router` configuration.\n * The router attempts to match segments of a given URL against each route,\n * using the configuration options defined in this object.\n *\n * Supports static, parameterized, redirect, and wildcard routes, as well as\n * custom route data and resolve methods.\n *\n * For detailed usage information, see the [Routing Guide](guide/router).\n *\n * @usageNotes\n *\n * ### Simple Configuration\n *\n * The following route specifies that when navigating to, for example,\n * `/team/11/user/bob`, the router creates the 'Team' component\n * with the 'User' child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n  *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * ### Multiple Outlets\n *\n * The following route creates sibling components with multiple outlets.\n * When navigating to `/team/11(aux:chat/jim)`, the router creates the 'Team' component next to\n * the 'Chat' component. The 'Chat' component is placed into the 'aux' outlet.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * ### Wild Cards\n *\n * The following route uses wild-card notation to specify a component\n * that is always instantiated regardless of where you navigate to.\n *\n * ```\n * [{\n *   path: '**',\n *   component: WildcardComponent\n * }]\n * ```\n *\n * ### Redirects\n *\n * The following route uses the `redirectTo` property to ignore a segment of\n * a given URL when looking for a child path.\n *\n * When navigating to '/team/11/legacy/user/jim', the router changes the URL segment\n * '/team/11/legacy/user/jim' to '/team/11/user/jim', and then instantiates\n * the Team component with the User child component in it.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * The redirect path can be relative, as shown in this example, or absolute.\n * If we change the `redirectTo` value in the example to the absolute URL segment '/user/:name',\n * the result URL is also absolute, '/user/jim'.\n\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any URL segments.\n *\n * In the following configuration, when navigating to\n * `/team/11`, the router instantiates the 'AllUsers' component.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * Empty-path routes can have children. In the following example, when navigating\n * to `/team/11/user/jim`, the router instantiates the wrapper component with\n * the user component in it.\n *\n * Note that an empty path route inherits its parent's parameters and data.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * ### Matching Strategy\n *\n * The default path-match strategy is 'prefix', which means that the router\n * checks URL elements from the left to see if the URL matches a specified path.\n * For example, '/team/11/user' matches 'team/:id'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * You can specify the path-match strategy 'full' to make sure that the path\n * covers the whole unconsumed URL. It is important to do this when redirecting\n * empty-path routes. Otherwise, because an empty path is a prefix of any URL,\n * the router would apply the redirect even when navigating to the redirect destination,\n * creating an endless loop.\n *\n * In the following example, supplying the 'full' `pathMatch` strategy ensures\n * that the router applies the redirect if and only if navigating to '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * You can share parameters between sibling components.\n * For example, suppose that two sibling components should go next to each other,\n * and both of them require an ID parameter. You can accomplish this using a route\n * that does not specify a component at the top level.\n *\n * In the following example, 'MainChild' and 'AuxChild' are siblings.\n * When navigating to 'parent/10/(a//aux:b)', the route instantiates\n * the main child and aux child components next to each other.\n * For this to work, the application component must have the primary and aux outlets defined.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * The router merges the parameters, data, and resolve of the componentless\n * parent into the parameters, data, and resolve of the children.\n *\n * This is especially useful when child components are defined\n * with an empty path string, as in the following example.\n * With this configuration, navigating to '/parent/10' creates\n * the main child and aux components.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up application load time by splitting the application\n * into multiple bundles and loading them on demand.\n * To use lazy loading, provide the `loadChildren` property  instead of the `children` property.\n *\n * Given the following example route, the router will lazy load\n * the associated module on demand using the browser native import system.\n *\n * ```\n * [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy-route/lazy.module').then(mod => mod.LazyModule),\n * }];\n * ```\n *\n * @publicApi\n */\nexport declare interface Route {\n    /**\n     * The path to match against. Cannot be used together with a custom `matcher` function.\n     * A URL string that uses router matching notation.\n     * Can be a wild card (`**`) that matches any URL (see Usage Notes below).\n     * Default is \"/\" (the root path).\n     *\n     */\n    path?: string;\n    /**\n     * The path-matching strategy, one of 'prefix' or 'full'.\n     * Default is 'prefix'.\n     *\n     * By default, the router checks URL elements from the left to see if the URL\n     * matches a given  path, and stops when there is a match. For example,\n     * '/team/11/user' matches 'team/:id'.\n     *\n     * The path-match strategy 'full' matches against the entire URL.\n     * It is important to do this when redirecting empty-path routes.\n     * Otherwise, because an empty path is a prefix of any URL,\n     * the router would apply the redirect even when navigating\n     * to the redirect destination, creating an endless loop.\n     *\n     */\n    pathMatch?: string;\n    /**\n     * A custom URL-matching function. Cannot be used together with `path`.\n     */\n    matcher?: UrlMatcher;\n    /**\n     * The component to instantiate when the path matches.\n     * Can be empty if child routes specify components.\n     */\n    component?: Type<any>;\n    /**\n     * A URL to which to redirect when a the path matches.\n     * Absolute if the URL begins with a slash (/), otherwise relative to the path URL.\n     * When not present, router does not redirect.\n     */\n    redirectTo?: string;\n    /**\n     * Name of a `RouterOutlet` object where the component can be placed\n     * when the path matches.\n     */\n    outlet?: string;\n    /**\n     * An array of dependency-injection tokens used to look up `CanActivate()`\n     * handlers, in order to determine if the current user is allowed to\n     * activate the component. By default, any user can activate.\n     */\n    canActivate?: any[];\n    /**\n     * An array of DI tokens used to look up `CanActivateChild()` handlers,\n     * in order to determine if the current user is allowed to activate\n     * a child of the component. By default, any user can activate a child.\n     */\n    canActivateChild?: any[];\n    /**\n     * An array of DI tokens used to look up `CanDeactivate()`\n     * handlers, in order to determine if the current user is allowed to\n     * deactivate the component. By default, any user can deactivate.\n     *\n     */\n    canDeactivate?: any[];\n    /**\n     * An array of DI tokens used to look up `CanLoad()`\n     * handlers, in order to determine if the current user is allowed to\n     * load the component. By default, any user can load.\n     */\n    canLoad?: any[];\n    /**\n     * Additional developer-defined data provided to the component via\n     * `ActivatedRoute`. By default, no additional data is passed.\n     */\n    data?: Data;\n    /**\n     * A map of DI tokens used to look up data resolvers. See `Resolve`.\n     */\n    resolve?: ResolveData;\n    /**\n     * An array of child `Route` objects that specifies a nested route\n     * configuration.\n     */\n    children?: Routes;\n    /**\n     * A `LoadChildren` object specifying lazy-loaded child routes.\n     */\n    loadChildren?: LoadChildren;\n    /**\n     * Defines when guards and resolvers will be run. One of\n     * - `paramsOrQueryParamsChange` : Run when query parameters change.\n     * - `always` : Run on every execution.\n     * By default, guards and resolvers run only when the matrix\n     * parameters of the route change.\n     */\n    runGuardsAndResolvers?: RunGuardsAndResolvers;\n}\n\n/**\n * An event triggered when a route has been lazy loaded.\n *\n * @publicApi\n */\nexport declare class RouteConfigLoadEnd {\n    /** @docsNotRequired */\n    route: Route;\n    constructor(\n    /** @docsNotRequired */\n    route: Route);\n    toString(): string;\n}\n\n/**\n * An event triggered before lazy loading a route configuration.\n *\n * @publicApi\n */\nexport declare class RouteConfigLoadStart {\n    /** @docsNotRequired */\n    route: Route;\n    constructor(\n    /** @docsNotRequired */\n    route: Route);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * A service that provides navigation and URL manipulation capabilities.\n *\n * @see `Route`.\n * @see [Routing and Navigation Guide](guide/router).\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class Router {\n    private rootComponentType;\n    private urlSerializer;\n    private rootContexts;\n    private location;\n    config: Routes;\n    private currentUrlTree;\n    private rawUrlTree;\n    private browserUrlTree;\n    private readonly transitions;\n    private navigations;\n    private lastSuccessfulNavigation;\n    private currentNavigation;\n    private locationSubscription;\n    private navigationId;\n    private configLoader;\n    private ngModule;\n    private console;\n    private isNgZoneEnabled;\n    /**\n     * An event stream for routing events in this NgModule.\n     */\n    readonly events: Observable<Event>;\n    /**\n     * The current state of routing in this NgModule.\n     */\n    readonly routerState: RouterState;\n    /**\n     * A handler for navigation errors in this NgModule.\n     */\n    errorHandler: ErrorHandler;\n    /**\n     * A handler for errors thrown by `Router.parseUrl(url)`\n     * when `url` contains an invalid character.\n     * The most common case is a `%` sign\n     * that's not encoded and is not part of a percent encoded sequence.\n     */\n    malformedUriErrorHandler: (error: URIError, urlSerializer: UrlSerializer, url: string) => UrlTree;\n    /**\n     * True if at least one navigation event has occurred,\n     * false otherwise.\n     */\n    navigated: boolean;\n    private lastSuccessfulId;\n    /**\n     * A strategy for extracting and merging URLs.\n     * Used for AngularJS to Angular migrations.\n     */\n    urlHandlingStrategy: UrlHandlingStrategy;\n    /**\n     * A strategy for re-using routes.\n     */\n    routeReuseStrategy: RouteReuseStrategy;\n    /**\n     * How to handle a navigation request to the current URL. One of:\n     * - `'ignore'` :  The router ignores the request.\n     * - `'reload'` : The router reloads the URL. Use to implement a \"refresh\" feature.\n     */\n    onSameUrlNavigation: 'reload' | 'ignore';\n    /**\n     * How to merge parameters, data, and resolved data from parent to child\n     * routes. One of:\n     *\n     * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data\n     * for path-less or component-less routes.\n     * - `'always'` : Inherit parent parameters, data, and resolved data\n     * for all child routes.\n     */\n    paramsInheritanceStrategy: 'emptyOnly' | 'always';\n    /**\n     * Determines when the router updates the browser URL.\n     * By default (`\"deferred\"`), updates the browser URL after navigation has finished.\n     * Set to `'eager'` to update the browser URL at the beginning of navigation.\n     * You can choose to update early so that, if navigation fails,\n     * you can show an error message with the URL that failed.\n     */\n    urlUpdateStrategy: 'deferred' | 'eager';\n    /**\n     * Enables a bug fix that corrects relative link resolution in components with empty paths.\n     * @see `RouterModule`\n     */\n    relativeLinkResolution: 'legacy' | 'corrected';\n    /**\n     * Creates the router service.\n     */\n    constructor(rootComponentType: Type<any> | null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes);\n    private setupNavigations;\n    private getTransition;\n    private setTransition;\n    /**\n     * Sets up the location change listener and performs the initial navigation.\n     */\n    initialNavigation(): void;\n    /**\n     * Sets up the location change listener.\n     */\n    setUpLocationChangeListener(): void;\n    /** The current URL. */\n    readonly url: string;\n    /** The current Navigation object if one exists */\n    getCurrentNavigation(): Navigation | null;\n    /**\n     * Resets the configuration used for navigation and generating links.\n     *\n     * @param config The route array for the new configuration.\n     *\n     * @usageNotes\n     *\n     * ```\n     * router.resetConfig([\n     *  { path: 'team/:id', component: TeamCmp, children: [\n     *    { path: 'simple', component: SimpleCmp },\n     *    { path: 'user/:name', component: UserCmp }\n     *  ]}\n     * ]);\n     * ```\n     */\n    resetConfig(config: Routes): void;\n    /** @docsNotRequired */\n    ngOnDestroy(): void;\n    /** Disposes of the router. */\n    dispose(): void;\n    /**\n     * Applies an array of commands to the current URL tree and creates a new URL tree.\n     *\n     * When given an activated route, applies the given commands starting from the route.\n     * Otherwise, applies the given command starting from the root.\n     *\n     * @param commands An array of commands to apply.\n     * @param navigationExtras Options that control the navigation strategy.\n     * @returns The new URL tree.\n     *\n     * @usageNotes\n     *\n     * ```\n     * // create /team/33/user/11\n     * router.createUrlTree(['/team', 33, 'user', 11]);\n     *\n     * // create /team/33;expand=true/user/11\n     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n     *\n     * // you can collapse static segments like this (this works only with the first passed-in value):\n     * router.createUrlTree(['/team/33/user', userId]);\n     *\n     * // If the first segment can contain slashes, and you do not want the router to split it,\n     * // you can do the following:\n     * router.createUrlTree([{segmentPath: '/one/two'}]);\n     *\n     * // create /team/33/(user/11//right:chat)\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n     *\n     * // remove the right secondary node\n     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n     *\n     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n     *\n     * // navigate to /team/33/user/11/details\n     * router.createUrlTree(['details'], {relativeTo: route});\n     *\n     * // navigate to /team/33/user/22\n     * router.createUrlTree(['../22'], {relativeTo: route});\n     *\n     * // navigate to /team/44/user/22\n     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n     * ```\n     */\n    createUrlTree(commands: any[], navigationExtras?: NavigationExtras): UrlTree;\n    /**\n     * Navigate based on the provided URL, which must be absolute.\n     *\n     * @param url An absolute URL. The function does not apply any delta to the current URL.\n     * @param extras An object containing properties that modify the navigation strategy.\n     * The function ignores any properties in the `NavigationExtras` that would change the\n     * provided URL.\n     *\n     * @returns A Promise that resolves to 'true' when navigation succeeds,\n     * to 'false' when navigation fails, or is rejected on error.\n     *\n     * @usageNotes\n     *\n     * ```\n     * router.navigateByUrl(\"/team/33/user/11\");\n     *\n     * // Navigate without updating the URL\n     * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n     * ```\n     *\n     */\n    navigateByUrl(url: string | UrlTree, extras?: NavigationExtras): Promise<boolean>;\n    /**\n     * Navigate based on the provided array of commands and a starting point.\n     * If no starting route is provided, the navigation is absolute.\n     *\n     * Returns a promise that:\n     * - resolves to 'true' when navigation succeeds,\n     * - resolves to 'false' when navigation fails,\n     * - is rejected when an error happens.\n     *\n     * @usageNotes\n     *\n     * ```\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n     *\n     * // Navigate without updating the URL\n     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n     * ```\n     *\n     * The first parameter of `navigate()` is a delta to be applied to the current URL\n     * or the one provided in the `relativeTo` property of the second parameter (the\n     * `NavigationExtras`).\n     *\n     * In order to affect this browser's `history.state` entry, the `state`\n     * parameter can be passed. This must be an object because the router\n     * will add the `navigationId` property to this object before creating\n     * the new history item.\n     */\n    navigate(commands: any[], extras?: NavigationExtras): Promise<boolean>;\n    /** Serializes a `UrlTree` into a string */\n    serializeUrl(url: UrlTree): string;\n    /** Parses a string into a `UrlTree` */\n    parseUrl(url: string): UrlTree;\n    /** Returns whether the url is activated */\n    isActive(url: string | UrlTree, exact: boolean): boolean;\n    private removeEmptyProps;\n    private processNavigations;\n    private scheduleNavigation;\n    private setBrowserUrl;\n    private resetStateAndUrl;\n    private resetUrlToCurrentUrlTree;\n}\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router service.\n *\n * @publicApi\n */\nexport declare const ROUTER_CONFIGURATION: InjectionToken<ExtraOptions>;\n\n/**\n * A [DI token](guide/glossary/#di-token) for the router initializer that\n * is called after the app is bootstrapped.\n *\n * @publicApi\n */\nexport declare const ROUTER_INITIALIZER: InjectionToken<(compRef: ComponentRef<any>) => void>;\n\n/**\n * @description\n *\n * Provides a way to customize when activated routes get reused.\n *\n * @publicApi\n */\nexport declare abstract class RouteReuseStrategy {\n    /** Determines if this route (and its subtree) should be detached to be reused later */\n    abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n    /**\n     * Stores the detached route.\n     *\n     * Storing a `null` value should erase the previously stored value.\n     */\n    abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle | null): void;\n    /** Determines if this route (and its subtree) should be reattached */\n    abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n    /** Retrieves the previously stored route */\n    abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null;\n    /** Determines if a route should be reused */\n    abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\n/**\n * Base for events the router goes through, as opposed to events tied to a specific\n * route. Fired one time for any given navigation.\n *\n * @usageNotes\n *\n * ```ts\n * class MyService {\n *   constructor(public router: Router, logger: Logger) {\n *     router.events.pipe(\n *       filter(e => e instanceof RouterEvent)\n *     ).subscribe(e => {\n *       logger.log(e.id, e.url);\n *     });\n *   }\n * }\n * ```\n *\n * @see `Event`\n * @publicApi\n */\nexport declare class RouterEvent {\n    /** A unique ID that the router assigns to every router navigation. */\n    id: number;\n    /** The URL that is the destination for this navigation. */\n    url: string;\n    constructor(\n    /** A unique ID that the router assigns to every router navigation. */\n    id: number, \n    /** The URL that is the destination for this navigation. */\n    url: string);\n}\n\n/**\n * @description\n *\n * Lets you link to specific routes in your app.\n *\n * Consider the following route configuration:\n * `[{ path: 'user/:name', component: UserCmp }]`.\n * When linking to this `user/:name` route, you use the `RouterLink` directive.\n *\n * If the link is static, you can use the directive as follows:\n * `<a routerLink=\"/user/bob\">link to user component</a>`\n *\n * If you use dynamic values to generate the link, you can pass an array of path\n * segments, followed by the params for each segment.\n *\n * For instance `['/team', teamId, 'user', userName, {details: true}]`\n * means that we want to generate a link to `/team/11/user/bob;details=true`.\n *\n * Multiple static segments can be merged into one\n * (e.g., `['/team/11/user', userName, {details: true}]`).\n *\n * The first segment name can be prepended with `/`, `./`, or `../`:\n * * If the first segment begins with `/`, the router will look up the route from the root of the\n *   app.\n * * If the first segment begins with `./`, or doesn't begin with a slash, the router will\n *   instead look in the children of the current activated route.\n * * And if the first segment begins with `../`, the router will go up one level.\n *\n * You can set query params and fragment as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" fragment=\"education\">\n *   link to user component\n * </a>\n * ```\n * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.\n *\n * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the\n * directive to preserve the current query params and fragment:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" preserveQueryParams preserveFragment>\n *   link to user component\n * </a>\n * ```\n *\n * You can tell the directive how to handle queryParams. Available options are:\n *  - `'merge'`: merge the queryParams into the current queryParams\n *  - `'preserve'`: preserve the current queryParams\n *  - default/`''`: use the queryParams only\n *\n * Same options for {@link NavigationExtras#queryParamsHandling\n * NavigationExtras#queryParamsHandling}.\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [queryParams]=\"{debug: true}\" queryParamsHandling=\"merge\">\n *   link to user component\n * </a>\n * ```\n *\n * You can provide a `state` value to be persisted to the browser's History.state\n * property (See https://developer.mozilla.org/en-US/docs/Web/API/History#Properties). It's\n * used as follows:\n *\n * ```\n * <a [routerLink]=\"['/user/bob']\" [state]=\"{tracingId: 123}\">\n *   link to user component\n * </a>\n * ```\n *\n * And later the value can be read from the router through `router.getCurrentNavigation`.\n * For example, to capture the `tracingId` above during the `NavigationStart` event:\n *\n * ```\n * // Get NavigationStart events\n * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {\n *   const navigation = router.getCurrentNavigation();\n *   tracingService.trace({id: navigation.extras.state.tracingId});\n * });\n * ```\n *\n * The router link directive always treats the provided input as a delta to the current url.\n *\n * For instance, if the current url is `/user/(box//aux:team)`.\n *\n * Then the following link `<a [routerLink]=\"['/user/jim']\">Jim</a>` will generate the link\n * `/user/(jim//aux:team)`.\n *\n * See {@link Router#createUrlTree createUrlTree} for more information.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLink {\n    private router;\n    private route;\n    queryParams: {\n        [k: string]: any;\n    };\n    fragment: string;\n    queryParamsHandling: QueryParamsHandling;\n    preserveFragment: boolean;\n    skipLocationChange: boolean;\n    replaceUrl: boolean;\n    state?: {\n        [k: string]: any;\n    };\n    private commands;\n    private preserve;\n    constructor(router: Router, route: ActivatedRoute, tabIndex: string, renderer: Renderer2, el: ElementRef);\n    routerLink: any[] | string;\n    /**\n     * @deprecated 4.0.0 use `queryParamsHandling` instead.\n     */\n    preserveQueryParams: boolean;\n    onClick(): boolean;\n    readonly urlTree: UrlTree;\n}\n\n/**\n *\n * @description\n *\n * Lets you add a CSS class to an element when the link's route becomes active.\n *\n * This directive lets you add a CSS class to an element when the link's route\n * becomes active.\n *\n * Consider the following example:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\">Bob</a>\n * ```\n *\n * When the url is either '/user' or '/user/bob', the active-link class will\n * be added to the `a` tag. If the url changes, the class will be removed.\n *\n * You can set more than one class, as follows:\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"class1 class2\">Bob</a>\n * <a routerLink=\"/user/bob\" [routerLinkActive]=\"['class1', 'class2']\">Bob</a>\n * ```\n *\n * You can configure RouterLinkActive by passing `exact: true`. This will add the classes\n * only when the url matches the link exactly.\n *\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact:\n * true}\">Bob</a>\n * ```\n *\n * You can assign the RouterLinkActive instance to a template variable and directly check\n * the `isActive` status.\n * ```\n * <a routerLink=\"/user/bob\" routerLinkActive #rla=\"routerLinkActive\">\n *   Bob {{ rla.isActive ? '(already open)' : ''}}\n * </a>\n * ```\n *\n * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.\n *\n * ```\n * <div routerLinkActive=\"active-link\" [routerLinkActiveOptions]=\"{exact: true}\">\n *   <a routerLink=\"/user/jim\">Jim</a>\n *   <a routerLink=\"/user/bob\">Bob</a>\n * </div>\n * ```\n *\n * This will set the active-link class on the div tag if the url is either '/user/jim' or\n * '/user/bob'.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLinkActive implements OnChanges, OnDestroy, AfterContentInit {\n    private router;\n    private element;\n    private renderer;\n    private link?;\n    private linkWithHref?;\n    links: QueryList<RouterLink>;\n    linksWithHrefs: QueryList<RouterLinkWithHref>;\n    private classes;\n    private subscription;\n    readonly isActive: boolean;\n    routerLinkActiveOptions: {\n        exact: boolean;\n    };\n    constructor(router: Router, element: ElementRef, renderer: Renderer2, link?: RouterLink | undefined, linkWithHref?: RouterLinkWithHref | undefined);\n    ngAfterContentInit(): void;\n    routerLinkActive: string[] | string;\n    ngOnChanges(changes: SimpleChanges): void;\n    ngOnDestroy(): void;\n    private update;\n    private isLinkActive;\n    private hasActiveLinks;\n}\n\n/**\n * @description\n *\n * Lets you link to specific routes in your app.\n *\n * See `RouterLink` for more information.\n *\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterLinkWithHref implements OnChanges, OnDestroy {\n    private router;\n    private route;\n    private locationStrategy;\n    target: string;\n    queryParams: {\n        [k: string]: any;\n    };\n    fragment: string;\n    queryParamsHandling: QueryParamsHandling;\n    preserveFragment: boolean;\n    skipLocationChange: boolean;\n    replaceUrl: boolean;\n    state?: {\n        [k: string]: any;\n    };\n    private commands;\n    private subscription;\n    private preserve;\n    href: string;\n    constructor(router: Router, route: ActivatedRoute, locationStrategy: LocationStrategy);\n    routerLink: any[] | string;\n    preserveQueryParams: boolean;\n    ngOnChanges(changes: {}): any;\n    ngOnDestroy(): any;\n    onClick(button: number, ctrlKey: boolean, metaKey: boolean, shiftKey: boolean): boolean;\n    private updateTargetUrlAndHref;\n    readonly urlTree: UrlTree;\n}\n\n/**\n * @usageNotes\n *\n * RouterModule can be imported multiple times: once per lazily-loaded bundle.\n * Since the router deals with a global shared resource--location, we cannot have\n * more than one router service active.\n *\n * That is why there are two ways to create the module: `RouterModule.forRoot` and\n * `RouterModule.forChild`.\n *\n * * `forRoot` creates a module that contains all the directives, the given routes, and the router\n *   service itself.\n * * `forChild` creates a module that contains all the directives and the given routes, but does not\n *   include the router service.\n *\n * When registered at the root, the module should be used as follows\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forRoot(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * For submodules and lazy loaded submodules the module should be used as follows:\n *\n * ```\n * @NgModule({\n *   imports: [RouterModule.forChild(ROUTES)]\n * })\n * class MyNgModule {}\n * ```\n *\n * @description\n *\n * Adds router directives and providers.\n *\n * Managing state transitions is one of the hardest parts of building applications. This is\n * especially true on the web, where you also need to ensure that the state is reflected in the URL.\n * In addition, we often want to split applications into multiple bundles and load them on demand.\n * Doing this transparently is not trivial.\n *\n * The Angular router service solves these problems. Using the router, you can declaratively specify\n * application states, manage state transitions while taking care of the URL, and load bundles on\n * demand.\n *\n * @see [Routing and Navigation](guide/router.html) for an\n * overview of how the router service should be used.\n *\n * @publicApi\n */\nexport declare class RouterModule {\n    constructor(guard: any, router: Router);\n    /**\n     * Creates and configures a module with all the router providers and directives.\n     * Optionally sets up an application listener to perform an initial navigation.\n     *\n     * @param routes An array of `Route` objects that define the navigation paths for the application.\n     * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n     * @return The new router module.\n    */\n    static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders<RouterModule>;\n    /**\n     * Creates a module with all the router directives and a provider registering routes.\n     */\n    static forChild(routes: Routes): ModuleWithProviders<RouterModule>;\n}\n\n/**\n * @description\n *\n * Acts as a placeholder that Angular dynamically fills based on the current router state.\n *\n * Each outlet can have a unique name, determined by the optional `name` attribute.\n * The name cannot be set or changed dynamically. If not set, default value is \"primary\".\n *\n * ```\n * <router-outlet></router-outlet>\n * <router-outlet name='left'></router-outlet>\n * <router-outlet name='right'></router-outlet>\n * ```\n *\n * A router outlet emits an activate event when a new component is instantiated,\n * and a deactivate event when a component is destroyed.\n *\n * ```\n * <router-outlet\n *   (activate)='onActivate($event)'\n *   (deactivate)='onDeactivate($event)'></router-outlet>\n * ```\n * @ngModule RouterModule\n *\n * @publicApi\n */\nexport declare class RouterOutlet implements OnDestroy, OnInit {\n    private parentContexts;\n    private location;\n    private resolver;\n    private changeDetector;\n    private activated;\n    private _activatedRoute;\n    private name;\n    activateEvents: EventEmitter<any>;\n    deactivateEvents: EventEmitter<any>;\n    constructor(parentContexts: ChildrenOutletContexts, location: ViewContainerRef, resolver: ComponentFactoryResolver, name: string, changeDetector: ChangeDetectorRef);\n    ngOnDestroy(): void;\n    ngOnInit(): void;\n    readonly isActivated: boolean;\n    readonly component: Object;\n    readonly activatedRoute: ActivatedRoute;\n    readonly activatedRouteData: Data;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach(): ComponentRef<any>;\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    attach(ref: ComponentRef<any>, activatedRoute: ActivatedRoute): void;\n    deactivate(): void;\n    activateWith(activatedRoute: ActivatedRoute, resolver: ComponentFactoryResolver | null): void;\n}\n\n/**\n * The preloader optimistically loads all router configurations to\n * make navigations into lazily-loaded sections of the application faster.\n *\n * The preloader runs in the background. When the router bootstraps, the preloader\n * starts listening to all navigation events. After every such event, the preloader\n * will check if any configurations can be loaded lazily.\n *\n * If a route is protected by `canLoad` guards, the preloaded will not load it.\n *\n * @publicApi\n */\nexport declare class RouterPreloader implements OnDestroy {\n    private router;\n    private injector;\n    private preloadingStrategy;\n    private loader;\n    private subscription;\n    constructor(router: Router, moduleLoader: NgModuleFactoryLoader, compiler: Compiler, injector: Injector, preloadingStrategy: PreloadingStrategy);\n    setUpPreloading(): void;\n    preload(): Observable<any>;\n    ngOnDestroy(): void;\n    private processRoutes;\n    private preloadConfig;\n}\n\n/**\n * Represents the state of the router as a tree of activated routes.\n *\n * @usageNotes\n *\n * Every node in the route tree is an `ActivatedRoute` instance\n * that knows about the \"consumed\" URL segments, the extracted parameters,\n * and the resolved data.\n * Use the `ActivatedRoute` properties to traverse the tree from any node.\n *\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const root: ActivatedRoute = state.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @see `ActivatedRoute`\n *\n * @publicApi\n */\nexport declare class RouterState extends ɵangular_packages_router_router_m<ActivatedRoute> {\n    /** The current snapshot of the router state */\n    snapshot: RouterStateSnapshot;\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Represents the state of the router at a moment in time.\n *\n * This is a tree of activated route snapshots. Every node in this tree knows about\n * the \"consumed\" URL segments, the extracted parameters, and the resolved data.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const state: RouterState = router.routerState;\n *     const snapshot: RouterStateSnapshot = state.snapshot;\n *     const root: ActivatedRouteSnapshot = snapshot.root;\n *     const child = root.firstChild;\n *     const id: Observable<string> = child.params.map(p => p.id);\n *     //...\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class RouterStateSnapshot extends ɵangular_packages_router_router_m<ActivatedRouteSnapshot> {\n    /** The url from which this snapshot was created */\n    url: string;\n    toString(): string;\n}\n\n/**\n * The [DI token](guide/glossary/#di-token) for a router configuration.\n * @see `ROUTES`\n * @publicApi\n */\nexport declare const ROUTES: InjectionToken<Route[][]>;\n\n/**\n * Represents a route configuration for the Router service.\n * An array of `Route` objects, used in `Router.config` and for nested route configurations\n * in `Route.children`.\n *\n * @see `Route`\n * @see `Router`\n * @publicApi\n */\nexport declare type Routes = Route[];\n\n/**\n *An event triggered when routes are recognized.\n *\n * @publicApi\n */\nexport declare class RoutesRecognized extends RouterEvent {\n    /** @docsNotRequired */\n    urlAfterRedirects: string;\n    /** @docsNotRequired */\n    state: RouterStateSnapshot;\n    constructor(\n    /** @docsNotRequired */\n    id: number, \n    /** @docsNotRequired */\n    url: string, \n    /** @docsNotRequired */\n    urlAfterRedirects: string, \n    /** @docsNotRequired */\n    state: RouterStateSnapshot);\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n *\n * A policy for when to run guards and resolvers on a route.\n *\n * @see `Route#runGuardsAndResolvers`\n * @publicApi\n */\nexport declare type RunGuardsAndResolvers = 'pathParamsChange' | 'pathParamsOrQueryParamsChange' | 'paramsChange' | 'paramsOrQueryParamsChange' | 'always' | ((from: ActivatedRouteSnapshot, to: ActivatedRouteSnapshot) => boolean);\n\n/**\n * An event triggered by scrolling.\n *\n * @publicApi\n */\nexport declare class Scroll {\n    /** @docsNotRequired */\n    readonly routerEvent: NavigationEnd;\n    /** @docsNotRequired */\n    readonly position: [number, number] | null;\n    /** @docsNotRequired */\n    readonly anchor: string | null;\n    constructor(\n    /** @docsNotRequired */\n    routerEvent: NavigationEnd, \n    /** @docsNotRequired */\n    position: [number, number] | null, \n    /** @docsNotRequired */\n    anchor: string | null);\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Provides a way to migrate AngularJS applications to Angular.\n *\n * @publicApi\n */\nexport declare abstract class UrlHandlingStrategy {\n    /**\n     * Tells the router if this URL should be processed.\n     *\n     * When it returns true, the router will execute the regular navigation.\n     * When it returns false, the router will set the router state to an empty state.\n     * As a result, all the active components will be destroyed.\n     *\n     */\n    abstract shouldProcessUrl(url: UrlTree): boolean;\n    /**\n     * Extracts the part of the URL that should be handled by the router.\n     * The rest of the URL will remain untouched.\n     */\n    abstract extract(url: UrlTree): UrlTree;\n    /**\n     * Merges the URL fragment with the rest of the URL.\n     */\n    abstract merge(newUrlPart: UrlTree, rawUrl: UrlTree): UrlTree;\n}\n\n/**\n * A function for matching a route against URLs. Implement a custom URL matcher\n * for `Route.matcher` when a combination of `path` and `pathMatch`\n * is not expressive enough. Cannot be used together with `path` and `pathMatch`.\n *\n * @param segments An array of URL segments.\n * @param group A segment group.\n * @param route The route to match against.\n * @returns The match-result.\n *\n * @usageNotes\n *\n * The following matcher matches HTML files.\n *\n * ```\n * export function htmlFiles(url: UrlSegment[]) {\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\n * ```\n *\n * @publicApi\n */\nexport declare type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) => UrlMatchResult;\n\n/**\n * Represents the result of matching URLs with a custom matching function.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @see `UrlMatcher()`\n * @publicApi\n */\nexport declare type UrlMatchResult = {\n    consumed: UrlSegment[];\n    posParams?: {\n        [name: string]: UrlSegment;\n    };\n};\n\n/**\n * @description\n *\n * Represents a single URL segment.\n *\n * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix\n * parameters associated with the segment.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree = router.parseUrl('/team;id=33');\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments;\n *     s[0].path; // returns 'team'\n *     s[0].parameters; // returns {id: 33}\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class UrlSegment {\n    /** The path part of a URL segment */\n    path: string;\n    /** The matrix parameters associated with a segment */\n    parameters: {\n        [name: string]: string;\n    };\n    constructor(\n    /** The path part of a URL segment */\n    path: string, \n    /** The matrix parameters associated with a segment */\n    parameters: {\n        [name: string]: string;\n    });\n    readonly parameterMap: ParamMap;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Represents the parsed URL segment group.\n *\n * See `UrlTree` for more information.\n *\n * @publicApi\n */\nexport declare class UrlSegmentGroup {\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments: UrlSegment[];\n    /** The list of children of this group */\n    children: {\n        [key: string]: UrlSegmentGroup;\n    };\n    /** The parent node in the url tree */\n    parent: UrlSegmentGroup | null;\n    constructor(\n    /** The URL segments of this group. See `UrlSegment` for more information */\n    segments: UrlSegment[], \n    /** The list of children of this group */\n    children: {\n        [key: string]: UrlSegmentGroup;\n    });\n    /** Whether the segment has child segments */\n    hasChildren(): boolean;\n    /** Number of child segments */\n    readonly numberOfChildren: number;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @description\n *\n * Serializes and deserializes a URL string into a URL tree.\n *\n * The url serialization strategy is customizable. You can\n * make all URLs case insensitive by providing a custom UrlSerializer.\n *\n * See `DefaultUrlSerializer` for an example of a URL serializer.\n *\n * @publicApi\n */\nexport declare abstract class UrlSerializer {\n    /** Parse a url into a `UrlTree` */\n    abstract parse(url: string): UrlTree;\n    /** Converts a `UrlTree` into a url */\n    abstract serialize(tree: UrlTree): string;\n}\n\n/**\n * @description\n *\n * Represents the parsed URL.\n *\n * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a\n * serialized tree.\n * UrlTree is a data structure that provides a lot of affordances in dealing with URLs\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * @Component({templateUrl:'template.html'})\n * class MyComponent {\n *   constructor(router: Router) {\n *     const tree: UrlTree =\n *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');\n *     const f = tree.fragment; // return 'fragment'\n *     const q = tree.queryParams; // returns {debug: 'true'}\n *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];\n *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'\n *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'\n *     g.children['support'].segments; // return 1 segment 'help'\n *   }\n * }\n * ```\n *\n * @publicApi\n */\nexport declare class UrlTree {\n    /** The root segment group of the URL tree */\n    root: UrlSegmentGroup;\n    /** The query params of the URL */\n    queryParams: Params;\n    /** The fragment of the URL */\n    fragment: string | null;\n    readonly queryParamMap: ParamMap;\n    /** @docsNotRequired */\n    toString(): string;\n}\n\n/**\n * @publicApi\n */\nexport declare const VERSION: Version;\n\n/**\n * @docsNotRequired\n */\nexport declare const ɵangular_packages_router_router_a: InjectionToken<void>;\n\nexport declare function ɵangular_packages_router_router_b(): NgProbeToken;\n\nexport declare function ɵangular_packages_router_router_c(router: Router, viewportScroller: ViewportScroller, config: ExtraOptions): ɵangular_packages_router_router_o;\n\nexport declare function ɵangular_packages_router_router_d(platformLocationStrategy: PlatformLocation, baseHref: string, options?: ExtraOptions): HashLocationStrategy | PathLocationStrategy;\n\nexport declare function ɵangular_packages_router_router_e(router: Router): any;\n\nexport declare function ɵangular_packages_router_router_f(ref: ApplicationRef, urlSerializer: UrlSerializer, contexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Route[][], opts?: ExtraOptions, urlHandlingStrategy?: UrlHandlingStrategy, routeReuseStrategy?: RouteReuseStrategy): Router;\n\nexport declare function ɵangular_packages_router_router_g(router: Router): ActivatedRoute;\n\n/**\n * Router initialization requires two steps:\n *\n * First, we start the navigation in a `APP_INITIALIZER` to block the bootstrap if\n * a resolver or a guard executes asynchronously.\n *\n * Next, we actually run activation in a `BOOTSTRAP_LISTENER`, using the\n * `afterPreactivation` hook provided by the router.\n * The router navigation starts, reaches the point when preactivation is done, and then\n * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.\n */\nexport declare class ɵangular_packages_router_router_h {\n    private injector;\n    private initNavigation;\n    private resultOfPreactivationDone;\n    constructor(injector: Injector);\n    appInitializer(): Promise<any>;\n    bootstrapListener(bootstrappedComponentRef: ComponentRef<any>): void;\n    private isLegacyEnabled;\n    private isLegacyDisabled;\n}\n\nexport declare function ɵangular_packages_router_router_i(r: ɵangular_packages_router_router_h): () => Promise<any>;\n\nexport declare function ɵangular_packages_router_router_j(r: ɵangular_packages_router_router_h): (bootstrappedComponentRef: ComponentRef<any>) => void;\n\nexport declare function ɵangular_packages_router_router_k(): (typeof ɵangular_packages_router_router_h | {\n    provide: InjectionToken<(() => void)[]>;\n    multi: boolean;\n    useFactory: typeof ɵangular_packages_router_router_i;\n    deps: (typeof ɵangular_packages_router_router_h)[];\n    useExisting?: undefined;\n} | {\n    provide: InjectionToken<(compRef: ComponentRef<any>) => void>;\n    useFactory: typeof ɵangular_packages_router_router_j;\n    deps: (typeof ɵangular_packages_router_router_h)[];\n    multi?: undefined;\n    useExisting?: undefined;\n} | {\n    provide: InjectionToken<((compRef: ComponentRef<any>) => void)[]>;\n    multi: boolean;\n    useExisting: InjectionToken<(compRef: ComponentRef<any>) => void>;\n    useFactory?: undefined;\n    deps?: undefined;\n})[];\n\n\nexport declare class ɵangular_packages_router_router_m<T> {\n    constructor(root: ɵangular_packages_router_router_n<T>);\n    readonly root: T;\n}\n\nexport declare class ɵangular_packages_router_router_n<T> {\n    value: T;\n    children: ɵangular_packages_router_router_n<T>[];\n    constructor(value: T, children: ɵangular_packages_router_router_n<T>[]);\n    toString(): string;\n}\n\nexport declare class ɵangular_packages_router_router_o implements OnDestroy {\n    private router;\n    /** @docsNotRequired */ readonly viewportScroller: ViewportScroller;\n    private options;\n    private routerEventsSubscription;\n    private scrollEventsSubscription;\n    private lastId;\n    private lastSource;\n    private restoredId;\n    private store;\n    constructor(router: Router, \n    /** @docsNotRequired */ viewportScroller: ViewportScroller, options?: {\n        scrollPositionRestoration?: 'disabled' | 'enabled' | 'top';\n        anchorScrolling?: 'disabled' | 'enabled';\n    });\n    init(): void;\n    private createScrollEvents;\n    private consumeScrollEvents;\n    private scheduleScrollEvent;\n    ngOnDestroy(): void;\n}\n\n\n/**\n * This component is used internally within the router to be a placeholder when an empty\n * router-outlet is needed. For example, with a config such as:\n *\n * `{path: 'parent', outlet: 'nav', children: [...]}`\n *\n * In order to render, there needs to be a component on this config, which will default\n * to this `EmptyOutletComponent`.\n */\ndeclare class ɵEmptyOutletComponent {\n}\nexport { ɵEmptyOutletComponent }\nexport { ɵEmptyOutletComponent as ɵangular_packages_router_router_l }\n\n/**\n * Flattens single-level nested arrays.\n */\nexport declare function ɵflatten<T>(arr: T[][]): T[];\n\nexport declare const ɵROUTER_PROVIDERS: Provider[];\n\nexport { }\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqpEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAidA;;;;;;;;;;;;"}
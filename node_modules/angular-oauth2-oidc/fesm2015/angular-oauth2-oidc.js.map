{"version":3,"sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/angular-oauth2-oidc/fesm2015/angular-oauth2-oidc.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAeA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA2MC,kEAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA0pFD,4xFAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAoJD,8IAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8QD,iKAOC","file":"angular-oauth2-oidc.js","sourcesContent":["import { Injectable, NgZone, Optional, NgModule, InjectionToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { HttpHeaders, HttpParams, HttpClient, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { __awaiter } from 'tslib';\nimport { Subject, of, from, race, throwError, merge } from 'rxjs';\nimport { filter, tap, delay, switchMap, map, first, catchError, timeout, take, mergeMap } from 'rxjs/operators';\nimport { KEYUTIL, KJUR } from 'jsrsasign';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Additional options that can be passt to tryLogin.\n */\nclass LoginOptions {\n    constructor() {\n        /**\n         * Normally, you want to clear your hash fragment after\n         * the lib read the token(s) so that they are not displayed\n         * anymore in the url. If not, set this to true.\n         */\n        this.preventClearHashAfterLogin = false;\n    }\n}\n/**\n * Defines the logging interface the OAuthService uses\n * internally. Is compatible with the `console` object,\n * but you can provide your own implementation as well\n * through dependency injection.\n * @abstract\n */\nclass OAuthLogger {\n}\n/**\n * Defines a simple storage that can be used for\n * storing the tokens at client side.\n * Is compatible to localStorage and sessionStorage,\n * but you can also create your own implementations.\n * @abstract\n */\nclass OAuthStorage {\n}\n/**\n * Represents the received tokens, the received state\n * and the parsed claims from the id-token.\n */\nclass ReceivedTokens {\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\n/**\n * @param {?} str\n * @return {?}\n */\nfunction b64DecodeUnicode(str) {\n    /** @type {?} */\n    const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n    return decodeURIComponent(atob(base64)\n        .split('')\n        .map((/**\n     * @param {?} c\n     * @return {?}\n     */\n    function (c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }))\n        .join(''));\n}\n/**\n * @param {?} str\n * @return {?}\n */\nfunction base64UrlEncode(str) {\n    /** @type {?} */\n    const base64 = btoa(str);\n    return base64\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=/g, '');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Interface for Handlers that are hooked in to\n * validate tokens.\n * @abstract\n */\nclass ValidationHandler {\n}\n/**\n * This abstract implementation of ValidationHandler already implements\n * the method validateAtHash. However, to make use of it,\n * you have to override the method calcHash.\n * @abstract\n */\nclass AbstractValidationHandler {\n    /**\n     * Validates the at_hash in an id_token against the received access_token.\n     * @param {?} params\n     * @return {?}\n     */\n    validateAtHash(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /** @type {?} */\n            let hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\n            /** @type {?} */\n            let tokenHash = yield this.calcHash(params.accessToken, hashAlg);\n            // sha256(accessToken, { asString: true });\n            /** @type {?} */\n            let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n            /** @type {?} */\n            let atHash = base64UrlEncode(leftMostHalf);\n            /** @type {?} */\n            let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n            if (atHash !== claimsAtHash) {\n                console.error('exptected at_hash: ' + atHash);\n                console.error('actual at_hash: ' + claimsAtHash);\n            }\n            return atHash === claimsAtHash;\n        });\n    }\n    /**\n     * Infers the name of the hash algorithm to use\n     * from the alg field of an id_token.\n     *\n     * @protected\n     * @param {?} jwtHeader the id_token's parsed header\n     * @return {?}\n     */\n    inferHashAlgorithm(jwtHeader) {\n        /** @type {?} */\n        let alg = jwtHeader['alg'];\n        if (!alg.match(/^.S[0-9]{3}$/)) {\n            throw new Error('Algorithm not supported: ' + alg);\n        }\n        return 'sha-' + alg.substr(2);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass UrlHelperService {\n    /**\n     * @param {?=} customHashFragment\n     * @return {?}\n     */\n    getHashFragmentParams(customHashFragment) {\n        /** @type {?} */\n        let hash = customHashFragment || window.location.hash;\n        hash = decodeURIComponent(hash);\n        if (hash.indexOf('#') !== 0) {\n            return {};\n        }\n        /** @type {?} */\n        const questionMarkPosition = hash.indexOf('?');\n        if (questionMarkPosition > -1) {\n            hash = hash.substr(questionMarkPosition + 1);\n        }\n        else {\n            hash = hash.substr(1);\n        }\n        return this.parseQueryString(hash);\n    }\n    /**\n     * @param {?} queryString\n     * @return {?}\n     */\n    parseQueryString(queryString) {\n        /** @type {?} */\n        const data = {};\n        /** @type {?} */\n        let pairs;\n        /** @type {?} */\n        let pair;\n        /** @type {?} */\n        let separatorIndex;\n        /** @type {?} */\n        let escapedKey;\n        /** @type {?} */\n        let escapedValue;\n        /** @type {?} */\n        let key;\n        /** @type {?} */\n        let value;\n        if (queryString === null) {\n            return data;\n        }\n        pairs = queryString.split('&');\n        for (let i = 0; i < pairs.length; i++) {\n            pair = pairs[i];\n            separatorIndex = pair.indexOf('=');\n            if (separatorIndex === -1) {\n                escapedKey = pair;\n                escapedValue = null;\n            }\n            else {\n                escapedKey = pair.substr(0, separatorIndex);\n                escapedValue = pair.substr(separatorIndex + 1);\n            }\n            key = decodeURIComponent(escapedKey);\n            value = decodeURIComponent(escapedValue);\n            if (key.substr(0, 1) === '/') {\n                key = key.substr(1);\n            }\n            data[key] = value;\n        }\n        return data;\n    }\n}\nUrlHelperService.decorators = [\n    { type: Injectable }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass OAuthEvent {\n    /**\n     * @param {?} type\n     */\n    constructor(type) {\n        this.type = type;\n    }\n}\nclass OAuthSuccessEvent extends OAuthEvent {\n    /**\n     * @param {?} type\n     * @param {?=} info\n     */\n    constructor(type, info = null) {\n        super(type);\n        this.info = info;\n    }\n}\nclass OAuthInfoEvent extends OAuthEvent {\n    /**\n     * @param {?} type\n     * @param {?=} info\n     */\n    constructor(type, info = null) {\n        super(type);\n        this.info = info;\n    }\n}\nclass OAuthErrorEvent extends OAuthEvent {\n    /**\n     * @param {?} type\n     * @param {?} reason\n     * @param {?=} params\n     */\n    constructor(type, reason, params = null) {\n        super(type);\n        this.reason = reason;\n        this.params = params;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass AuthConfig {\n    /**\n     * @param {?=} json\n     */\n    constructor(json) {\n        /**\n         * The client's id as registered with the auth server\n         */\n        this.clientId = '';\n        /**\n         * The client's redirectUri as registered with the auth server\n         */\n        this.redirectUri = '';\n        /**\n         * An optional second redirectUri where the auth server\n         * redirects the user to after logging out.\n         */\n        this.postLogoutRedirectUri = '';\n        /**\n         * The auth server's endpoint that allows to log\n         * the user in when using implicit flow.\n         */\n        this.loginUrl = '';\n        /**\n         * The requested scopes\n         */\n        this.scope = 'openid profile';\n        this.resource = '';\n        this.rngUrl = '';\n        /**\n         * Defines whether to use OpenId Connect during\n         * implicit flow.\n         */\n        this.oidc = true;\n        /**\n         * Defines whether to request an access token during\n         * implicit flow.\n         */\n        this.requestAccessToken = true;\n        this.options = null;\n        /**\n         * The issuer's uri.\n         */\n        this.issuer = '';\n        /**\n         * The logout url.\n         */\n        this.logoutUrl = '';\n        /**\n         * Defines whether to clear the hash fragment after logging in.\n         */\n        this.clearHashAfterLogin = true;\n        /**\n         * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\n         */\n        this.tokenEndpoint = null;\n        /**\n         * Url of the userinfo endpoint as defined by OpenId Connect.\n         */\n        this.userinfoEndpoint = null;\n        this.responseType = '';\n        /**\n         * Defines whether additional debug information should\n         * be shown at the console. Note that in certain browsers\n         * the verbosity of the console needs to be explicitly set\n         * to include Debug level messages.\n         */\n        this.showDebugInformation = false;\n        /**\n         * The redirect uri used when doing silent refresh.\n         */\n        this.silentRefreshRedirectUri = '';\n        this.silentRefreshMessagePrefix = '';\n        /**\n         * Set this to true to display the iframe used for\n         * silent refresh for debugging.\n         */\n        this.silentRefreshShowIFrame = false;\n        /**\n         * Timeout for silent refresh.\n         * \\@internal\n         * depreacted b/c of typo, see silentRefreshTimeout\n         */\n        this.siletRefreshTimeout = 1000 * 20;\n        /**\n         * Timeout for silent refresh.\n         */\n        this.silentRefreshTimeout = 1000 * 20;\n        /**\n         * Some auth servers don't allow using password flow\n         * w/o a client secret while the standards do not\n         * demand for it. In this case, you can set a password\n         * here. As this password is exposed to the public\n         * it does not bring additional security and is therefore\n         * as good as using no password.\n         */\n        this.dummyClientSecret = null;\n        /**\n         * Defines whether https is required.\n         * The default value is remoteOnly which only allows\n         * http for localhost, while every other domains need\n         * to be used with https.\n         */\n        this.requireHttps = 'remoteOnly';\n        /**\n         * Defines whether every url provided by the discovery\n         * document has to start with the issuer's url.\n         */\n        this.strictDiscoveryDocumentValidation = true;\n        /**\n         * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\n         * with keys used to validate received id_tokens.\n         * This is taken out of the disovery document. Can be set manually too.\n         */\n        this.jwks = null;\n        /**\n         * Map with additional query parameter that are appended to\n         * the request when initializing implicit flow.\n         */\n        this.customQueryParams = null;\n        this.silentRefreshIFrameName = 'angular-oauth-oidc-silent-refresh-iframe';\n        /**\n         * Defines when the token_timeout event should be raised.\n         * If you set this to the default value 0.75, the event\n         * is triggered after 75% of the token's life time.\n         */\n        this.timeoutFactor = 0.75;\n        /**\n         * If true, the lib will try to check whether the user\n         * is still logged in on a regular basis as described\n         * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n         */\n        this.sessionChecksEnabled = false;\n        /**\n         * Interval in msec for checking the session\n         * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n         */\n        this.sessionCheckIntervall = 3 * 1000;\n        /**\n         * Url for the iframe used for session checks\n         */\n        this.sessionCheckIFrameUrl = null;\n        /**\n         * Name of the iframe to use for session checks\n         */\n        this.sessionCheckIFrameName = 'angular-oauth-oidc-check-session-iframe';\n        /**\n         * This property has been introduced to disable at_hash checks\n         * and is indented for Identity Provider that does not deliver\n         * an at_hash EVEN THOUGH its recommended by the OIDC specs.\n         * Of course, when disabling these checks the we are bypassing\n         * a security check which means we are more vulnerable.\n         */\n        this.disableAtHashCheck = false;\n        /**\n         * Defines wether to check the subject of a refreshed token after silent refresh.\n         * Normally, it should be the same as before.\n         */\n        this.skipSubjectCheck = false;\n        this.useIdTokenHintForSilentRefresh = false;\n        /**\n         * Defined whether to skip the validation of the issuer in the discovery document.\n         * Normally, the discovey document's url starts with the url of the issuer.\n         */\n        this.skipIssuerCheck = false;\n        /**\n         * final state sent to issuer is built as follows:\n         * state = nonce + nonceStateSeparator + additional state\n         * Default separator is ';' (encoded %3B).\n         * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\n         */\n        this.nonceStateSeparator = ';';\n        /**\n         * Set this to true to use HTTP BASIC auth for password flow\n         */\n        this.useHttpBasicAuth = false;\n        /**\n         * The interceptors waits this time span if there is no token\n         */\n        this.waitForTokenInMsec = 0;\n        /**\n         * Code Flow is by defauld used together with PKCI which is also higly recommented.\n         * You can disbale it here by setting this flag to true.\n         * https://tools.ietf.org/html/rfc7636#section-1.1\n         */\n        this.disablePKCE = false;\n        /**\n         * This property allows you to override the method that is used to open the login url,\n         * allowing a way for implementations to specify their own method of routing to new\n         * urls.\n         */\n        this.openUri = (/**\n         * @param {?} uri\n         * @return {?}\n         */\n        uri => {\n            location.href = uri;\n        });\n        if (json) {\n            Object.assign(this, json);\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * This custom encoder allows charactes like +, % and / to be used in passwords\n */\nclass WebHttpUrlEncodingCodec {\n    /**\n     * @param {?} k\n     * @return {?}\n     */\n    encodeKey(k) {\n        return encodeURIComponent(k);\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    encodeValue(v) {\n        return encodeURIComponent(v);\n    }\n    /**\n     * @param {?} k\n     * @return {?}\n     */\n    decodeKey(k) {\n        return decodeURIComponent(k);\n    }\n    /**\n     * @param {?} v\n     * @return {?}\n     */\n    decodeValue(v) {\n        return decodeURIComponent(v);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Abstraction for crypto algorithms\n * @abstract\n */\nclass CryptoHandler {\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Service for logging in and logging out with\n * OIDC and OAuth2. Supports implicit flow and\n * password flow.\n */\nclass OAuthService extends AuthConfig {\n    /**\n     * @param {?} ngZone\n     * @param {?} http\n     * @param {?} storage\n     * @param {?} tokenValidationHandler\n     * @param {?} config\n     * @param {?} urlHelper\n     * @param {?} logger\n     * @param {?} crypto\n     */\n    constructor(ngZone, http, storage, tokenValidationHandler, config, urlHelper, logger, crypto) {\n        super();\n        this.ngZone = ngZone;\n        this.http = http;\n        this.config = config;\n        this.urlHelper = urlHelper;\n        this.logger = logger;\n        this.crypto = crypto;\n        /**\n         * \\@internal\n         * Deprecated:  use property events instead\n         */\n        this.discoveryDocumentLoaded = false;\n        /**\n         * The received (passed around) state, when logging\n         * in with implicit flow.\n         */\n        this.state = '';\n        this.eventsSubject = new Subject();\n        this.discoveryDocumentLoadedSubject = new Subject();\n        this.grantTypesSupported = [];\n        this.inImplicitFlow = false;\n        this.debug('angular-oauth2-oidc v8-beta');\n        this.discoveryDocumentLoaded$ = this.discoveryDocumentLoadedSubject.asObservable();\n        this.events = this.eventsSubject.asObservable();\n        if (tokenValidationHandler) {\n            this.tokenValidationHandler = tokenValidationHandler;\n        }\n        if (config) {\n            this.configure(config);\n        }\n        try {\n            if (storage) {\n                this.setStorage(storage);\n            }\n            else if (typeof sessionStorage !== 'undefined') {\n                this.setStorage(sessionStorage);\n            }\n        }\n        catch (e) {\n            console.error('No OAuthStorage provided and cannot access default (sessionStorage).'\n                + 'Consider providing a custom OAuthStorage implementation in your module.', e);\n        }\n        this.setupRefreshTimer();\n    }\n    /**\n     * Use this method to configure the service\n     * @param {?} config the configuration\n     * @return {?}\n     */\n    configure(config) {\n        // For the sake of downward compatibility with\n        // original configuration API\n        Object.assign(this, new AuthConfig(), config);\n        this.config = Object.assign((/** @type {?} */ ({})), new AuthConfig(), config);\n        if (this.sessionChecksEnabled) {\n            this.setupSessionCheck();\n        }\n        this.configChanged();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    configChanged() {\n        this.setupRefreshTimer();\n    }\n    /**\n     * @return {?}\n     */\n    restartSessionChecksIfStillLoggedIn() {\n        if (this.hasValidIdToken()) {\n            this.initSessionCheck();\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    restartRefreshTimerIfStillLoggedIn() {\n        this.setupExpirationTimers();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    setupSessionCheck() {\n        this.events.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => e.type === 'token_received'))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            this.initSessionCheck();\n        }));\n    }\n    /**\n     * Will setup up silent refreshing for when the token is\n     * about to expire. When the user is logged out via this.logOut method, the\n     * silent refreshing will pause and not refresh the tokens until the user is\n     * logged back in via receiving a new token.\n     * @param {?=} params Additional parameter to pass\n     * @param {?=} listenTo Setup automatic refresh of a specific token type\n     * @param {?=} noPrompt\n     * @return {?}\n     */\n    setupAutomaticSilentRefresh(params = {}, listenTo, noPrompt = true) {\n        /** @type {?} */\n        let shouldRunSilentRefresh = true;\n        this.events.pipe(tap((/**\n         * @param {?} e\n         * @return {?}\n         */\n        (e) => {\n            if (e.type === 'token_received') {\n                shouldRunSilentRefresh = true;\n            }\n            else if (e.type === 'logout') {\n                shouldRunSilentRefresh = false;\n            }\n        })), filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => e.type === 'token_expires'))).subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            /** @type {?} */\n            const event = (/** @type {?} */ (e));\n            if ((listenTo == null || listenTo === 'any' || event.info === listenTo) && shouldRunSilentRefresh) {\n                // this.silentRefresh(params, noPrompt).catch(_ => {\n                this.refreshInternal(params, noPrompt).catch((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                _ => {\n                    this.debug('Automatic silent refresh did not work');\n                }));\n            }\n        }));\n        this.restartRefreshTimerIfStillLoggedIn();\n    }\n    /**\n     * @protected\n     * @param {?} params\n     * @param {?} noPrompt\n     * @return {?}\n     */\n    refreshInternal(params, noPrompt) {\n        if (this.responseType === 'code') {\n            return this.refreshToken();\n        }\n        else {\n            return this.silentRefresh(params, noPrompt);\n        }\n    }\n    /**\n     * Convenience method that first calls `loadDiscoveryDocument(...)` and\n     * directly chains using the `then(...)` part of the promise to call\n     * the `tryLogin(...)` method.\n     *\n     * @param {?=} options LoginOptions to pass through to `tryLogin(...)`\n     * @return {?}\n     */\n    loadDiscoveryDocumentAndTryLogin(options = null) {\n        return this.loadDiscoveryDocument().then((/**\n         * @param {?} doc\n         * @return {?}\n         */\n        doc => {\n            return this.tryLogin(options);\n        }));\n    }\n    /**\n     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\n     * and if then chains to `initImplicitFlow()`, but only if there is no valid\n     * IdToken or no valid AccessToken.\n     *\n     * @param {?=} options LoginOptions to pass through to `tryLogin(...)`\n     * @return {?}\n     */\n    loadDiscoveryDocumentAndLogin(options = null) {\n        return this.loadDiscoveryDocumentAndTryLogin(options).then((/**\n         * @param {?} _\n         * @return {?}\n         */\n        _ => {\n            if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\n                this.initImplicitFlow();\n                return false;\n            }\n            else {\n                return true;\n            }\n        }));\n    }\n    /**\n     * @protected\n     * @param {...?} args\n     * @return {?}\n     */\n    debug(...args) {\n        if (this.showDebugInformation) {\n            this.logger.debug.apply(console, args);\n        }\n    }\n    /**\n     * @protected\n     * @param {?} url\n     * @return {?}\n     */\n    validateUrlFromDiscoveryDocument(url) {\n        /** @type {?} */\n        const errors = [];\n        /** @type {?} */\n        const httpsCheck = this.validateUrlForHttps(url);\n        /** @type {?} */\n        const issuerCheck = this.validateUrlAgainstIssuer(url);\n        if (!httpsCheck) {\n            errors.push('https for all urls required. Also for urls received by discovery.');\n        }\n        if (!issuerCheck) {\n            errors.push('Every url in discovery document has to start with the issuer url.' +\n                'Also see property strictDiscoveryDocumentValidation.');\n        }\n        return errors;\n    }\n    /**\n     * @protected\n     * @param {?} url\n     * @return {?}\n     */\n    validateUrlForHttps(url) {\n        if (!url) {\n            return true;\n        }\n        /** @type {?} */\n        const lcUrl = url.toLowerCase();\n        if (this.requireHttps === false) {\n            return true;\n        }\n        if ((lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) ||\n            lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) &&\n            this.requireHttps === 'remoteOnly') {\n            return true;\n        }\n        return lcUrl.startsWith('https://');\n    }\n    /**\n     * @protected\n     * @param {?} url\n     * @return {?}\n     */\n    validateUrlAgainstIssuer(url) {\n        if (!this.strictDiscoveryDocumentValidation) {\n            return true;\n        }\n        if (!url) {\n            return true;\n        }\n        return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    setupRefreshTimer() {\n        if (typeof window === 'undefined') {\n            this.debug('timer not supported on this plattform');\n            return;\n        }\n        if (this.hasValidIdToken()) {\n            this.clearAccessTokenTimer();\n            this.clearIdTokenTimer();\n            this.setupExpirationTimers();\n        }\n        this.events.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => e.type === 'token_received'))).subscribe((/**\n         * @param {?} _\n         * @return {?}\n         */\n        _ => {\n            this.clearAccessTokenTimer();\n            this.clearIdTokenTimer();\n            this.setupExpirationTimers();\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    setupExpirationTimers() {\n        /** @type {?} */\n        const idTokenExp = this.getIdTokenExpiration() || Number.MAX_VALUE;\n        /** @type {?} */\n        const accessTokenExp = this.getAccessTokenExpiration() || Number.MAX_VALUE;\n        /** @type {?} */\n        const useAccessTokenExp = accessTokenExp <= idTokenExp;\n        if (this.hasValidAccessToken() && useAccessTokenExp) {\n            this.setupAccessTokenTimer();\n        }\n        if (this.hasValidIdToken() && !useAccessTokenExp) {\n            this.setupIdTokenTimer();\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    setupAccessTokenTimer() {\n        /** @type {?} */\n        const expiration = this.getAccessTokenExpiration();\n        /** @type {?} */\n        const storedAt = this.getAccessTokenStoredAt();\n        /** @type {?} */\n        const timeout = this.calcTimeout(storedAt, expiration);\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            this.accessTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'access_token'))\n                .pipe(delay(timeout))\n                .subscribe((/**\n             * @param {?} e\n             * @return {?}\n             */\n            e => {\n                this.ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.eventsSubject.next(e);\n                }));\n            }));\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    setupIdTokenTimer() {\n        /** @type {?} */\n        const expiration = this.getIdTokenExpiration();\n        /** @type {?} */\n        const storedAt = this.getIdTokenStoredAt();\n        /** @type {?} */\n        const timeout = this.calcTimeout(storedAt, expiration);\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            this.idTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'id_token'))\n                .pipe(delay(timeout))\n                .subscribe((/**\n             * @param {?} e\n             * @return {?}\n             */\n            e => {\n                this.ngZone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this.eventsSubject.next(e);\n                }));\n            }));\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    clearAccessTokenTimer() {\n        if (this.accessTokenTimeoutSubscription) {\n            this.accessTokenTimeoutSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    clearIdTokenTimer() {\n        if (this.idTokenTimeoutSubscription) {\n            this.idTokenTimeoutSubscription.unsubscribe();\n        }\n    }\n    /**\n     * @protected\n     * @param {?} storedAt\n     * @param {?} expiration\n     * @return {?}\n     */\n    calcTimeout(storedAt, expiration) {\n        /** @type {?} */\n        const now = Date.now();\n        /** @type {?} */\n        const delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n        return Math.max(0, delta);\n    }\n    /**\n     * DEPRECATED. Use a provider for OAuthStorage instead:\n     *\n     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\n     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\n     * Sets a custom storage used to store the received\n     * tokens on client side. By default, the browser's\n     * sessionStorage is used.\n     * @ignore\n     *\n     * @param {?} storage\n     * @return {?}\n     */\n    setStorage(storage) {\n        this._storage = storage;\n        this.configChanged();\n    }\n    /**\n     * Loads the discovery document to configure most\n     * properties of this service. The url of the discovery\n     * document is infered from the issuer's url according\n     * to the OpenId Connect spec. To use another url you\n     * can pass it to to optional parameter fullUrl.\n     *\n     * @param {?=} fullUrl\n     * @return {?}\n     */\n    loadDiscoveryDocument(fullUrl = null) {\n        return new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        (resolve, reject) => {\n            if (!fullUrl) {\n                fullUrl = this.issuer || '';\n                if (!fullUrl.endsWith('/')) {\n                    fullUrl += '/';\n                }\n                fullUrl += '.well-known/openid-configuration';\n            }\n            if (!this.validateUrlForHttps(fullUrl)) {\n                reject('issuer must use https, or config value for property requireHttps must allow http');\n                return;\n            }\n            this.http.get(fullUrl).subscribe((/**\n             * @param {?} doc\n             * @return {?}\n             */\n            doc => {\n                if (!this.validateDiscoveryDocument(doc)) {\n                    this.eventsSubject.next(new OAuthErrorEvent('discovery_document_validation_error', null));\n                    reject('discovery_document_validation_error');\n                    return;\n                }\n                this.loginUrl = doc.authorization_endpoint;\n                this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\n                this.grantTypesSupported = doc.grant_types_supported;\n                this.issuer = doc.issuer;\n                this.tokenEndpoint = doc.token_endpoint;\n                this.userinfoEndpoint = doc.userinfo_endpoint;\n                this.jwksUri = doc.jwks_uri;\n                this.sessionCheckIFrameUrl = doc.check_session_iframe || this.sessionCheckIFrameUrl;\n                this.discoveryDocumentLoaded = true;\n                this.discoveryDocumentLoadedSubject.next(doc);\n                if (this.sessionChecksEnabled) {\n                    this.restartSessionChecksIfStillLoggedIn();\n                }\n                this.loadJwks()\n                    .then((/**\n                 * @param {?} jwks\n                 * @return {?}\n                 */\n                jwks => {\n                    /** @type {?} */\n                    const result = {\n                        discoveryDocument: doc,\n                        jwks: jwks\n                    };\n                    /** @type {?} */\n                    const event = new OAuthSuccessEvent('discovery_document_loaded', result);\n                    this.eventsSubject.next(event);\n                    resolve(event);\n                    return;\n                }))\n                    .catch((/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                err => {\n                    this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n                    reject(err);\n                    return;\n                }));\n            }), (/**\n             * @param {?} err\n             * @return {?}\n             */\n            err => {\n                this.logger.error('error loading discovery document', err);\n                this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n                reject(err);\n            }));\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    loadJwks() {\n        return new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        (resolve, reject) => {\n            if (this.jwksUri) {\n                this.http.get(this.jwksUri).subscribe((/**\n                 * @param {?} jwks\n                 * @return {?}\n                 */\n                jwks => {\n                    this.jwks = jwks;\n                    this.eventsSubject.next(new OAuthSuccessEvent('discovery_document_loaded'));\n                    resolve(jwks);\n                }), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                err => {\n                    this.logger.error('error loading jwks', err);\n                    this.eventsSubject.next(new OAuthErrorEvent('jwks_load_error', err));\n                    reject(err);\n                }));\n            }\n            else {\n                resolve(null);\n            }\n        }));\n    }\n    /**\n     * @protected\n     * @param {?} doc\n     * @return {?}\n     */\n    validateDiscoveryDocument(doc) {\n        /** @type {?} */\n        let errors;\n        if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n            this.logger.error('invalid issuer in discovery document', 'expected: ' + this.issuer, 'current: ' + doc.issuer);\n            return false;\n        }\n        errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n        if (errors.length > 0) {\n            this.logger.error('error validating authorization_endpoint in discovery document', errors);\n            return false;\n        }\n        errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n        if (errors.length > 0) {\n            this.logger.error('error validating end_session_endpoint in discovery document', errors);\n            return false;\n        }\n        errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n        if (errors.length > 0) {\n            this.logger.error('error validating token_endpoint in discovery document', errors);\n        }\n        errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n        if (errors.length > 0) {\n            this.logger.error('error validating userinfo_endpoint in discovery document', errors);\n            return false;\n        }\n        errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n        if (errors.length > 0) {\n            this.logger.error('error validating jwks_uri in discovery document', errors);\n            return false;\n        }\n        if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n            this.logger.warn('sessionChecksEnabled is activated but discovery document' +\n                ' does not contain a check_session_iframe field');\n        }\n        return true;\n    }\n    /**\n     * Uses password flow to exchange userName and password for an\n     * access_token. After receiving the access_token, this method\n     * uses it to query the userinfo endpoint in order to get information\n     * about the user in question.\n     *\n     * When using this, make sure that the property oidc is set to false.\n     * Otherwise stricter validations take place that make this operation\n     * fail.\n     *\n     * @param {?} userName\n     * @param {?} password\n     * @param {?=} headers Optional additional http-headers.\n     * @return {?}\n     */\n    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName, password, headers = new HttpHeaders()) {\n        return this.fetchTokenUsingPasswordFlow(userName, password, headers).then((/**\n         * @return {?}\n         */\n        () => this.loadUserProfile()));\n    }\n    /**\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\n     *\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\n     * Otherwise stricter validations take place that make this operation fail.\n     * @return {?}\n     */\n    loadUserProfile() {\n        if (!this.hasValidAccessToken()) {\n            throw new Error('Can not load User Profile without access_token');\n        }\n        if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n            throw new Error('userinfoEndpoint must use https, or config value for property requireHttps must allow http');\n        }\n        return new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        (resolve, reject) => {\n            /** @type {?} */\n            const headers = new HttpHeaders().set('Authorization', 'Bearer ' + this.getAccessToken());\n            this.http.get(this.userinfoEndpoint, { headers }).subscribe((/**\n             * @param {?} info\n             * @return {?}\n             */\n            info => {\n                this.debug('userinfo received', info);\n                /** @type {?} */\n                const existingClaims = this.getIdentityClaims() || {};\n                if (!this.skipSubjectCheck) {\n                    if (this.oidc &&\n                        (!existingClaims['sub'] || info.sub !== existingClaims['sub'])) {\n                        /** @type {?} */\n                        const err = 'if property oidc is true, the received user-id (sub) has to be the user-id ' +\n                            'of the user that has logged in with oidc.\\n' +\n                            'if you are not using oidc but just oauth2 password flow set oidc to false';\n                        reject(err);\n                        return;\n                    }\n                }\n                info = Object.assign({}, existingClaims, info);\n                this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n                this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n                resolve(info);\n            }), (/**\n             * @param {?} err\n             * @return {?}\n             */\n            err => {\n                this.logger.error('error loading user info', err);\n                this.eventsSubject.next(new OAuthErrorEvent('user_profile_load_error', err));\n                reject(err);\n            }));\n        }));\n    }\n    /**\n     * Uses password flow to exchange userName and password for an access_token.\n     * @param {?} userName\n     * @param {?} password\n     * @param {?=} headers Optional additional http-headers.\n     * @return {?}\n     */\n    fetchTokenUsingPasswordFlow(userName, password, headers = new HttpHeaders()) {\n        if (!this.validateUrlForHttps(this.tokenEndpoint)) {\n            throw new Error('tokenEndpoint must use https, or config value for property requireHttps must allow http');\n        }\n        return new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        (resolve, reject) => {\n            /**\n             * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n             * serialize and parse URL parameter keys and values.\n             *\n             * \\@stable\n             * @type {?}\n             */\n            let params = new HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\n                .set('grant_type', 'password')\n                .set('scope', this.scope)\n                .set('username', userName)\n                .set('password', password);\n            if (this.useHttpBasicAuth) {\n                /** @type {?} */\n                const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n                headers = headers.set('Authorization', 'Basic ' + header);\n            }\n            if (!this.useHttpBasicAuth) {\n                params = params.set('client_id', this.clientId);\n            }\n            if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n                params = params.set('client_secret', this.dummyClientSecret);\n            }\n            if (this.customQueryParams) {\n                for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                    params = params.set(key, this.customQueryParams[key]);\n                }\n            }\n            headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n            this.http\n                .post(this.tokenEndpoint, params, { headers })\n                .subscribe((/**\n             * @param {?} tokenResponse\n             * @return {?}\n             */\n            tokenResponse => {\n                this.debug('tokenResponse', tokenResponse);\n                this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in, tokenResponse.scope);\n                this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                resolve(tokenResponse);\n            }), (/**\n             * @param {?} err\n             * @return {?}\n             */\n            err => {\n                this.logger.error('Error performing password flow', err);\n                this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n                reject(err);\n            }));\n        }));\n    }\n    /**\n     * Refreshes the token using a refresh_token.\n     * This does not work for implicit flow, b/c\n     * there is no refresh_token in this flow.\n     * A solution for this is provided by the\n     * method silentRefresh.\n     * @return {?}\n     */\n    refreshToken() {\n        if (!this.validateUrlForHttps(this.tokenEndpoint)) {\n            throw new Error('tokenEndpoint must use https, or config value for property requireHttps must allow http');\n        }\n        return new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        (resolve, reject) => {\n            /** @type {?} */\n            let params = new HttpParams()\n                .set('grant_type', 'refresh_token')\n                .set('client_id', this.clientId)\n                .set('scope', this.scope)\n                .set('refresh_token', this._storage.getItem('refresh_token'));\n            if (this.dummyClientSecret) {\n                params = params.set('client_secret', this.dummyClientSecret);\n            }\n            if (this.customQueryParams) {\n                for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                    params = params.set(key, this.customQueryParams[key]);\n                }\n            }\n            /** @type {?} */\n            const headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n            this.http\n                .post(this.tokenEndpoint, params, { headers })\n                .pipe(switchMap((/**\n             * @param {?} tokenResponse\n             * @return {?}\n             */\n            tokenResponse => {\n                if (tokenResponse.id_token) {\n                    return from(this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true))\n                        .pipe(tap((/**\n                     * @param {?} result\n                     * @return {?}\n                     */\n                    result => this.storeIdToken(result))), map((/**\n                     * @param {?} _\n                     * @return {?}\n                     */\n                    _ => tokenResponse)));\n                }\n                else {\n                    return of(tokenResponse);\n                }\n            })))\n                .subscribe((/**\n             * @param {?} tokenResponse\n             * @return {?}\n             */\n            tokenResponse => {\n                this.debug('refresh tokenResponse', tokenResponse);\n                this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in, tokenResponse.scope);\n                this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n                resolve(tokenResponse);\n            }), (/**\n             * @param {?} err\n             * @return {?}\n             */\n            err => {\n                this.logger.error('Error performing password flow', err);\n                this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n                reject(err);\n            }));\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    removeSilentRefreshEventListener() {\n        if (this.silentRefreshPostMessageEventListener) {\n            window.removeEventListener('message', this.silentRefreshPostMessageEventListener);\n            this.silentRefreshPostMessageEventListener = null;\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    setupSilentRefreshEventListener() {\n        this.removeSilentRefreshEventListener();\n        this.silentRefreshPostMessageEventListener = (/**\n         * @param {?} e\n         * @return {?}\n         */\n        (e) => {\n            /** @type {?} */\n            const message = this.processMessageEventMessage(e);\n            this.tryLogin({\n                customHashFragment: message,\n                preventClearHashAfterLogin: true,\n                onLoginError: (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                err => {\n                    this.eventsSubject.next(new OAuthErrorEvent('silent_refresh_error', err));\n                }),\n                onTokenReceived: (/**\n                 * @return {?}\n                 */\n                () => {\n                    this.eventsSubject.next(new OAuthSuccessEvent('silently_refreshed'));\n                })\n            }).catch((/**\n             * @param {?} err\n             * @return {?}\n             */\n            err => this.debug('tryLogin during silent refresh failed', err)));\n        });\n        window.addEventListener('message', this.silentRefreshPostMessageEventListener);\n    }\n    /**\n     * Performs a silent refresh for implicit flow.\n     * Use this method to get new tokens when/before\n     * the existing tokens expire.\n     * @param {?=} params\n     * @param {?=} noPrompt\n     * @return {?}\n     */\n    silentRefresh(params = {}, noPrompt = true) {\n        /** @type {?} */\n        const claims = this.getIdentityClaims() || {};\n        if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n            params['id_token_hint'] = this.getIdToken();\n        }\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n            throw new Error('tokenEndpoint must use https, or config value for property requireHttps must allow http');\n        }\n        if (typeof document === 'undefined') {\n            throw new Error('silent refresh is not supported on this platform');\n        }\n        /** @type {?} */\n        const existingIframe = document.getElementById(this.silentRefreshIFrameName);\n        if (existingIframe) {\n            document.body.removeChild(existingIframe);\n        }\n        this.silentRefreshSubject = claims['sub'];\n        /** @type {?} */\n        const iframe = document.createElement('iframe');\n        iframe.id = this.silentRefreshIFrameName;\n        this.setupSilentRefreshEventListener();\n        /** @type {?} */\n        const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n        this.createLoginUrl(null, null, redirectUri, noPrompt, params).then((/**\n         * @param {?} url\n         * @return {?}\n         */\n        url => {\n            iframe.setAttribute('src', url);\n            if (!this.silentRefreshShowIFrame) {\n                iframe.style['display'] = 'none';\n            }\n            document.body.appendChild(iframe);\n        }));\n        /** @type {?} */\n        const errors = this.events.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => e instanceof OAuthErrorEvent)), first());\n        /** @type {?} */\n        const success = this.events.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => e.type === 'silently_refreshed')), first());\n        /** @type {?} */\n        const timeout = of(new OAuthErrorEvent('silent_refresh_timeout', null)).pipe(delay(this.silentRefreshTimeout));\n        return race([errors, success, timeout])\n            .pipe(tap((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            if (e.type === 'silent_refresh_timeout') {\n                this.eventsSubject.next(e);\n            }\n        })), map((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            if (e instanceof OAuthErrorEvent) {\n                throw e;\n            }\n            return e;\n        })))\n            .toPromise();\n    }\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    initImplicitFlowInPopup(options) {\n        options = options || {};\n        return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\n            display: 'popup'\n        }).then((/**\n         * @param {?} url\n         * @return {?}\n         */\n        url => {\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            (resolve, reject) => {\n                /** @type {?} */\n                let windowRef = window.open(url, '_blank', this.calculatePopupFeatures(options));\n                /** @type {?} */\n                const cleanup = (/**\n                 * @return {?}\n                 */\n                () => {\n                    window.removeEventListener('message', listener);\n                    windowRef.close();\n                    windowRef = null;\n                });\n                /** @type {?} */\n                const listener = (/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                (e) => {\n                    /** @type {?} */\n                    const message = this.processMessageEventMessage(e);\n                    this.tryLogin({\n                        customHashFragment: message,\n                        preventClearHashAfterLogin: true,\n                    }).then((/**\n                     * @return {?}\n                     */\n                    () => {\n                        cleanup();\n                        resolve();\n                    }), (/**\n                     * @param {?} err\n                     * @return {?}\n                     */\n                    err => {\n                        cleanup();\n                        reject(err);\n                    }));\n                });\n                window.addEventListener('message', listener);\n            }));\n        }));\n    }\n    /**\n     * @protected\n     * @param {?} options\n     * @return {?}\n     */\n    calculatePopupFeatures(options) {\n        // Specify an static height and width and calculate centered position\n        /** @type {?} */\n        const height = options.height || 470;\n        /** @type {?} */\n        const width = options.width || 500;\n        /** @type {?} */\n        const left = (screen.width / 2) - (width / 2);\n        /** @type {?} */\n        const top = (screen.height / 2) - (height / 2);\n        return `location=no,toolbar=no,width=${width},height=${height},top=${top},left=${left}`;\n    }\n    /**\n     * @protected\n     * @param {?} e\n     * @return {?}\n     */\n    processMessageEventMessage(e) {\n        /** @type {?} */\n        let expectedPrefix = '#';\n        if (this.silentRefreshMessagePrefix) {\n            expectedPrefix += this.silentRefreshMessagePrefix;\n        }\n        if (!e || !e.data || typeof e.data !== 'string') {\n            return;\n        }\n        /** @type {?} */\n        const prefixedMessage = e.data;\n        if (!prefixedMessage.startsWith(expectedPrefix)) {\n            return;\n        }\n        return '#' + prefixedMessage.substr(expectedPrefix.length);\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    canPerformSessionCheck() {\n        if (!this.sessionChecksEnabled) {\n            return false;\n        }\n        if (!this.sessionCheckIFrameUrl) {\n            console.warn('sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl');\n            return false;\n        }\n        /** @type {?} */\n        const sessionState = this.getSessionState();\n        if (!sessionState) {\n            console.warn('sessionChecksEnabled is activated but there is no session_state');\n            return false;\n        }\n        if (typeof document === 'undefined') {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    setupSessionCheckEventListener() {\n        this.removeSessionCheckEventListener();\n        this.sessionCheckEventListener = (/**\n         * @param {?} e\n         * @return {?}\n         */\n        (e) => {\n            /** @type {?} */\n            const origin = e.origin.toLowerCase();\n            /** @type {?} */\n            const issuer = this.issuer.toLowerCase();\n            this.debug('sessionCheckEventListener');\n            if (!issuer.startsWith(origin)) {\n                this.debug('sessionCheckEventListener', 'wrong origin', origin, 'expected', issuer);\n            }\n            // only run in Angular zone if it is 'changed' or 'error'\n            switch (e.data) {\n                case 'unchanged':\n                    this.handleSessionUnchanged();\n                    break;\n                case 'changed':\n                    this.ngZone.run((/**\n                     * @return {?}\n                     */\n                    () => {\n                        this.handleSessionChange();\n                    }));\n                    break;\n                case 'error':\n                    this.ngZone.run((/**\n                     * @return {?}\n                     */\n                    () => {\n                        this.handleSessionError();\n                    }));\n                    break;\n            }\n            this.debug('got info from session check inframe', e);\n        });\n        // prevent Angular from refreshing the view on every message (runs in intervals)\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            window.addEventListener('message', this.sessionCheckEventListener);\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    handleSessionUnchanged() {\n        this.debug('session check', 'session unchanged');\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    handleSessionChange() {\n        /* events: session_changed, relogin, stopTimer, logged_out*/\n        this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n        this.stopSessionCheckTimer();\n        if (this.silentRefreshRedirectUri) {\n            this.silentRefresh().catch((/**\n             * @param {?} _\n             * @return {?}\n             */\n            _ => this.debug('silent refresh failed after session changed')));\n            this.waitForSilentRefreshAfterSessionChange();\n        }\n        else {\n            this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n            this.logOut(true);\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    waitForSilentRefreshAfterSessionChange() {\n        this.events\n            .pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        (e) => e.type === 'silently_refreshed' ||\n            e.type === 'silent_refresh_timeout' ||\n            e.type === 'silent_refresh_error')), first())\n            .subscribe((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => {\n            if (e.type !== 'silently_refreshed') {\n                this.debug('silent refresh did not work after session changed');\n                this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n                this.logOut(true);\n            }\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    handleSessionError() {\n        this.stopSessionCheckTimer();\n        this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    removeSessionCheckEventListener() {\n        if (this.sessionCheckEventListener) {\n            window.removeEventListener('message', this.sessionCheckEventListener);\n            this.sessionCheckEventListener = null;\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    initSessionCheck() {\n        if (!this.canPerformSessionCheck()) {\n            return;\n        }\n        /** @type {?} */\n        const existingIframe = document.getElementById(this.sessionCheckIFrameName);\n        if (existingIframe) {\n            document.body.removeChild(existingIframe);\n        }\n        /** @type {?} */\n        const iframe = document.createElement('iframe');\n        iframe.id = this.sessionCheckIFrameName;\n        this.setupSessionCheckEventListener();\n        /** @type {?} */\n        const url = this.sessionCheckIFrameUrl;\n        iframe.setAttribute('src', url);\n        iframe.style.display = 'none';\n        document.body.appendChild(iframe);\n        this.startSessionCheckTimer();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    startSessionCheckTimer() {\n        this.stopSessionCheckTimer();\n        this.ngZone.runOutsideAngular((/**\n         * @return {?}\n         */\n        () => {\n            this.sessionCheckTimer = setInterval(this.checkSession.bind(this), this.sessionCheckIntervall);\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    stopSessionCheckTimer() {\n        if (this.sessionCheckTimer) {\n            clearInterval(this.sessionCheckTimer);\n            this.sessionCheckTimer = null;\n        }\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    checkSession() {\n        /** @type {?} */\n        const iframe = document.getElementById(this.sessionCheckIFrameName);\n        if (!iframe) {\n            this.logger.warn('checkSession did not find iframe', this.sessionCheckIFrameName);\n        }\n        /** @type {?} */\n        const sessionState = this.getSessionState();\n        if (!sessionState) {\n            this.stopSessionCheckTimer();\n        }\n        /** @type {?} */\n        const message = this.clientId + ' ' + sessionState;\n        iframe.contentWindow.postMessage(message, this.issuer);\n    }\n    /**\n     * @protected\n     * @param {?=} state\n     * @param {?=} loginHint\n     * @param {?=} customRedirectUri\n     * @param {?=} noPrompt\n     * @param {?=} params\n     * @return {?}\n     */\n    createLoginUrl(state = '', loginHint = '', customRedirectUri = '', noPrompt = false, params = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            /** @type {?} */\n            const that = this;\n            /** @type {?} */\n            let redirectUri;\n            if (customRedirectUri) {\n                redirectUri = customRedirectUri;\n            }\n            else {\n                redirectUri = this.redirectUri;\n            }\n            /** @type {?} */\n            const nonce = yield this.createAndSaveNonce();\n            if (state) {\n                state = nonce + this.config.nonceStateSeparator + state;\n            }\n            else {\n                state = nonce;\n            }\n            if (!this.requestAccessToken && !this.oidc) {\n                throw new Error('Either requestAccessToken or oidc or both must be true');\n            }\n            if (this.config.responseType) {\n                this.responseType = this.config.responseType;\n            }\n            else {\n                if (this.oidc && this.requestAccessToken) {\n                    this.responseType = 'id_token token';\n                }\n                else if (this.oidc && !this.requestAccessToken) {\n                    this.responseType = 'id_token';\n                }\n                else {\n                    this.responseType = 'token';\n                }\n            }\n            /** @type {?} */\n            const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n            /** @type {?} */\n            let scope = that.scope;\n            if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n                scope = 'openid ' + scope;\n            }\n            /** @type {?} */\n            let url = that.loginUrl +\n                seperationChar +\n                'response_type=' +\n                encodeURIComponent(that.responseType) +\n                '&client_id=' +\n                encodeURIComponent(that.clientId) +\n                '&state=' +\n                encodeURIComponent(state) +\n                '&redirect_uri=' +\n                encodeURIComponent(redirectUri) +\n                '&scope=' +\n                encodeURIComponent(scope);\n            if (this.responseType === 'code' && !this.disablePKCE) {\n                const [challenge, verifier] = yield this.createChallangeVerifierPairForPKCE();\n                this._storage.setItem('PKCI_verifier', verifier);\n                url += '&code_challenge=' + challenge;\n                url += '&code_challenge_method=S256';\n            }\n            if (loginHint) {\n                url += '&login_hint=' + encodeURIComponent(loginHint);\n            }\n            if (that.resource) {\n                url += '&resource=' + encodeURIComponent(that.resource);\n            }\n            if (that.oidc) {\n                url += '&nonce=' + encodeURIComponent(nonce);\n            }\n            if (noPrompt) {\n                url += '&prompt=none';\n            }\n            for (const key of Object.keys(params)) {\n                url +=\n                    '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n            }\n            if (this.customQueryParams) {\n                for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                    url +=\n                        '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\n                }\n            }\n            return url;\n        });\n    }\n    /**\n     * @param {?=} additionalState\n     * @param {?=} params\n     * @return {?}\n     */\n    initImplicitFlowInternal(additionalState = '', params = '') {\n        if (this.inImplicitFlow) {\n            return;\n        }\n        this.inImplicitFlow = true;\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n            throw new Error('loginUrl must use https, or config value for property requireHttps must allow http');\n        }\n        /** @type {?} */\n        let addParams = {};\n        /** @type {?} */\n        let loginHint = null;\n        if (typeof params === 'string') {\n            loginHint = params;\n        }\n        else if (typeof params === 'object') {\n            addParams = params;\n        }\n        this.createLoginUrl(additionalState, loginHint, null, false, addParams)\n            .then(this.config.openUri)\n            .catch((/**\n         * @param {?} error\n         * @return {?}\n         */\n        error => {\n            console.error('Error in initImplicitFlow', error);\n            this.inImplicitFlow = false;\n        }));\n    }\n    /**\n     * Starts the implicit flow and redirects to user to\n     * the auth servers' login url.\n     *\n     * @param {?=} additionalState Optional state that is passed around.\n     *  You'll find this state in the property `state` after `tryLogin` logged in the user.\n     * @param {?=} params Hash with additional parameter. If it is a string, it is used for the\n     *               parameter loginHint (for the sake of compatibility with former versions)\n     * @return {?}\n     */\n    initImplicitFlow(additionalState = '', params = '') {\n        if (this.loginUrl !== '') {\n            this.initImplicitFlowInternal(additionalState, params);\n        }\n        else {\n            this.events\n                .pipe(filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            e => e.type === 'discovery_document_loaded')))\n                .subscribe((/**\n             * @param {?} _\n             * @return {?}\n             */\n            _ => this.initImplicitFlowInternal(additionalState, params)));\n        }\n    }\n    /**\n     * Reset current implicit flow\n     *\n     * \\@description This method allows resetting the current implict flow in order to be initialized again.\n     * @return {?}\n     */\n    resetImplicitFlow() {\n        this.inImplicitFlow = false;\n    }\n    /**\n     * @protected\n     * @param {?} options\n     * @return {?}\n     */\n    callOnTokenReceivedIfExists(options) {\n        /** @type {?} */\n        const that = this;\n        if (options.onTokenReceived) {\n            /** @type {?} */\n            const tokenParams = {\n                idClaims: that.getIdentityClaims(),\n                idToken: that.getIdToken(),\n                accessToken: that.getAccessToken(),\n                state: that.state\n            };\n            options.onTokenReceived(tokenParams);\n        }\n    }\n    /**\n     * @protected\n     * @param {?} accessToken\n     * @param {?} refreshToken\n     * @param {?} expiresIn\n     * @param {?} grantedScopes\n     * @return {?}\n     */\n    storeAccessTokenResponse(accessToken, refreshToken, expiresIn, grantedScopes) {\n        this._storage.setItem('access_token', accessToken);\n        if (grantedScopes) {\n            this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split('+')));\n        }\n        this._storage.setItem('access_token_stored_at', '' + Date.now());\n        if (expiresIn) {\n            /** @type {?} */\n            const expiresInMilliSeconds = expiresIn * 1000;\n            /** @type {?} */\n            const now = new Date();\n            /** @type {?} */\n            const expiresAt = now.getTime() + expiresInMilliSeconds;\n            this._storage.setItem('expires_at', '' + expiresAt);\n        }\n        if (refreshToken) {\n            this._storage.setItem('refresh_token', refreshToken);\n        }\n    }\n    /**\n     * Delegates to tryLoginImplicitFlow for the sake of competability\n     * @param {?=} options Optional options.\n     * @return {?}\n     */\n    tryLogin(options = null) {\n        if (this.config.responseType === 'code') {\n            return this.tryLoginCodeFlow().then((/**\n             * @param {?} _\n             * @return {?}\n             */\n            _ => true));\n        }\n        else {\n            return this.tryLoginImplicitFlow(options);\n        }\n    }\n    /**\n     * @private\n     * @param {?} queryString\n     * @return {?}\n     */\n    parseQueryString(queryString) {\n        if (!queryString || queryString.length === 0) {\n            return {};\n        }\n        if (queryString.charAt(0) === '?') {\n            queryString = queryString.substr(1);\n        }\n        return this.urlHelper.parseQueryString(queryString);\n    }\n    /**\n     * @return {?}\n     */\n    tryLoginCodeFlow() {\n        /** @type {?} */\n        const parts = this.parseQueryString(window.location.search);\n        /** @type {?} */\n        const code = parts['code'];\n        /** @type {?} */\n        const state = parts['state'];\n        /** @type {?} */\n        const href = location.href\n            .replace(/[&\\?]code=[^&\\$]*/, '')\n            .replace(/[&\\?]scope=[^&\\$]*/, '')\n            .replace(/[&\\?]state=[^&\\$]*/, '')\n            .replace(/[&\\?]session_state=[^&\\$]*/, '');\n        history.replaceState(null, window.name, href);\n        let [nonceInState, userState] = this.parseState(state);\n        this.state = userState;\n        if (parts['error']) {\n            this.debug('error trying to login');\n            this.handleLoginError({}, parts);\n            /** @type {?} */\n            const err = new OAuthErrorEvent('code_error', {}, parts);\n            this.eventsSubject.next(err);\n            return Promise.reject(err);\n        }\n        if (!nonceInState) {\n            return Promise.resolve();\n        }\n        /** @type {?} */\n        const success = this.validateNonce(nonceInState);\n        if (!success) {\n            /** @type {?} */\n            const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n            this.eventsSubject.next(event);\n            return Promise.reject(event);\n        }\n        if (code) {\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            (resolve, reject) => {\n                this.getTokenFromCode(code).then((/**\n                 * @param {?} result\n                 * @return {?}\n                 */\n                result => {\n                    resolve();\n                })).catch((/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                err => {\n                    reject(err);\n                }));\n            }));\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Get token using an intermediate code. Works for the Authorization Code flow.\n     * @private\n     * @param {?} code\n     * @return {?}\n     */\n    getTokenFromCode(code) {\n        /** @type {?} */\n        let params = new HttpParams()\n            .set('grant_type', 'authorization_code')\n            .set('code', code)\n            .set('redirect_uri', this.redirectUri);\n        if (!this.disablePKCE) {\n            /** @type {?} */\n            const pkciVerifier = this._storage.getItem('PKCI_verifier');\n            if (!pkciVerifier) {\n                console.warn('No PKCI verifier found in oauth storage!');\n            }\n            else {\n                params = params.set('code_verifier', pkciVerifier);\n            }\n        }\n        return this.fetchAndProcessToken(params);\n    }\n    /**\n     * @private\n     * @param {?} params\n     * @return {?}\n     */\n    fetchAndProcessToken(params) {\n        /** @type {?} */\n        let headers = new HttpHeaders()\n            .set('Content-Type', 'application/x-www-form-urlencoded');\n        if (!this.validateUrlForHttps(this.tokenEndpoint)) {\n            throw new Error('tokenEndpoint must use Http. Also check property requireHttps.');\n        }\n        if (this.useHttpBasicAuth) {\n            /** @type {?} */\n            const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n            headers = headers.set('Authorization', 'Basic ' + header);\n        }\n        if (!this.useHttpBasicAuth) {\n            params = params.set('client_id', this.clientId);\n        }\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n            params = params.set('client_secret', this.dummyClientSecret);\n        }\n        return new Promise((/**\n         * @param {?} resolve\n         * @param {?} reject\n         * @return {?}\n         */\n        (resolve, reject) => {\n            if (this.customQueryParams) {\n                for (let key of Object.getOwnPropertyNames(this.customQueryParams)) {\n                    params = params.set(key, this.customQueryParams[key]);\n                }\n            }\n            this.http.post(this.tokenEndpoint, params, { headers }).subscribe((/**\n             * @param {?} tokenResponse\n             * @return {?}\n             */\n            (tokenResponse) => {\n                this.debug('refresh tokenResponse', tokenResponse);\n                this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in, tokenResponse.scope);\n                if (this.oidc && tokenResponse.id_token) {\n                    this.processIdToken(tokenResponse.id_token, tokenResponse.access_token).\n                        then((/**\n                     * @param {?} result\n                     * @return {?}\n                     */\n                    result => {\n                        this.storeIdToken(result);\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                        this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n                        resolve(tokenResponse);\n                    }))\n                        .catch((/**\n                     * @param {?} reason\n                     * @return {?}\n                     */\n                    reason => {\n                        this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n                        console.error('Error validating tokens');\n                        console.error(reason);\n                        reject(reason);\n                    }));\n                }\n                else {\n                    this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                    this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n                    resolve(tokenResponse);\n                }\n            }), (/**\n             * @param {?} err\n             * @return {?}\n             */\n            (err) => {\n                console.error('Error getting token', err);\n                this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n                reject(err);\n            }));\n        }));\n    }\n    /**\n     * Checks whether there are tokens in the hash fragment\n     * as a result of the implicit flow. These tokens are\n     * parsed, validated and used to sign the user in to the\n     * current client.\n     *\n     * @param {?=} options Optional options.\n     * @return {?}\n     */\n    tryLoginImplicitFlow(options = null) {\n        options = options || {};\n        /** @type {?} */\n        let parts;\n        if (options.customHashFragment) {\n            parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n        }\n        else {\n            parts = this.urlHelper.getHashFragmentParams();\n        }\n        this.debug('parsed url', parts);\n        /** @type {?} */\n        const state = parts['state'];\n        let [nonceInState, userState] = this.parseState(state);\n        this.state = userState;\n        if (parts['error']) {\n            this.debug('error trying to login');\n            this.handleLoginError(options, parts);\n            /** @type {?} */\n            const err = new OAuthErrorEvent('token_error', {}, parts);\n            this.eventsSubject.next(err);\n            return Promise.reject(err);\n        }\n        /** @type {?} */\n        const accessToken = parts['access_token'];\n        /** @type {?} */\n        const idToken = parts['id_token'];\n        /** @type {?} */\n        const sessionState = parts['session_state'];\n        /** @type {?} */\n        const grantedScopes = parts['scope'];\n        if (!this.requestAccessToken && !this.oidc) {\n            return Promise.reject('Either requestAccessToken or oidc (or both) must be true.');\n        }\n        if (this.requestAccessToken && !accessToken) {\n            return Promise.resolve(false);\n        }\n        if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n            return Promise.resolve(false);\n        }\n        if (this.oidc && !idToken) {\n            return Promise.resolve(false);\n        }\n        if (this.sessionChecksEnabled && !sessionState) {\n            this.logger.warn('session checks (Session Status Change Notification) ' +\n                'were activated in the configuration but the id_token ' +\n                'does not contain a session_state claim');\n        }\n        if (this.requestAccessToken && !options.disableOAuth2StateCheck) {\n            /** @type {?} */\n            const success = this.validateNonce(nonceInState);\n            if (!success) {\n                /** @type {?} */\n                const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n                this.eventsSubject.next(event);\n                return Promise.reject(event);\n            }\n        }\n        if (this.requestAccessToken) {\n            this.storeAccessTokenResponse(accessToken, null, parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec, grantedScopes);\n        }\n        if (!this.oidc) {\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n                location.hash = '';\n            }\n            this.callOnTokenReceivedIfExists(options);\n            return Promise.resolve(true);\n        }\n        return this.processIdToken(idToken, accessToken)\n            .then((/**\n         * @param {?} result\n         * @return {?}\n         */\n        result => {\n            if (options.validationHandler) {\n                return options\n                    .validationHandler({\n                    accessToken: accessToken,\n                    idClaims: result.idTokenClaims,\n                    idToken: result.idToken,\n                    state: state\n                })\n                    .then((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                _ => result));\n            }\n            return result;\n        }))\n            .then((/**\n         * @param {?} result\n         * @return {?}\n         */\n        result => {\n            this.storeIdToken(result);\n            this.storeSessionState(sessionState);\n            if (this.clearHashAfterLogin) {\n                location.hash = '';\n            }\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            this.callOnTokenReceivedIfExists(options);\n            this.inImplicitFlow = false;\n            return true;\n        }))\n            .catch((/**\n         * @param {?} reason\n         * @return {?}\n         */\n        reason => {\n            this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n            this.logger.error('Error validating tokens');\n            this.logger.error(reason);\n            return Promise.reject(reason);\n        }));\n    }\n    /**\n     * @private\n     * @param {?} state\n     * @return {?}\n     */\n    parseState(state) {\n        /** @type {?} */\n        let nonce = state;\n        /** @type {?} */\n        let userState = '';\n        if (state) {\n            /** @type {?} */\n            const idx = state.indexOf(this.config.nonceStateSeparator);\n            if (idx > -1) {\n                nonce = state.substr(0, idx);\n                userState = state.substr(idx + this.config.nonceStateSeparator.length);\n            }\n        }\n        return [nonce, userState];\n    }\n    /**\n     * @protected\n     * @param {?} nonceInState\n     * @return {?}\n     */\n    validateNonce(nonceInState) {\n        /** @type {?} */\n        const savedNonce = this._storage.getItem('nonce');\n        if (savedNonce !== nonceInState) {\n            /** @type {?} */\n            const err = 'Validating access_token failed, wrong state/nonce.';\n            console.error(err, savedNonce, nonceInState);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @protected\n     * @param {?} idToken\n     * @return {?}\n     */\n    storeIdToken(idToken) {\n        this._storage.setItem('id_token', idToken.idToken);\n        this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n        this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n        this._storage.setItem('id_token_stored_at', '' + Date.now());\n    }\n    /**\n     * @protected\n     * @param {?} sessionState\n     * @return {?}\n     */\n    storeSessionState(sessionState) {\n        this._storage.setItem('session_state', sessionState);\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    getSessionState() {\n        return this._storage.getItem('session_state');\n    }\n    /**\n     * @protected\n     * @param {?} options\n     * @param {?} parts\n     * @return {?}\n     */\n    handleLoginError(options, parts) {\n        if (options.onLoginError) {\n            options.onLoginError(parts);\n        }\n        if (this.clearHashAfterLogin) {\n            location.hash = '';\n        }\n    }\n    /**\n     * @ignore\n     * @param {?} idToken\n     * @param {?} accessToken\n     * @param {?=} skipNonceCheck\n     * @return {?}\n     */\n    processIdToken(idToken, accessToken, skipNonceCheck = false) {\n        /** @type {?} */\n        const tokenParts = idToken.split('.');\n        /** @type {?} */\n        const headerBase64 = this.padBase64(tokenParts[0]);\n        /** @type {?} */\n        const headerJson = b64DecodeUnicode(headerBase64);\n        /** @type {?} */\n        const header = JSON.parse(headerJson);\n        /** @type {?} */\n        const claimsBase64 = this.padBase64(tokenParts[1]);\n        /** @type {?} */\n        const claimsJson = b64DecodeUnicode(claimsBase64);\n        /** @type {?} */\n        const claims = JSON.parse(claimsJson);\n        /** @type {?} */\n        const savedNonce = this._storage.getItem('nonce');\n        if (Array.isArray(claims.aud)) {\n            if (claims.aud.every((/**\n             * @param {?} v\n             * @return {?}\n             */\n            v => v !== this.clientId))) {\n                /** @type {?} */\n                const err = 'Wrong audience: ' + claims.aud.join(',');\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n        }\n        else {\n            if (claims.aud !== this.clientId) {\n                /** @type {?} */\n                const err = 'Wrong audience: ' + claims.aud;\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n        }\n        if (!claims.sub) {\n            /** @type {?} */\n            const err = 'No sub claim in id_token';\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n        /* For now, we only check whether the sub against\n         * silentRefreshSubject when sessionChecksEnabled is on\n         * We will reconsider in a later version to do this\n         * in every other case too.\n         */\n        if (this.sessionChecksEnabled &&\n            this.silentRefreshSubject &&\n            this.silentRefreshSubject !== claims['sub']) {\n            /** @type {?} */\n            const err = 'After refreshing, we got an id_token for another user (sub). ' +\n                `Expected sub: ${this.silentRefreshSubject}, received sub: ${claims['sub']}`;\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n        if (!claims.iat) {\n            /** @type {?} */\n            const err = 'No iat claim in id_token';\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n        if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n            /** @type {?} */\n            const err = 'Wrong issuer: ' + claims.iss;\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n        if (!skipNonceCheck && claims.nonce !== savedNonce) {\n            /** @type {?} */\n            const err = 'Wrong nonce: ' + claims.nonce;\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n        if (!this.disableAtHashCheck &&\n            this.requestAccessToken &&\n            !claims['at_hash']) {\n            /** @type {?} */\n            const err = 'An at_hash is needed!';\n            this.logger.warn(err);\n            return Promise.reject(err);\n        }\n        /** @type {?} */\n        const now = Date.now();\n        /** @type {?} */\n        const issuedAtMSec = claims.iat * 1000;\n        /** @type {?} */\n        const expiresAtMSec = claims.exp * 1000;\n        /** @type {?} */\n        const clockSkewInMSec = (this.clockSkewInSec || 600) * 1000;\n        if (issuedAtMSec - clockSkewInMSec >= now ||\n            expiresAtMSec + clockSkewInMSec <= now) {\n            /** @type {?} */\n            const err = 'Token has expired';\n            console.error(err);\n            console.error({\n                now: now,\n                issuedAtMSec: issuedAtMSec,\n                expiresAtMSec: expiresAtMSec\n            });\n            return Promise.reject(err);\n        }\n        /** @type {?} */\n        const validationParams = {\n            accessToken: accessToken,\n            idToken: idToken,\n            jwks: this.jwks,\n            idTokenClaims: claims,\n            idTokenHeader: header,\n            loadKeys: (/**\n             * @return {?}\n             */\n            () => this.loadJwks())\n        };\n        return this.checkAtHash(validationParams)\n            .then((/**\n         * @param {?} atHashValid\n         * @return {?}\n         */\n        atHashValid => {\n            if (!this.disableAtHashCheck &&\n                this.requestAccessToken &&\n                !atHashValid) {\n                /** @type {?} */\n                const err = 'Wrong at_hash';\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n            return this.checkSignature(validationParams).then((/**\n             * @param {?} _\n             * @return {?}\n             */\n            _ => {\n                /** @type {?} */\n                const result = {\n                    idToken: idToken,\n                    idTokenClaims: claims,\n                    idTokenClaimsJson: claimsJson,\n                    idTokenHeader: header,\n                    idTokenHeaderJson: headerJson,\n                    idTokenExpiresAt: expiresAtMSec\n                };\n                return result;\n            }));\n        }));\n    }\n    /**\n     * Returns the received claims about the user.\n     * @return {?}\n     */\n    getIdentityClaims() {\n        /** @type {?} */\n        const claims = this._storage.getItem('id_token_claims_obj');\n        if (!claims) {\n            return null;\n        }\n        return JSON.parse(claims);\n    }\n    /**\n     * Returns the granted scopes from the server.\n     * @return {?}\n     */\n    getGrantedScopes() {\n        /** @type {?} */\n        const scopes = this._storage.getItem('granted_scopes');\n        if (!scopes) {\n            return null;\n        }\n        return JSON.parse(scopes);\n    }\n    /**\n     * Returns the current id_token.\n     * @return {?}\n     */\n    getIdToken() {\n        return this._storage\n            ? this._storage.getItem('id_token')\n            : null;\n    }\n    /**\n     * @protected\n     * @param {?} base64data\n     * @return {?}\n     */\n    padBase64(base64data) {\n        while (base64data.length % 4 !== 0) {\n            base64data += '=';\n        }\n        return base64data;\n    }\n    /**\n     * Returns the current access_token.\n     * @return {?}\n     */\n    getAccessToken() {\n        return this._storage\n            ? this._storage.getItem('access_token')\n            : null;\n    }\n    /**\n     * @return {?}\n     */\n    getRefreshToken() {\n        return this._storage\n            ? this._storage.getItem('refresh_token')\n            : null;\n    }\n    /**\n     * Returns the expiration date of the access_token\n     * as milliseconds since 1970.\n     * @return {?}\n     */\n    getAccessTokenExpiration() {\n        if (!this._storage.getItem('expires_at')) {\n            return null;\n        }\n        return parseInt(this._storage.getItem('expires_at'), 10);\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    getAccessTokenStoredAt() {\n        return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    getIdTokenStoredAt() {\n        return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n    }\n    /**\n     * Returns the expiration date of the id_token\n     * as milliseconds since 1970.\n     * @return {?}\n     */\n    getIdTokenExpiration() {\n        if (!this._storage.getItem('id_token_expires_at')) {\n            return null;\n        }\n        return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n    }\n    /**\n     * Checkes, whether there is a valid access_token.\n     * @return {?}\n     */\n    hasValidAccessToken() {\n        if (this.getAccessToken()) {\n            /** @type {?} */\n            const expiresAt = this._storage.getItem('expires_at');\n            /** @type {?} */\n            const now = new Date();\n            if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Checks whether there is a valid id_token.\n     * @return {?}\n     */\n    hasValidIdToken() {\n        if (this.getIdToken()) {\n            /** @type {?} */\n            const expiresAt = this._storage.getItem('id_token_expires_at');\n            /** @type {?} */\n            const now = new Date();\n            if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns the auth-header that can be used\n     * to transmit the access_token to a service\n     * @return {?}\n     */\n    authorizationHeader() {\n        return 'Bearer ' + this.getAccessToken();\n    }\n    /**\n     * Removes all tokens and logs the user out.\n     * If a logout url is configured, the user is\n     * redirected to it.\n     * @param {?=} noRedirectToLogoutUrl\n     * @return {?}\n     */\n    logOut(noRedirectToLogoutUrl = false) {\n        /** @type {?} */\n        const id_token = this.getIdToken();\n        this._storage.removeItem('access_token');\n        this._storage.removeItem('id_token');\n        this._storage.removeItem('refresh_token');\n        this._storage.removeItem('nonce');\n        this._storage.removeItem('expires_at');\n        this._storage.removeItem('id_token_claims_obj');\n        this._storage.removeItem('id_token_expires_at');\n        this._storage.removeItem('id_token_stored_at');\n        this._storage.removeItem('access_token_stored_at');\n        this._storage.removeItem('granted_scopes');\n        this._storage.removeItem('session_state');\n        this.silentRefreshSubject = null;\n        this.eventsSubject.next(new OAuthInfoEvent('logout'));\n        if (!this.logoutUrl) {\n            return;\n        }\n        if (noRedirectToLogoutUrl) {\n            return;\n        }\n        if (!id_token && !this.postLogoutRedirectUri) {\n            return;\n        }\n        /** @type {?} */\n        let logoutUrl;\n        if (!this.validateUrlForHttps(this.logoutUrl)) {\n            throw new Error('logoutUrl must use https, or config value for property requireHttps must allow http');\n        }\n        // For backward compatibility\n        if (this.logoutUrl.indexOf('{{') > -1) {\n            logoutUrl = this.logoutUrl\n                .replace(/\\{\\{id_token\\}\\}/, id_token)\n                .replace(/\\{\\{client_id\\}\\}/, this.clientId);\n        }\n        else {\n            /** @type {?} */\n            let params = new HttpParams();\n            if (id_token) {\n                params = params.set('id_token_hint', id_token);\n            }\n            /** @type {?} */\n            const postLogoutUrl = this.postLogoutRedirectUri || this.redirectUri;\n            if (postLogoutUrl) {\n                params = params.set('post_logout_redirect_uri', postLogoutUrl);\n            }\n            logoutUrl =\n                this.logoutUrl +\n                    (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') +\n                    params.toString();\n        }\n        this.config.openUri(logoutUrl);\n    }\n    /**\n     * @ignore\n     * @return {?}\n     */\n    createAndSaveNonce() {\n        /** @type {?} */\n        const that = this;\n        return this.createNonce().then((/**\n         * @param {?} nonce\n         * @return {?}\n         */\n        function (nonce) {\n            that._storage.setItem('nonce', nonce);\n            return nonce;\n        }));\n    }\n    /**\n     * @ignore\n     * @return {?}\n     */\n    ngOnDestroy() {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    createNonce() {\n        return new Promise((/**\n         * @param {?} resolve\n         * @return {?}\n         */\n        (resolve) => {\n            if (this.rngUrl) {\n                throw new Error('createNonce with rng-web-api has not been implemented so far');\n            }\n            /*\n                         * This alphabet uses a-z A-Z 0-9 _- symbols.\n                         * Symbols order was changed for better gzip compression.\n                         */\n            /** @type {?} */\n            const url = 'Uint8ArdomValuesObj012345679BCDEFGHIJKLMNPQRSTWXYZ_cfghkpqvwxyz-';\n            /** @type {?} */\n            let size = 45;\n            /** @type {?} */\n            let id = '';\n            /** @type {?} */\n            const crypto = self.crypto || self['msCrypto'];\n            if (crypto) {\n                /** @type {?} */\n                const bytes = crypto.getRandomValues(new Uint8Array(size));\n                while (0 < size--) {\n                    id += url[bytes[size] & 63];\n                }\n            }\n            else {\n                while (0 < size--) {\n                    id += url[Math.random() * 64 | 0];\n                }\n            }\n            resolve(id);\n        }));\n    }\n    /**\n     * @protected\n     * @param {?} params\n     * @return {?}\n     */\n    checkAtHash(params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.tokenValidationHandler) {\n                this.logger.warn('No tokenValidationHandler configured. Cannot check at_hash.');\n                return true;\n            }\n            return this.tokenValidationHandler.validateAtHash(params);\n        });\n    }\n    /**\n     * @protected\n     * @param {?} params\n     * @return {?}\n     */\n    checkSignature(params) {\n        if (!this.tokenValidationHandler) {\n            this.logger.warn('No tokenValidationHandler configured. Cannot check signature.');\n            return Promise.resolve(null);\n        }\n        return this.tokenValidationHandler.validateSignature(params);\n    }\n    /**\n     * Start the implicit flow or the code flow,\n     * depending on your configuration.\n     * @param {?=} additionalState\n     * @param {?=} params\n     * @return {?}\n     */\n    initLoginFlow(additionalState = '', params = {}) {\n        if (this.responseType === 'code') {\n            return this.initCodeFlow(additionalState, params);\n        }\n        else {\n            return this.initImplicitFlow(additionalState, params);\n        }\n    }\n    /**\n     * Starts the authorization code flow and redirects to user to\n     * the auth servers login url.\n     * @param {?=} additionalState\n     * @param {?=} params\n     * @return {?}\n     */\n    initCodeFlow(additionalState = '', params = {}) {\n        if (this.loginUrl !== '') {\n            this.initCodeFlowInternal(additionalState, params);\n        }\n        else {\n            this.events.pipe(filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            e => e.type === 'discovery_document_loaded')))\n                .subscribe((/**\n             * @param {?} _\n             * @return {?}\n             */\n            _ => this.initCodeFlowInternal(additionalState, params)));\n        }\n    }\n    /**\n     * @private\n     * @param {?=} additionalState\n     * @param {?=} params\n     * @return {?}\n     */\n    initCodeFlowInternal(additionalState = '', params = {}) {\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n            throw new Error('loginUrl must use Http. Also check property requireHttps.');\n        }\n        this.createLoginUrl(additionalState, '', null, false, params).then((/**\n         * @param {?} url\n         * @return {?}\n         */\n        function (url) {\n            location.href = url;\n        }))\n            .catch((/**\n         * @param {?} error\n         * @return {?}\n         */\n        error => {\n            console.error('Error in initAuthorizationCodeFlow');\n            console.error(error);\n        }));\n    }\n    /**\n     * @protected\n     * @return {?}\n     */\n    createChallangeVerifierPairForPKCE() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.crypto) {\n                throw new Error('PKCI support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\n            }\n            /** @type {?} */\n            const verifier = yield this.createNonce();\n            /** @type {?} */\n            const challengeRaw = yield this.crypto.calcHash(verifier, 'sha-256');\n            /** @type {?} */\n            const challange = base64UrlEncode(challengeRaw);\n            return [challange, verifier];\n        });\n    }\n}\nOAuthService.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nOAuthService.ctorParameters = () => [\n    { type: NgZone },\n    { type: HttpClient },\n    { type: OAuthStorage, decorators: [{ type: Optional }] },\n    { type: ValidationHandler, decorators: [{ type: Optional }] },\n    { type: AuthConfig, decorators: [{ type: Optional }] },\n    { type: UrlHelperService },\n    { type: OAuthLogger },\n    { type: CryptoHandler, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass OAuthModuleConfig {\n}\n/**\n * @abstract\n */\nclass OAuthResourceServerConfig {\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @abstract\n */\nclass OAuthResourceServerErrorHandler {\n}\nclass OAuthNoopResourceServerErrorHandler {\n    /**\n     * @param {?} err\n     * @return {?}\n     */\n    handleError(err) {\n        return throwError(err);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DefaultOAuthInterceptor {\n    /**\n     * @param {?} authStorage\n     * @param {?} oAuthService\n     * @param {?} errorHandler\n     * @param {?} moduleConfig\n     */\n    constructor(authStorage, oAuthService, errorHandler, moduleConfig) {\n        this.authStorage = authStorage;\n        this.oAuthService = oAuthService;\n        this.errorHandler = errorHandler;\n        this.moduleConfig = moduleConfig;\n    }\n    /**\n     * @private\n     * @param {?} url\n     * @return {?}\n     */\n    checkUrl(url) {\n        if (this.moduleConfig.resourceServer.customUrlValidation) {\n            return this.moduleConfig.resourceServer.customUrlValidation(url);\n        }\n        if (this.moduleConfig.resourceServer.allowedUrls) {\n            return !!this.moduleConfig.resourceServer.allowedUrls.find((/**\n             * @param {?} u\n             * @return {?}\n             */\n            u => url.startsWith(u)));\n        }\n        return true;\n    }\n    /**\n     * @param {?} req\n     * @param {?} next\n     * @return {?}\n     */\n    intercept(req, next) {\n        /** @type {?} */\n        const url = req.url.toLowerCase();\n        if (!this.moduleConfig) {\n            return next.handle(req);\n        }\n        if (!this.moduleConfig.resourceServer) {\n            return next.handle(req);\n        }\n        if (this.moduleConfig.resourceServer.allowedUrls && !this.checkUrl(url)) {\n            return next.handle(req);\n        }\n        /** @type {?} */\n        const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n        if (!sendAccessToken) {\n            return next\n                .handle(req)\n                .pipe(catchError((/**\n             * @param {?} err\n             * @return {?}\n             */\n            err => this.errorHandler.handleError(err))));\n        }\n        return merge(of(this.oAuthService.getAccessToken()).pipe(filter((/**\n         * @param {?} token\n         * @return {?}\n         */\n        token => token ? true : false))), this.oAuthService.events.pipe(filter((/**\n         * @param {?} e\n         * @return {?}\n         */\n        e => e.type === 'token_received')), timeout(this.oAuthService.waitForTokenInMsec || 0), catchError((/**\n         * @param {?} _\n         * @return {?}\n         */\n        _ => of(null))), // timeout is not an error\n        map((/**\n         * @param {?} _\n         * @return {?}\n         */\n        _ => this.oAuthService.getAccessToken())))).pipe(take(1), mergeMap((/**\n         * @param {?} token\n         * @return {?}\n         */\n        token => {\n            if (token) {\n                /** @type {?} */\n                const header = 'Bearer ' + token;\n                /** @type {?} */\n                const headers = req.headers.set('Authorization', header);\n                req = req.clone({ headers });\n            }\n            return next\n                .handle(req)\n                .pipe(catchError((/**\n             * @param {?} err\n             * @return {?}\n             */\n            err => this.errorHandler.handleError(err))));\n        })));\n    }\n}\nDefaultOAuthInterceptor.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nDefaultOAuthInterceptor.ctorParameters = () => [\n    { type: OAuthStorage },\n    { type: OAuthService },\n    { type: OAuthResourceServerErrorHandler },\n    { type: OAuthModuleConfig, decorators: [{ type: Optional }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * A validation handler that isn't validating nothing.\n * Can be used to skip validation (at your own risk).\n */\nclass NullValidationHandler {\n    /**\n     * @param {?} validationParams\n     * @return {?}\n     */\n    validateSignature(validationParams) {\n        return Promise.resolve(null);\n    }\n    /**\n     * @param {?} validationParams\n     * @return {?}\n     */\n    validateAtHash(validationParams) {\n        return Promise.resolve(true);\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @return {?}\n */\nfunction createDefaultLogger() {\n    return console;\n}\n/**\n * @return {?}\n */\nfunction createDefaultStorage() {\n    return typeof sessionStorage !== 'undefined' ? sessionStorage : null;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Validates the signature of an id_token against one\n * of the keys of an JSON Web Key Set (jwks).\n *\n * This jwks can be provided by the discovery document.\n */\nclass JwksValidationHandler extends AbstractValidationHandler {\n    constructor() {\n        super(...arguments);\n        /**\n         * Allowed algorithms\n         */\n        this.allowedAlgorithms = [\n            'HS256',\n            'HS384',\n            'HS512',\n            'RS256',\n            'RS384',\n            'RS512',\n            'ES256',\n            'ES384',\n            'PS256',\n            'PS384',\n            'PS512'\n        ];\n        /**\n         * Time period in seconds the timestamp in the signature can\n         * differ from the current time.\n         */\n        this.gracePeriodInSec = 600;\n    }\n    /**\n     * @param {?} params\n     * @param {?=} retry\n     * @return {?}\n     */\n    validateSignature(params, retry = false) {\n        if (!params.idToken)\n            throw new Error('Parameter idToken expected!');\n        if (!params.idTokenHeader)\n            throw new Error('Parameter idTokenHandler expected.');\n        if (!params.jwks)\n            throw new Error('Parameter jwks expected!');\n        if (!params.jwks['keys'] ||\n            !Array.isArray(params.jwks['keys']) ||\n            params.jwks['keys'].length === 0) {\n            throw new Error('Array keys in jwks missing!');\n        }\n        // console.debug('validateSignature: retry', retry);\n        /** @type {?} */\n        let kid = params.idTokenHeader['kid'];\n        /** @type {?} */\n        let keys = params.jwks['keys'];\n        /** @type {?} */\n        let key;\n        /** @type {?} */\n        let alg = params.idTokenHeader['alg'];\n        if (kid) {\n            key = keys.find((/**\n             * @param {?} k\n             * @return {?}\n             */\n            k => k['kid'] === kid /* && k['use'] === 'sig' */));\n        }\n        else {\n            /** @type {?} */\n            let kty = this.alg2kty(alg);\n            /** @type {?} */\n            let matchingKeys = keys.filter((/**\n             * @param {?} k\n             * @return {?}\n             */\n            k => k['kty'] === kty && k['use'] === 'sig'));\n            /*\n                  if (matchingKeys.length == 0) {\n                      let error = 'No matching key found.';\n                      console.error(error);\n                      return Promise.reject(error);\n                  }*/\n            if (matchingKeys.length > 1) {\n                /** @type {?} */\n                let error = 'More than one matching key found. Please specify a kid in the id_token header.';\n                console.error(error);\n                return Promise.reject(error);\n            }\n            else if (matchingKeys.length === 1) {\n                key = matchingKeys[0];\n            }\n        }\n        if (!key && !retry && params.loadKeys) {\n            return params\n                .loadKeys()\n                .then((/**\n             * @param {?} loadedKeys\n             * @return {?}\n             */\n            loadedKeys => (params.jwks = loadedKeys)))\n                .then((/**\n             * @param {?} _\n             * @return {?}\n             */\n            _ => this.validateSignature(params, true)));\n        }\n        if (!key && retry && !kid) {\n            /** @type {?} */\n            let error = 'No matching key found.';\n            console.error(error);\n            return Promise.reject(error);\n        }\n        if (!key && retry && kid) {\n            /** @type {?} */\n            let error = 'expected key not found in property jwks. ' +\n                'This property is most likely loaded with the ' +\n                'discovery document. ' +\n                'Expected key id (kid): ' +\n                kid;\n            console.error(error);\n            return Promise.reject(error);\n        }\n        /** @type {?} */\n        let keyObj = KEYUTIL.getKey(key);\n        /** @type {?} */\n        let validationOptions = {\n            alg: this.allowedAlgorithms,\n            gracePeriod: this.gracePeriodInSec\n        };\n        /** @type {?} */\n        let isValid = KJUR.jws.JWS.verifyJWT(params.idToken, keyObj, validationOptions);\n        if (isValid) {\n            return Promise.resolve();\n        }\n        else {\n            return Promise.reject('Signature not valid');\n        }\n    }\n    /**\n     * @private\n     * @param {?} alg\n     * @return {?}\n     */\n    alg2kty(alg) {\n        switch (alg.charAt(0)) {\n            case 'R':\n                return 'RSA';\n            case 'E':\n                return 'EC';\n            default:\n                throw new Error('Cannot infer kty from alg: ' + alg);\n        }\n    }\n    /**\n     * @param {?} valueToHash\n     * @param {?} algorithm\n     * @return {?}\n     */\n    calcHash(valueToHash, algorithm) {\n        /** @type {?} */\n        let hashAlg = new KJUR.crypto.MessageDigest({ alg: algorithm });\n        /** @type {?} */\n        let result = hashAlg.digestString(valueToHash);\n        /** @type {?} */\n        let byteArrayAsString = this.toByteArrayAsString(result);\n        return Promise.resolve(byteArrayAsString);\n    }\n    /**\n     * @param {?} hexString\n     * @return {?}\n     */\n    toByteArrayAsString(hexString) {\n        /** @type {?} */\n        let result = '';\n        for (let i = 0; i < hexString.length; i += 2) {\n            /** @type {?} */\n            let hexDigit = hexString.charAt(i) + hexString.charAt(i + 1);\n            /** @type {?} */\n            let num = parseInt(hexDigit, 16);\n            result += String.fromCharCode(num);\n        }\n        return result;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass OAuthModule {\n    /**\n     * @param {?=} config\n     * @param {?=} validationHandlerClass\n     * @return {?}\n     */\n    static forRoot(config = null, validationHandlerClass = NullValidationHandler) {\n        return {\n            ngModule: OAuthModule,\n            providers: [\n                OAuthService,\n                UrlHelperService,\n                { provide: OAuthLogger, useFactory: createDefaultLogger },\n                { provide: OAuthStorage, useFactory: createDefaultStorage },\n                { provide: ValidationHandler, useClass: validationHandlerClass },\n                { provide: CryptoHandler, useClass: JwksValidationHandler },\n                {\n                    provide: OAuthResourceServerErrorHandler,\n                    useClass: OAuthNoopResourceServerErrorHandler\n                },\n                { provide: OAuthModuleConfig, useValue: config },\n                {\n                    provide: HTTP_INTERCEPTORS,\n                    useClass: DefaultOAuthInterceptor,\n                    multi: true\n                }\n            ]\n        };\n    }\n}\nOAuthModule.decorators = [\n    { type: NgModule, args: [{\n                imports: [CommonModule],\n                declarations: [],\n                exports: []\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst AUTH_CONFIG = new InjectionToken('AUTH_CONFIG');\n\nexport { AUTH_CONFIG, AbstractValidationHandler, AuthConfig, DefaultOAuthInterceptor, JwksValidationHandler, LoginOptions, NullValidationHandler, OAuthErrorEvent, OAuthEvent, OAuthInfoEvent, OAuthLogger, OAuthModule, OAuthModuleConfig, OAuthNoopResourceServerErrorHandler, OAuthResourceServerConfig, OAuthResourceServerErrorHandler, OAuthService, OAuthStorage, OAuthSuccessEvent, ReceivedTokens, UrlHelperService, ValidationHandler, CryptoHandler as ɵa, createDefaultLogger as ɵb, createDefaultStorage as ɵc };\n"]}
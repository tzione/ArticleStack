{"version":3,"sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/angular-oauth2-oidc/bundles/angular-oauth2-oidc.umd.js"],"names":[],"mappings":"AAAA;+RAC2O;8NAC/C;;uFAEnH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAoY/D;;;;yFAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAy6GA,AAGA;;;;;;;;;;;;;;;;;;;;;;;o1EAWG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAwKH,AAGA;;;;;;;;;;;;;8HAOG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA8TH;;;;;;;;;;;yKAOA","file":"angular-oauth2-oidc.umd.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/common/http'), require('rxjs'), require('rxjs/operators'), require('jsrsasign')) :\n    typeof define === 'function' && define.amd ? define('angular-oauth2-oidc', ['exports', '@angular/core', '@angular/common', '@angular/common/http', 'rxjs', 'rxjs/operators', 'jsrsasign'], factory) :\n    (global = global || self, factory(global['angular-oauth2-oidc'] = {}, global.ng.core, global.ng.common, global.ng.common.http, global.rxjs, global.rxjs.operators, global.jsrsasign));\n}(this, function (exports, core, common, http, rxjs, operators, jsrsasign) { 'use strict';\n\n    /*! *****************************************************************************\n    Copyright (c) Microsoft Corporation. All rights reserved.\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n    this file except in compliance with the License. You may obtain a copy of the\n    License at http://www.apache.org/licenses/LICENSE-2.0\n\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n    MERCHANTABLITY OR NON-INFRINGEMENT.\n\n    See the Apache Version 2.0 License for specific language governing permissions\n    and limitations under the License.\n    ***************************************************************************** */\n    /* global Reflect, Promise */\n\n    var extendStatics = function(d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n\n    function __extends(d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }\n\n    function __awaiter(thisArg, _arguments, P, generator) {\n        return new (P || (P = Promise))(function (resolve, reject) {\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\n        });\n    }\n\n    function __generator(thisArg, body) {\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n        function verb(n) { return function (v) { return step([n, v]); }; }\n        function step(op) {\n            if (f) throw new TypeError(\"Generator is already executing.\");\n            while (_) try {\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                if (y = 0, t) op = [op[0] & 2, t.value];\n                switch (op[0]) {\n                    case 0: case 1: t = op; break;\n                    case 4: _.label++; return { value: op[1], done: false };\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                    default:\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                        if (t[2]) _.ops.pop();\n                        _.trys.pop(); continue;\n                }\n                op = body.call(thisArg, _);\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n        }\n    }\n\n    function __values(o) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\n        if (m) return m.call(o);\n        return {\n            next: function () {\n                if (o && i >= o.length) o = void 0;\n                return { value: o && o[i++], done: !o };\n            }\n        };\n    }\n\n    function __read(o, n) {\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n        if (!m) return o;\n        var i = m.call(o), r, ar = [], e;\n        try {\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n        }\n        catch (error) { e = { error: error }; }\n        finally {\n            try {\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\n            }\n            finally { if (e) throw e.error; }\n        }\n        return ar;\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * Additional options that can be passt to tryLogin.\n     */\n    var   /**\n     * Additional options that can be passt to tryLogin.\n     */\n    LoginOptions = /** @class */ (function () {\n        function LoginOptions() {\n            /**\n             * Normally, you want to clear your hash fragment after\n             * the lib read the token(s) so that they are not displayed\n             * anymore in the url. If not, set this to true.\n             */\n            this.preventClearHashAfterLogin = false;\n        }\n        return LoginOptions;\n    }());\n    /**\n     * Defines the logging interface the OAuthService uses\n     * internally. Is compatible with the `console` object,\n     * but you can provide your own implementation as well\n     * through dependency injection.\n     * @abstract\n     */\n    var   /**\n     * Defines the logging interface the OAuthService uses\n     * internally. Is compatible with the `console` object,\n     * but you can provide your own implementation as well\n     * through dependency injection.\n     * @abstract\n     */\n    OAuthLogger = /** @class */ (function () {\n        function OAuthLogger() {\n        }\n        return OAuthLogger;\n    }());\n    /**\n     * Defines a simple storage that can be used for\n     * storing the tokens at client side.\n     * Is compatible to localStorage and sessionStorage,\n     * but you can also create your own implementations.\n     * @abstract\n     */\n    var   /**\n     * Defines a simple storage that can be used for\n     * storing the tokens at client side.\n     * Is compatible to localStorage and sessionStorage,\n     * but you can also create your own implementations.\n     * @abstract\n     */\n    OAuthStorage = /** @class */ (function () {\n        function OAuthStorage() {\n        }\n        return OAuthStorage;\n    }());\n    /**\n     * Represents the received tokens, the received state\n     * and the parsed claims from the id-token.\n     */\n    var   /**\n     * Represents the received tokens, the received state\n     * and the parsed claims from the id-token.\n     */\n    ReceivedTokens = /** @class */ (function () {\n        function ReceivedTokens() {\n        }\n        return ReceivedTokens;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    // see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    function b64DecodeUnicode(str) {\n        /** @type {?} */\n        var base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n        return decodeURIComponent(atob(base64)\n            .split('')\n            .map((/**\n         * @param {?} c\n         * @return {?}\n         */\n        function (c) {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        }))\n            .join(''));\n    }\n    /**\n     * @param {?} str\n     * @return {?}\n     */\n    function base64UrlEncode(str) {\n        /** @type {?} */\n        var base64 = btoa(str);\n        return base64\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=/g, '');\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * Interface for Handlers that are hooked in to\n     * validate tokens.\n     * @abstract\n     */\n    var   /**\n     * Interface for Handlers that are hooked in to\n     * validate tokens.\n     * @abstract\n     */\n    ValidationHandler = /** @class */ (function () {\n        function ValidationHandler() {\n        }\n        return ValidationHandler;\n    }());\n    /**\n     * This abstract implementation of ValidationHandler already implements\n     * the method validateAtHash. However, to make use of it,\n     * you have to override the method calcHash.\n     * @abstract\n     */\n    var   /**\n     * This abstract implementation of ValidationHandler already implements\n     * the method validateAtHash. However, to make use of it,\n     * you have to override the method calcHash.\n     * @abstract\n     */\n    AbstractValidationHandler = /** @class */ (function () {\n        function AbstractValidationHandler() {\n        }\n        /**\n         * Validates the at_hash in an id_token against the received access_token.\n         */\n        /**\n         * Validates the at_hash in an id_token against the received access_token.\n         * @param {?} params\n         * @return {?}\n         */\n        AbstractValidationHandler.prototype.validateAtHash = /**\n         * Validates the at_hash in an id_token against the received access_token.\n         * @param {?} params\n         * @return {?}\n         */\n        function (params) {\n            return __awaiter(this, void 0, void 0, function () {\n                var hashAlg, tokenHash, leftMostHalf, atHash, claimsAtHash;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\n                            return [4 /*yield*/, this.calcHash(params.accessToken, hashAlg)];\n                        case 1:\n                            tokenHash = _a.sent();\n                            // sha256(accessToken, { asString: true });\n                            leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n                            atHash = base64UrlEncode(leftMostHalf);\n                            claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n                            if (atHash !== claimsAtHash) {\n                                console.error('exptected at_hash: ' + atHash);\n                                console.error('actual at_hash: ' + claimsAtHash);\n                            }\n                            return [2 /*return*/, atHash === claimsAtHash];\n                    }\n                });\n            });\n        };\n        /**\n         * Infers the name of the hash algorithm to use\n         * from the alg field of an id_token.\n         *\n         * @param jwtHeader the id_token's parsed header\n         */\n        /**\n         * Infers the name of the hash algorithm to use\n         * from the alg field of an id_token.\n         *\n         * @protected\n         * @param {?} jwtHeader the id_token's parsed header\n         * @return {?}\n         */\n        AbstractValidationHandler.prototype.inferHashAlgorithm = /**\n         * Infers the name of the hash algorithm to use\n         * from the alg field of an id_token.\n         *\n         * @protected\n         * @param {?} jwtHeader the id_token's parsed header\n         * @return {?}\n         */\n        function (jwtHeader) {\n            /** @type {?} */\n            var alg = jwtHeader['alg'];\n            if (!alg.match(/^.S[0-9]{3}$/)) {\n                throw new Error('Algorithm not supported: ' + alg);\n            }\n            return 'sha-' + alg.substr(2);\n        };\n        return AbstractValidationHandler;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var UrlHelperService = /** @class */ (function () {\n        function UrlHelperService() {\n        }\n        /**\n         * @param {?=} customHashFragment\n         * @return {?}\n         */\n        UrlHelperService.prototype.getHashFragmentParams = /**\n         * @param {?=} customHashFragment\n         * @return {?}\n         */\n        function (customHashFragment) {\n            /** @type {?} */\n            var hash = customHashFragment || window.location.hash;\n            hash = decodeURIComponent(hash);\n            if (hash.indexOf('#') !== 0) {\n                return {};\n            }\n            /** @type {?} */\n            var questionMarkPosition = hash.indexOf('?');\n            if (questionMarkPosition > -1) {\n                hash = hash.substr(questionMarkPosition + 1);\n            }\n            else {\n                hash = hash.substr(1);\n            }\n            return this.parseQueryString(hash);\n        };\n        /**\n         * @param {?} queryString\n         * @return {?}\n         */\n        UrlHelperService.prototype.parseQueryString = /**\n         * @param {?} queryString\n         * @return {?}\n         */\n        function (queryString) {\n            /** @type {?} */\n            var data = {};\n            /** @type {?} */\n            var pairs;\n            /** @type {?} */\n            var pair;\n            /** @type {?} */\n            var separatorIndex;\n            /** @type {?} */\n            var escapedKey;\n            /** @type {?} */\n            var escapedValue;\n            /** @type {?} */\n            var key;\n            /** @type {?} */\n            var value;\n            if (queryString === null) {\n                return data;\n            }\n            pairs = queryString.split('&');\n            for (var i = 0; i < pairs.length; i++) {\n                pair = pairs[i];\n                separatorIndex = pair.indexOf('=');\n                if (separatorIndex === -1) {\n                    escapedKey = pair;\n                    escapedValue = null;\n                }\n                else {\n                    escapedKey = pair.substr(0, separatorIndex);\n                    escapedValue = pair.substr(separatorIndex + 1);\n                }\n                key = decodeURIComponent(escapedKey);\n                value = decodeURIComponent(escapedValue);\n                if (key.substr(0, 1) === '/') {\n                    key = key.substr(1);\n                }\n                data[key] = value;\n            }\n            return data;\n        };\n        UrlHelperService.decorators = [\n            { type: core.Injectable }\n        ];\n        return UrlHelperService;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var   /**\n     * @abstract\n     */\n    OAuthEvent = /** @class */ (function () {\n        function OAuthEvent(type) {\n            this.type = type;\n        }\n        return OAuthEvent;\n    }());\n    var OAuthSuccessEvent = /** @class */ (function (_super) {\n        __extends(OAuthSuccessEvent, _super);\n        function OAuthSuccessEvent(type, info) {\n            if (info === void 0) { info = null; }\n            var _this = _super.call(this, type) || this;\n            _this.info = info;\n            return _this;\n        }\n        return OAuthSuccessEvent;\n    }(OAuthEvent));\n    var OAuthInfoEvent = /** @class */ (function (_super) {\n        __extends(OAuthInfoEvent, _super);\n        function OAuthInfoEvent(type, info) {\n            if (info === void 0) { info = null; }\n            var _this = _super.call(this, type) || this;\n            _this.info = info;\n            return _this;\n        }\n        return OAuthInfoEvent;\n    }(OAuthEvent));\n    var OAuthErrorEvent = /** @class */ (function (_super) {\n        __extends(OAuthErrorEvent, _super);\n        function OAuthErrorEvent(type, reason, params) {\n            if (params === void 0) { params = null; }\n            var _this = _super.call(this, type) || this;\n            _this.reason = reason;\n            _this.params = params;\n            return _this;\n        }\n        return OAuthErrorEvent;\n    }(OAuthEvent));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var AuthConfig = /** @class */ (function () {\n        function AuthConfig(json) {\n            /**\n             * The client's id as registered with the auth server\n             */\n            this.clientId = '';\n            /**\n             * The client's redirectUri as registered with the auth server\n             */\n            this.redirectUri = '';\n            /**\n             * An optional second redirectUri where the auth server\n             * redirects the user to after logging out.\n             */\n            this.postLogoutRedirectUri = '';\n            /**\n             * The auth server's endpoint that allows to log\n             * the user in when using implicit flow.\n             */\n            this.loginUrl = '';\n            /**\n             * The requested scopes\n             */\n            this.scope = 'openid profile';\n            this.resource = '';\n            this.rngUrl = '';\n            /**\n             * Defines whether to use OpenId Connect during\n             * implicit flow.\n             */\n            this.oidc = true;\n            /**\n             * Defines whether to request an access token during\n             * implicit flow.\n             */\n            this.requestAccessToken = true;\n            this.options = null;\n            /**\n             * The issuer's uri.\n             */\n            this.issuer = '';\n            /**\n             * The logout url.\n             */\n            this.logoutUrl = '';\n            /**\n             * Defines whether to clear the hash fragment after logging in.\n             */\n            this.clearHashAfterLogin = true;\n            /**\n             * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\n             */\n            this.tokenEndpoint = null;\n            /**\n             * Url of the userinfo endpoint as defined by OpenId Connect.\n             */\n            this.userinfoEndpoint = null;\n            this.responseType = '';\n            /**\n             * Defines whether additional debug information should\n             * be shown at the console. Note that in certain browsers\n             * the verbosity of the console needs to be explicitly set\n             * to include Debug level messages.\n             */\n            this.showDebugInformation = false;\n            /**\n             * The redirect uri used when doing silent refresh.\n             */\n            this.silentRefreshRedirectUri = '';\n            this.silentRefreshMessagePrefix = '';\n            /**\n             * Set this to true to display the iframe used for\n             * silent refresh for debugging.\n             */\n            this.silentRefreshShowIFrame = false;\n            /**\n             * Timeout for silent refresh.\n             * \\@internal\n             * depreacted b/c of typo, see silentRefreshTimeout\n             */\n            this.siletRefreshTimeout = 1000 * 20;\n            /**\n             * Timeout for silent refresh.\n             */\n            this.silentRefreshTimeout = 1000 * 20;\n            /**\n             * Some auth servers don't allow using password flow\n             * w/o a client secret while the standards do not\n             * demand for it. In this case, you can set a password\n             * here. As this password is exposed to the public\n             * it does not bring additional security and is therefore\n             * as good as using no password.\n             */\n            this.dummyClientSecret = null;\n            /**\n             * Defines whether https is required.\n             * The default value is remoteOnly which only allows\n             * http for localhost, while every other domains need\n             * to be used with https.\n             */\n            this.requireHttps = 'remoteOnly';\n            /**\n             * Defines whether every url provided by the discovery\n             * document has to start with the issuer's url.\n             */\n            this.strictDiscoveryDocumentValidation = true;\n            /**\n             * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\n             * with keys used to validate received id_tokens.\n             * This is taken out of the disovery document. Can be set manually too.\n             */\n            this.jwks = null;\n            /**\n             * Map with additional query parameter that are appended to\n             * the request when initializing implicit flow.\n             */\n            this.customQueryParams = null;\n            this.silentRefreshIFrameName = 'angular-oauth-oidc-silent-refresh-iframe';\n            /**\n             * Defines when the token_timeout event should be raised.\n             * If you set this to the default value 0.75, the event\n             * is triggered after 75% of the token's life time.\n             */\n            this.timeoutFactor = 0.75;\n            /**\n             * If true, the lib will try to check whether the user\n             * is still logged in on a regular basis as described\n             * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n             */\n            this.sessionChecksEnabled = false;\n            /**\n             * Interval in msec for checking the session\n             * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\n             */\n            this.sessionCheckIntervall = 3 * 1000;\n            /**\n             * Url for the iframe used for session checks\n             */\n            this.sessionCheckIFrameUrl = null;\n            /**\n             * Name of the iframe to use for session checks\n             */\n            this.sessionCheckIFrameName = 'angular-oauth-oidc-check-session-iframe';\n            /**\n             * This property has been introduced to disable at_hash checks\n             * and is indented for Identity Provider that does not deliver\n             * an at_hash EVEN THOUGH its recommended by the OIDC specs.\n             * Of course, when disabling these checks the we are bypassing\n             * a security check which means we are more vulnerable.\n             */\n            this.disableAtHashCheck = false;\n            /**\n             * Defines wether to check the subject of a refreshed token after silent refresh.\n             * Normally, it should be the same as before.\n             */\n            this.skipSubjectCheck = false;\n            this.useIdTokenHintForSilentRefresh = false;\n            /**\n             * Defined whether to skip the validation of the issuer in the discovery document.\n             * Normally, the discovey document's url starts with the url of the issuer.\n             */\n            this.skipIssuerCheck = false;\n            /**\n             * final state sent to issuer is built as follows:\n             * state = nonce + nonceStateSeparator + additional state\n             * Default separator is ';' (encoded %3B).\n             * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\n             */\n            this.nonceStateSeparator = ';';\n            /**\n             * Set this to true to use HTTP BASIC auth for password flow\n             */\n            this.useHttpBasicAuth = false;\n            /**\n             * The interceptors waits this time span if there is no token\n             */\n            this.waitForTokenInMsec = 0;\n            /**\n             * Code Flow is by defauld used together with PKCI which is also higly recommented.\n             * You can disbale it here by setting this flag to true.\n             * https://tools.ietf.org/html/rfc7636#section-1.1\n             */\n            this.disablePKCE = false;\n            /**\n             * This property allows you to override the method that is used to open the login url,\n             * allowing a way for implementations to specify their own method of routing to new\n             * urls.\n             */\n            this.openUri = (/**\n             * @param {?} uri\n             * @return {?}\n             */\n            function (uri) {\n                location.href = uri;\n            });\n            if (json) {\n                Object.assign(this, json);\n            }\n        }\n        return AuthConfig;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * This custom encoder allows charactes like +, % and / to be used in passwords\n     */\n    var /**\n     * This custom encoder allows charactes like +, % and / to be used in passwords\n     */\n    WebHttpUrlEncodingCodec = /** @class */ (function () {\n        function WebHttpUrlEncodingCodec() {\n        }\n        /**\n         * @param {?} k\n         * @return {?}\n         */\n        WebHttpUrlEncodingCodec.prototype.encodeKey = /**\n         * @param {?} k\n         * @return {?}\n         */\n        function (k) {\n            return encodeURIComponent(k);\n        };\n        /**\n         * @param {?} v\n         * @return {?}\n         */\n        WebHttpUrlEncodingCodec.prototype.encodeValue = /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            return encodeURIComponent(v);\n        };\n        /**\n         * @param {?} k\n         * @return {?}\n         */\n        WebHttpUrlEncodingCodec.prototype.decodeKey = /**\n         * @param {?} k\n         * @return {?}\n         */\n        function (k) {\n            return decodeURIComponent(k);\n        };\n        /**\n         * @param {?} v\n         * @return {?}\n         */\n        WebHttpUrlEncodingCodec.prototype.decodeValue = /**\n         * @param {?} v\n         * @return {?}\n         */\n        function (v) {\n            return decodeURIComponent(v);\n        };\n        return WebHttpUrlEncodingCodec;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * Abstraction for crypto algorithms\n     * @abstract\n     */\n    var   /**\n     * Abstraction for crypto algorithms\n     * @abstract\n     */\n    CryptoHandler = /** @class */ (function () {\n        function CryptoHandler() {\n        }\n        return CryptoHandler;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * Service for logging in and logging out with\n     * OIDC and OAuth2. Supports implicit flow and\n     * password flow.\n     */\n    var OAuthService = /** @class */ (function (_super) {\n        __extends(OAuthService, _super);\n        function OAuthService(ngZone, http, storage, tokenValidationHandler, config, urlHelper, logger, crypto) {\n            var _this = _super.call(this) || this;\n            _this.ngZone = ngZone;\n            _this.http = http;\n            _this.config = config;\n            _this.urlHelper = urlHelper;\n            _this.logger = logger;\n            _this.crypto = crypto;\n            /**\n             * \\@internal\n             * Deprecated:  use property events instead\n             */\n            _this.discoveryDocumentLoaded = false;\n            /**\n             * The received (passed around) state, when logging\n             * in with implicit flow.\n             */\n            _this.state = '';\n            _this.eventsSubject = new rxjs.Subject();\n            _this.discoveryDocumentLoadedSubject = new rxjs.Subject();\n            _this.grantTypesSupported = [];\n            _this.inImplicitFlow = false;\n            _this.debug('angular-oauth2-oidc v8-beta');\n            _this.discoveryDocumentLoaded$ = _this.discoveryDocumentLoadedSubject.asObservable();\n            _this.events = _this.eventsSubject.asObservable();\n            if (tokenValidationHandler) {\n                _this.tokenValidationHandler = tokenValidationHandler;\n            }\n            if (config) {\n                _this.configure(config);\n            }\n            try {\n                if (storage) {\n                    _this.setStorage(storage);\n                }\n                else if (typeof sessionStorage !== 'undefined') {\n                    _this.setStorage(sessionStorage);\n                }\n            }\n            catch (e) {\n                console.error('No OAuthStorage provided and cannot access default (sessionStorage).'\n                    + 'Consider providing a custom OAuthStorage implementation in your module.', e);\n            }\n            _this.setupRefreshTimer();\n            return _this;\n        }\n        /**\n         * Use this method to configure the service\n         * @param config the configuration\n         */\n        /**\n         * Use this method to configure the service\n         * @param {?} config the configuration\n         * @return {?}\n         */\n        OAuthService.prototype.configure = /**\n         * Use this method to configure the service\n         * @param {?} config the configuration\n         * @return {?}\n         */\n        function (config) {\n            // For the sake of downward compatibility with\n            // original configuration API\n            Object.assign(this, new AuthConfig(), config);\n            this.config = Object.assign((/** @type {?} */ ({})), new AuthConfig(), config);\n            if (this.sessionChecksEnabled) {\n                this.setupSessionCheck();\n            }\n            this.configChanged();\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.configChanged = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            this.setupRefreshTimer();\n        };\n        /**\n         * @return {?}\n         */\n        OAuthService.prototype.restartSessionChecksIfStillLoggedIn = /**\n         * @return {?}\n         */\n        function () {\n            if (this.hasValidIdToken()) {\n                this.initSessionCheck();\n            }\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.restartRefreshTimerIfStillLoggedIn = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            this.setupExpirationTimers();\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.setupSessionCheck = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            this.events.pipe(operators.filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) { return e.type === 'token_received'; }))).subscribe((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                _this.initSessionCheck();\n            }));\n        };\n        /**\n         * Will setup up silent refreshing for when the token is\n         * about to expire. When the user is logged out via this.logOut method, the\n         * silent refreshing will pause and not refresh the tokens until the user is\n         * logged back in via receiving a new token.\n         * @param params Additional parameter to pass\n         * @param listenTo Setup automatic refresh of a specific token type\n         */\n        /**\n         * Will setup up silent refreshing for when the token is\n         * about to expire. When the user is logged out via this.logOut method, the\n         * silent refreshing will pause and not refresh the tokens until the user is\n         * logged back in via receiving a new token.\n         * @param {?=} params Additional parameter to pass\n         * @param {?=} listenTo Setup automatic refresh of a specific token type\n         * @param {?=} noPrompt\n         * @return {?}\n         */\n        OAuthService.prototype.setupAutomaticSilentRefresh = /**\n         * Will setup up silent refreshing for when the token is\n         * about to expire. When the user is logged out via this.logOut method, the\n         * silent refreshing will pause and not refresh the tokens until the user is\n         * logged back in via receiving a new token.\n         * @param {?=} params Additional parameter to pass\n         * @param {?=} listenTo Setup automatic refresh of a specific token type\n         * @param {?=} noPrompt\n         * @return {?}\n         */\n        function (params, listenTo, noPrompt) {\n            var _this = this;\n            if (params === void 0) { params = {}; }\n            if (noPrompt === void 0) { noPrompt = true; }\n            /** @type {?} */\n            var shouldRunSilentRefresh = true;\n            this.events.pipe(operators.tap((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                if (e.type === 'token_received') {\n                    shouldRunSilentRefresh = true;\n                }\n                else if (e.type === 'logout') {\n                    shouldRunSilentRefresh = false;\n                }\n            })), operators.filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) { return e.type === 'token_expires'; }))).subscribe((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                /** @type {?} */\n                var event = (/** @type {?} */ (e));\n                if ((listenTo == null || listenTo === 'any' || event.info === listenTo) && shouldRunSilentRefresh) {\n                    // this.silentRefresh(params, noPrompt).catch(_ => {\n                    _this.refreshInternal(params, noPrompt).catch((/**\n                     * @param {?} _\n                     * @return {?}\n                     */\n                    function (_) {\n                        _this.debug('Automatic silent refresh did not work');\n                    }));\n                }\n            }));\n            this.restartRefreshTimerIfStillLoggedIn();\n        };\n        /**\n         * @protected\n         * @param {?} params\n         * @param {?} noPrompt\n         * @return {?}\n         */\n        OAuthService.prototype.refreshInternal = /**\n         * @protected\n         * @param {?} params\n         * @param {?} noPrompt\n         * @return {?}\n         */\n        function (params, noPrompt) {\n            if (this.responseType === 'code') {\n                return this.refreshToken();\n            }\n            else {\n                return this.silentRefresh(params, noPrompt);\n            }\n        };\n        /**\n         * Convenience method that first calls `loadDiscoveryDocument(...)` and\n         * directly chains using the `then(...)` part of the promise to call\n         * the `tryLogin(...)` method.\n         *\n         * @param options LoginOptions to pass through to `tryLogin(...)`\n         */\n        /**\n         * Convenience method that first calls `loadDiscoveryDocument(...)` and\n         * directly chains using the `then(...)` part of the promise to call\n         * the `tryLogin(...)` method.\n         *\n         * @param {?=} options LoginOptions to pass through to `tryLogin(...)`\n         * @return {?}\n         */\n        OAuthService.prototype.loadDiscoveryDocumentAndTryLogin = /**\n         * Convenience method that first calls `loadDiscoveryDocument(...)` and\n         * directly chains using the `then(...)` part of the promise to call\n         * the `tryLogin(...)` method.\n         *\n         * @param {?=} options LoginOptions to pass through to `tryLogin(...)`\n         * @return {?}\n         */\n        function (options) {\n            var _this = this;\n            if (options === void 0) { options = null; }\n            return this.loadDiscoveryDocument().then((/**\n             * @param {?} doc\n             * @return {?}\n             */\n            function (doc) {\n                return _this.tryLogin(options);\n            }));\n        };\n        /**\n         * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\n         * and if then chains to `initImplicitFlow()`, but only if there is no valid\n         * IdToken or no valid AccessToken.\n         *\n         * @param options LoginOptions to pass through to `tryLogin(...)`\n         */\n        /**\n         * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\n         * and if then chains to `initImplicitFlow()`, but only if there is no valid\n         * IdToken or no valid AccessToken.\n         *\n         * @param {?=} options LoginOptions to pass through to `tryLogin(...)`\n         * @return {?}\n         */\n        OAuthService.prototype.loadDiscoveryDocumentAndLogin = /**\n         * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\n         * and if then chains to `initImplicitFlow()`, but only if there is no valid\n         * IdToken or no valid AccessToken.\n         *\n         * @param {?=} options LoginOptions to pass through to `tryLogin(...)`\n         * @return {?}\n         */\n        function (options) {\n            var _this = this;\n            if (options === void 0) { options = null; }\n            return this.loadDiscoveryDocumentAndTryLogin(options).then((/**\n             * @param {?} _\n             * @return {?}\n             */\n            function (_) {\n                if (!_this.hasValidIdToken() || !_this.hasValidAccessToken()) {\n                    _this.initImplicitFlow();\n                    return false;\n                }\n                else {\n                    return true;\n                }\n            }));\n        };\n        /**\n         * @protected\n         * @param {...?} args\n         * @return {?}\n         */\n        OAuthService.prototype.debug = /**\n         * @protected\n         * @param {...?} args\n         * @return {?}\n         */\n        function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            if (this.showDebugInformation) {\n                this.logger.debug.apply(console, args);\n            }\n        };\n        /**\n         * @protected\n         * @param {?} url\n         * @return {?}\n         */\n        OAuthService.prototype.validateUrlFromDiscoveryDocument = /**\n         * @protected\n         * @param {?} url\n         * @return {?}\n         */\n        function (url) {\n            /** @type {?} */\n            var errors = [];\n            /** @type {?} */\n            var httpsCheck = this.validateUrlForHttps(url);\n            /** @type {?} */\n            var issuerCheck = this.validateUrlAgainstIssuer(url);\n            if (!httpsCheck) {\n                errors.push('https for all urls required. Also for urls received by discovery.');\n            }\n            if (!issuerCheck) {\n                errors.push('Every url in discovery document has to start with the issuer url.' +\n                    'Also see property strictDiscoveryDocumentValidation.');\n            }\n            return errors;\n        };\n        /**\n         * @protected\n         * @param {?} url\n         * @return {?}\n         */\n        OAuthService.prototype.validateUrlForHttps = /**\n         * @protected\n         * @param {?} url\n         * @return {?}\n         */\n        function (url) {\n            if (!url) {\n                return true;\n            }\n            /** @type {?} */\n            var lcUrl = url.toLowerCase();\n            if (this.requireHttps === false) {\n                return true;\n            }\n            if ((lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) ||\n                lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) &&\n                this.requireHttps === 'remoteOnly') {\n                return true;\n            }\n            return lcUrl.startsWith('https://');\n        };\n        /**\n         * @protected\n         * @param {?} url\n         * @return {?}\n         */\n        OAuthService.prototype.validateUrlAgainstIssuer = /**\n         * @protected\n         * @param {?} url\n         * @return {?}\n         */\n        function (url) {\n            if (!this.strictDiscoveryDocumentValidation) {\n                return true;\n            }\n            if (!url) {\n                return true;\n            }\n            return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.setupRefreshTimer = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            if (typeof window === 'undefined') {\n                this.debug('timer not supported on this plattform');\n                return;\n            }\n            if (this.hasValidIdToken()) {\n                this.clearAccessTokenTimer();\n                this.clearIdTokenTimer();\n                this.setupExpirationTimers();\n            }\n            this.events.pipe(operators.filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) { return e.type === 'token_received'; }))).subscribe((/**\n             * @param {?} _\n             * @return {?}\n             */\n            function (_) {\n                _this.clearAccessTokenTimer();\n                _this.clearIdTokenTimer();\n                _this.setupExpirationTimers();\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.setupExpirationTimers = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var idTokenExp = this.getIdTokenExpiration() || Number.MAX_VALUE;\n            /** @type {?} */\n            var accessTokenExp = this.getAccessTokenExpiration() || Number.MAX_VALUE;\n            /** @type {?} */\n            var useAccessTokenExp = accessTokenExp <= idTokenExp;\n            if (this.hasValidAccessToken() && useAccessTokenExp) {\n                this.setupAccessTokenTimer();\n            }\n            if (this.hasValidIdToken() && !useAccessTokenExp) {\n                this.setupIdTokenTimer();\n            }\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.setupAccessTokenTimer = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var expiration = this.getAccessTokenExpiration();\n            /** @type {?} */\n            var storedAt = this.getAccessTokenStoredAt();\n            /** @type {?} */\n            var timeout = this.calcTimeout(storedAt, expiration);\n            this.ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            function () {\n                _this.accessTokenTimeoutSubscription = rxjs.of(new OAuthInfoEvent('token_expires', 'access_token'))\n                    .pipe(operators.delay(timeout))\n                    .subscribe((/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                function (e) {\n                    _this.ngZone.run((/**\n                     * @return {?}\n                     */\n                    function () {\n                        _this.eventsSubject.next(e);\n                    }));\n                }));\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.setupIdTokenTimer = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var expiration = this.getIdTokenExpiration();\n            /** @type {?} */\n            var storedAt = this.getIdTokenStoredAt();\n            /** @type {?} */\n            var timeout = this.calcTimeout(storedAt, expiration);\n            this.ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            function () {\n                _this.idTokenTimeoutSubscription = rxjs.of(new OAuthInfoEvent('token_expires', 'id_token'))\n                    .pipe(operators.delay(timeout))\n                    .subscribe((/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                function (e) {\n                    _this.ngZone.run((/**\n                     * @return {?}\n                     */\n                    function () {\n                        _this.eventsSubject.next(e);\n                    }));\n                }));\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.clearAccessTokenTimer = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            if (this.accessTokenTimeoutSubscription) {\n                this.accessTokenTimeoutSubscription.unsubscribe();\n            }\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.clearIdTokenTimer = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            if (this.idTokenTimeoutSubscription) {\n                this.idTokenTimeoutSubscription.unsubscribe();\n            }\n        };\n        /**\n         * @protected\n         * @param {?} storedAt\n         * @param {?} expiration\n         * @return {?}\n         */\n        OAuthService.prototype.calcTimeout = /**\n         * @protected\n         * @param {?} storedAt\n         * @param {?} expiration\n         * @return {?}\n         */\n        function (storedAt, expiration) {\n            /** @type {?} */\n            var now = Date.now();\n            /** @type {?} */\n            var delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n            return Math.max(0, delta);\n        };\n        /**\n         * DEPRECATED. Use a provider for OAuthStorage instead:\n         *\n         * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\n         * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\n         * Sets a custom storage used to store the received\n         * tokens on client side. By default, the browser's\n         * sessionStorage is used.\n         * @ignore\n         *\n         * @param storage\n         */\n        /**\n         * DEPRECATED. Use a provider for OAuthStorage instead:\n         *\n         * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\n         * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\n         * Sets a custom storage used to store the received\n         * tokens on client side. By default, the browser's\n         * sessionStorage is used.\n         * @ignore\n         *\n         * @param {?} storage\n         * @return {?}\n         */\n        OAuthService.prototype.setStorage = /**\n         * DEPRECATED. Use a provider for OAuthStorage instead:\n         *\n         * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\n         * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\n         * Sets a custom storage used to store the received\n         * tokens on client side. By default, the browser's\n         * sessionStorage is used.\n         * @ignore\n         *\n         * @param {?} storage\n         * @return {?}\n         */\n        function (storage) {\n            this._storage = storage;\n            this.configChanged();\n        };\n        /**\n         * Loads the discovery document to configure most\n         * properties of this service. The url of the discovery\n         * document is infered from the issuer's url according\n         * to the OpenId Connect spec. To use another url you\n         * can pass it to to optional parameter fullUrl.\n         *\n         * @param fullUrl\n         */\n        /**\n         * Loads the discovery document to configure most\n         * properties of this service. The url of the discovery\n         * document is infered from the issuer's url according\n         * to the OpenId Connect spec. To use another url you\n         * can pass it to to optional parameter fullUrl.\n         *\n         * @param {?=} fullUrl\n         * @return {?}\n         */\n        OAuthService.prototype.loadDiscoveryDocument = /**\n         * Loads the discovery document to configure most\n         * properties of this service. The url of the discovery\n         * document is infered from the issuer's url according\n         * to the OpenId Connect spec. To use another url you\n         * can pass it to to optional parameter fullUrl.\n         *\n         * @param {?=} fullUrl\n         * @return {?}\n         */\n        function (fullUrl) {\n            var _this = this;\n            if (fullUrl === void 0) { fullUrl = null; }\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                if (!fullUrl) {\n                    fullUrl = _this.issuer || '';\n                    if (!fullUrl.endsWith('/')) {\n                        fullUrl += '/';\n                    }\n                    fullUrl += '.well-known/openid-configuration';\n                }\n                if (!_this.validateUrlForHttps(fullUrl)) {\n                    reject('issuer must use https, or config value for property requireHttps must allow http');\n                    return;\n                }\n                _this.http.get(fullUrl).subscribe((/**\n                 * @param {?} doc\n                 * @return {?}\n                 */\n                function (doc) {\n                    if (!_this.validateDiscoveryDocument(doc)) {\n                        _this.eventsSubject.next(new OAuthErrorEvent('discovery_document_validation_error', null));\n                        reject('discovery_document_validation_error');\n                        return;\n                    }\n                    _this.loginUrl = doc.authorization_endpoint;\n                    _this.logoutUrl = doc.end_session_endpoint || _this.logoutUrl;\n                    _this.grantTypesSupported = doc.grant_types_supported;\n                    _this.issuer = doc.issuer;\n                    _this.tokenEndpoint = doc.token_endpoint;\n                    _this.userinfoEndpoint = doc.userinfo_endpoint;\n                    _this.jwksUri = doc.jwks_uri;\n                    _this.sessionCheckIFrameUrl = doc.check_session_iframe || _this.sessionCheckIFrameUrl;\n                    _this.discoveryDocumentLoaded = true;\n                    _this.discoveryDocumentLoadedSubject.next(doc);\n                    if (_this.sessionChecksEnabled) {\n                        _this.restartSessionChecksIfStillLoggedIn();\n                    }\n                    _this.loadJwks()\n                        .then((/**\n                     * @param {?} jwks\n                     * @return {?}\n                     */\n                    function (jwks) {\n                        /** @type {?} */\n                        var result = {\n                            discoveryDocument: doc,\n                            jwks: jwks\n                        };\n                        /** @type {?} */\n                        var event = new OAuthSuccessEvent('discovery_document_loaded', result);\n                        _this.eventsSubject.next(event);\n                        resolve(event);\n                        return;\n                    }))\n                        .catch((/**\n                     * @param {?} err\n                     * @return {?}\n                     */\n                    function (err) {\n                        _this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n                        reject(err);\n                        return;\n                    }));\n                }), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) {\n                    _this.logger.error('error loading discovery document', err);\n                    _this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n                    reject(err);\n                }));\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.loadJwks = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                if (_this.jwksUri) {\n                    _this.http.get(_this.jwksUri).subscribe((/**\n                     * @param {?} jwks\n                     * @return {?}\n                     */\n                    function (jwks) {\n                        _this.jwks = jwks;\n                        _this.eventsSubject.next(new OAuthSuccessEvent('discovery_document_loaded'));\n                        resolve(jwks);\n                    }), (/**\n                     * @param {?} err\n                     * @return {?}\n                     */\n                    function (err) {\n                        _this.logger.error('error loading jwks', err);\n                        _this.eventsSubject.next(new OAuthErrorEvent('jwks_load_error', err));\n                        reject(err);\n                    }));\n                }\n                else {\n                    resolve(null);\n                }\n            }));\n        };\n        /**\n         * @protected\n         * @param {?} doc\n         * @return {?}\n         */\n        OAuthService.prototype.validateDiscoveryDocument = /**\n         * @protected\n         * @param {?} doc\n         * @return {?}\n         */\n        function (doc) {\n            /** @type {?} */\n            var errors;\n            if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n                this.logger.error('invalid issuer in discovery document', 'expected: ' + this.issuer, 'current: ' + doc.issuer);\n                return false;\n            }\n            errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n            if (errors.length > 0) {\n                this.logger.error('error validating authorization_endpoint in discovery document', errors);\n                return false;\n            }\n            errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n            if (errors.length > 0) {\n                this.logger.error('error validating end_session_endpoint in discovery document', errors);\n                return false;\n            }\n            errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n            if (errors.length > 0) {\n                this.logger.error('error validating token_endpoint in discovery document', errors);\n            }\n            errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n            if (errors.length > 0) {\n                this.logger.error('error validating userinfo_endpoint in discovery document', errors);\n                return false;\n            }\n            errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n            if (errors.length > 0) {\n                this.logger.error('error validating jwks_uri in discovery document', errors);\n                return false;\n            }\n            if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n                this.logger.warn('sessionChecksEnabled is activated but discovery document' +\n                    ' does not contain a check_session_iframe field');\n            }\n            return true;\n        };\n        /**\n         * Uses password flow to exchange userName and password for an\n         * access_token. After receiving the access_token, this method\n         * uses it to query the userinfo endpoint in order to get information\n         * about the user in question.\n         *\n         * When using this, make sure that the property oidc is set to false.\n         * Otherwise stricter validations take place that make this operation\n         * fail.\n         *\n         * @param userName\n         * @param password\n         * @param headers Optional additional http-headers.\n         */\n        /**\n         * Uses password flow to exchange userName and password for an\n         * access_token. After receiving the access_token, this method\n         * uses it to query the userinfo endpoint in order to get information\n         * about the user in question.\n         *\n         * When using this, make sure that the property oidc is set to false.\n         * Otherwise stricter validations take place that make this operation\n         * fail.\n         *\n         * @param {?} userName\n         * @param {?} password\n         * @param {?=} headers Optional additional http-headers.\n         * @return {?}\n         */\n        OAuthService.prototype.fetchTokenUsingPasswordFlowAndLoadUserProfile = /**\n         * Uses password flow to exchange userName and password for an\n         * access_token. After receiving the access_token, this method\n         * uses it to query the userinfo endpoint in order to get information\n         * about the user in question.\n         *\n         * When using this, make sure that the property oidc is set to false.\n         * Otherwise stricter validations take place that make this operation\n         * fail.\n         *\n         * @param {?} userName\n         * @param {?} password\n         * @param {?=} headers Optional additional http-headers.\n         * @return {?}\n         */\n        function (userName, password, headers) {\n            var _this = this;\n            if (headers === void 0) { headers = new http.HttpHeaders(); }\n            return this.fetchTokenUsingPasswordFlow(userName, password, headers).then((/**\n             * @return {?}\n             */\n            function () { return _this.loadUserProfile(); }));\n        };\n        /**\n         * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\n         *\n         * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\n         * Otherwise stricter validations take place that make this operation fail.\n         */\n        /**\n         * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\n         *\n         * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\n         * Otherwise stricter validations take place that make this operation fail.\n         * @return {?}\n         */\n        OAuthService.prototype.loadUserProfile = /**\n         * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\n         *\n         * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\n         * Otherwise stricter validations take place that make this operation fail.\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            if (!this.hasValidAccessToken()) {\n                throw new Error('Can not load User Profile without access_token');\n            }\n            if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n                throw new Error('userinfoEndpoint must use https, or config value for property requireHttps must allow http');\n            }\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                /** @type {?} */\n                var headers = new http.HttpHeaders().set('Authorization', 'Bearer ' + _this.getAccessToken());\n                _this.http.get(_this.userinfoEndpoint, { headers: headers }).subscribe((/**\n                 * @param {?} info\n                 * @return {?}\n                 */\n                function (info) {\n                    _this.debug('userinfo received', info);\n                    /** @type {?} */\n                    var existingClaims = _this.getIdentityClaims() || {};\n                    if (!_this.skipSubjectCheck) {\n                        if (_this.oidc &&\n                            (!existingClaims['sub'] || info.sub !== existingClaims['sub'])) {\n                            /** @type {?} */\n                            var err = 'if property oidc is true, the received user-id (sub) has to be the user-id ' +\n                                'of the user that has logged in with oidc.\\n' +\n                                'if you are not using oidc but just oauth2 password flow set oidc to false';\n                            reject(err);\n                            return;\n                        }\n                    }\n                    info = Object.assign({}, existingClaims, info);\n                    _this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n                    _this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n                    resolve(info);\n                }), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) {\n                    _this.logger.error('error loading user info', err);\n                    _this.eventsSubject.next(new OAuthErrorEvent('user_profile_load_error', err));\n                    reject(err);\n                }));\n            }));\n        };\n        /**\n         * Uses password flow to exchange userName and password for an access_token.\n         * @param userName\n         * @param password\n         * @param headers Optional additional http-headers.\n         */\n        /**\n         * Uses password flow to exchange userName and password for an access_token.\n         * @param {?} userName\n         * @param {?} password\n         * @param {?=} headers Optional additional http-headers.\n         * @return {?}\n         */\n        OAuthService.prototype.fetchTokenUsingPasswordFlow = /**\n         * Uses password flow to exchange userName and password for an access_token.\n         * @param {?} userName\n         * @param {?} password\n         * @param {?=} headers Optional additional http-headers.\n         * @return {?}\n         */\n        function (userName, password, headers) {\n            var _this = this;\n            if (headers === void 0) { headers = new http.HttpHeaders(); }\n            if (!this.validateUrlForHttps(this.tokenEndpoint)) {\n                throw new Error('tokenEndpoint must use https, or config value for property requireHttps must allow http');\n            }\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                var e_1, _a;\n                /**\n                 * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n                 * serialize and parse URL parameter keys and values.\n                 *\n                 * \\@stable\n                 * @type {?}\n                 */\n                var params = new http.HttpParams({ encoder: new WebHttpUrlEncodingCodec() })\n                    .set('grant_type', 'password')\n                    .set('scope', _this.scope)\n                    .set('username', userName)\n                    .set('password', password);\n                if (_this.useHttpBasicAuth) {\n                    /** @type {?} */\n                    var header = btoa(_this.clientId + \":\" + _this.dummyClientSecret);\n                    headers = headers.set('Authorization', 'Basic ' + header);\n                }\n                if (!_this.useHttpBasicAuth) {\n                    params = params.set('client_id', _this.clientId);\n                }\n                if (!_this.useHttpBasicAuth && _this.dummyClientSecret) {\n                    params = params.set('client_secret', _this.dummyClientSecret);\n                }\n                if (_this.customQueryParams) {\n                    try {\n                        for (var _b = __values(Object.getOwnPropertyNames(_this.customQueryParams)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                            var key = _c.value;\n                            params = params.set(key, _this.customQueryParams[key]);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                }\n                headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n                _this.http\n                    .post(_this.tokenEndpoint, params, { headers: headers })\n                    .subscribe((/**\n                 * @param {?} tokenResponse\n                 * @return {?}\n                 */\n                function (tokenResponse) {\n                    _this.debug('tokenResponse', tokenResponse);\n                    _this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in, tokenResponse.scope);\n                    _this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                    resolve(tokenResponse);\n                }), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) {\n                    _this.logger.error('Error performing password flow', err);\n                    _this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n                    reject(err);\n                }));\n            }));\n        };\n        /**\n         * Refreshes the token using a refresh_token.\n         * This does not work for implicit flow, b/c\n         * there is no refresh_token in this flow.\n         * A solution for this is provided by the\n         * method silentRefresh.\n         */\n        /**\n         * Refreshes the token using a refresh_token.\n         * This does not work for implicit flow, b/c\n         * there is no refresh_token in this flow.\n         * A solution for this is provided by the\n         * method silentRefresh.\n         * @return {?}\n         */\n        OAuthService.prototype.refreshToken = /**\n         * Refreshes the token using a refresh_token.\n         * This does not work for implicit flow, b/c\n         * there is no refresh_token in this flow.\n         * A solution for this is provided by the\n         * method silentRefresh.\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            if (!this.validateUrlForHttps(this.tokenEndpoint)) {\n                throw new Error('tokenEndpoint must use https, or config value for property requireHttps must allow http');\n            }\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                var e_2, _a;\n                /** @type {?} */\n                var params = new http.HttpParams()\n                    .set('grant_type', 'refresh_token')\n                    .set('client_id', _this.clientId)\n                    .set('scope', _this.scope)\n                    .set('refresh_token', _this._storage.getItem('refresh_token'));\n                if (_this.dummyClientSecret) {\n                    params = params.set('client_secret', _this.dummyClientSecret);\n                }\n                if (_this.customQueryParams) {\n                    try {\n                        for (var _b = __values(Object.getOwnPropertyNames(_this.customQueryParams)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                            var key = _c.value;\n                            params = params.set(key, _this.customQueryParams[key]);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                }\n                /** @type {?} */\n                var headers = new http.HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n                _this.http\n                    .post(_this.tokenEndpoint, params, { headers: headers })\n                    .pipe(operators.switchMap((/**\n                 * @param {?} tokenResponse\n                 * @return {?}\n                 */\n                function (tokenResponse) {\n                    if (tokenResponse.id_token) {\n                        return rxjs.from(_this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true))\n                            .pipe(operators.tap((/**\n                         * @param {?} result\n                         * @return {?}\n                         */\n                        function (result) { return _this.storeIdToken(result); })), operators.map((/**\n                         * @param {?} _\n                         * @return {?}\n                         */\n                        function (_) { return tokenResponse; })));\n                    }\n                    else {\n                        return rxjs.of(tokenResponse);\n                    }\n                })))\n                    .subscribe((/**\n                 * @param {?} tokenResponse\n                 * @return {?}\n                 */\n                function (tokenResponse) {\n                    _this.debug('refresh tokenResponse', tokenResponse);\n                    _this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in, tokenResponse.scope);\n                    _this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                    _this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n                    resolve(tokenResponse);\n                }), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) {\n                    _this.logger.error('Error performing password flow', err);\n                    _this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n                    reject(err);\n                }));\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.removeSilentRefreshEventListener = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            if (this.silentRefreshPostMessageEventListener) {\n                window.removeEventListener('message', this.silentRefreshPostMessageEventListener);\n                this.silentRefreshPostMessageEventListener = null;\n            }\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.setupSilentRefreshEventListener = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            this.removeSilentRefreshEventListener();\n            this.silentRefreshPostMessageEventListener = (/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                /** @type {?} */\n                var message = _this.processMessageEventMessage(e);\n                _this.tryLogin({\n                    customHashFragment: message,\n                    preventClearHashAfterLogin: true,\n                    onLoginError: (/**\n                     * @param {?} err\n                     * @return {?}\n                     */\n                    function (err) {\n                        _this.eventsSubject.next(new OAuthErrorEvent('silent_refresh_error', err));\n                    }),\n                    onTokenReceived: (/**\n                     * @return {?}\n                     */\n                    function () {\n                        _this.eventsSubject.next(new OAuthSuccessEvent('silently_refreshed'));\n                    })\n                }).catch((/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) { return _this.debug('tryLogin during silent refresh failed', err); }));\n            });\n            window.addEventListener('message', this.silentRefreshPostMessageEventListener);\n        };\n        /**\n         * Performs a silent refresh for implicit flow.\n         * Use this method to get new tokens when/before\n         * the existing tokens expire.\n         */\n        /**\n         * Performs a silent refresh for implicit flow.\n         * Use this method to get new tokens when/before\n         * the existing tokens expire.\n         * @param {?=} params\n         * @param {?=} noPrompt\n         * @return {?}\n         */\n        OAuthService.prototype.silentRefresh = /**\n         * Performs a silent refresh for implicit flow.\n         * Use this method to get new tokens when/before\n         * the existing tokens expire.\n         * @param {?=} params\n         * @param {?=} noPrompt\n         * @return {?}\n         */\n        function (params, noPrompt) {\n            var _this = this;\n            if (params === void 0) { params = {}; }\n            if (noPrompt === void 0) { noPrompt = true; }\n            /** @type {?} */\n            var claims = this.getIdentityClaims() || {};\n            if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n                params['id_token_hint'] = this.getIdToken();\n            }\n            if (!this.validateUrlForHttps(this.loginUrl)) {\n                throw new Error('tokenEndpoint must use https, or config value for property requireHttps must allow http');\n            }\n            if (typeof document === 'undefined') {\n                throw new Error('silent refresh is not supported on this platform');\n            }\n            /** @type {?} */\n            var existingIframe = document.getElementById(this.silentRefreshIFrameName);\n            if (existingIframe) {\n                document.body.removeChild(existingIframe);\n            }\n            this.silentRefreshSubject = claims['sub'];\n            /** @type {?} */\n            var iframe = document.createElement('iframe');\n            iframe.id = this.silentRefreshIFrameName;\n            this.setupSilentRefreshEventListener();\n            /** @type {?} */\n            var redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n            this.createLoginUrl(null, null, redirectUri, noPrompt, params).then((/**\n             * @param {?} url\n             * @return {?}\n             */\n            function (url) {\n                iframe.setAttribute('src', url);\n                if (!_this.silentRefreshShowIFrame) {\n                    iframe.style['display'] = 'none';\n                }\n                document.body.appendChild(iframe);\n            }));\n            /** @type {?} */\n            var errors = this.events.pipe(operators.filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) { return e instanceof OAuthErrorEvent; })), operators.first());\n            /** @type {?} */\n            var success = this.events.pipe(operators.filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) { return e.type === 'silently_refreshed'; })), operators.first());\n            /** @type {?} */\n            var timeout = rxjs.of(new OAuthErrorEvent('silent_refresh_timeout', null)).pipe(operators.delay(this.silentRefreshTimeout));\n            return rxjs.race([errors, success, timeout])\n                .pipe(operators.tap((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                if (e.type === 'silent_refresh_timeout') {\n                    _this.eventsSubject.next(e);\n                }\n            })), operators.map((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                if (e instanceof OAuthErrorEvent) {\n                    throw e;\n                }\n                return e;\n            })))\n                .toPromise();\n        };\n        /**\n         * @param {?=} options\n         * @return {?}\n         */\n        OAuthService.prototype.initImplicitFlowInPopup = /**\n         * @param {?=} options\n         * @return {?}\n         */\n        function (options) {\n            var _this = this;\n            options = options || {};\n            return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\n                display: 'popup'\n            }).then((/**\n             * @param {?} url\n             * @return {?}\n             */\n            function (url) {\n                return new Promise((/**\n                 * @param {?} resolve\n                 * @param {?} reject\n                 * @return {?}\n                 */\n                function (resolve, reject) {\n                    /** @type {?} */\n                    var windowRef = window.open(url, '_blank', _this.calculatePopupFeatures(options));\n                    /** @type {?} */\n                    var cleanup = (/**\n                     * @return {?}\n                     */\n                    function () {\n                        window.removeEventListener('message', listener);\n                        windowRef.close();\n                        windowRef = null;\n                    });\n                    /** @type {?} */\n                    var listener = (/**\n                     * @param {?} e\n                     * @return {?}\n                     */\n                    function (e) {\n                        /** @type {?} */\n                        var message = _this.processMessageEventMessage(e);\n                        _this.tryLogin({\n                            customHashFragment: message,\n                            preventClearHashAfterLogin: true,\n                        }).then((/**\n                         * @return {?}\n                         */\n                        function () {\n                            cleanup();\n                            resolve();\n                        }), (/**\n                         * @param {?} err\n                         * @return {?}\n                         */\n                        function (err) {\n                            cleanup();\n                            reject(err);\n                        }));\n                    });\n                    window.addEventListener('message', listener);\n                }));\n            }));\n        };\n        /**\n         * @protected\n         * @param {?} options\n         * @return {?}\n         */\n        OAuthService.prototype.calculatePopupFeatures = /**\n         * @protected\n         * @param {?} options\n         * @return {?}\n         */\n        function (options) {\n            // Specify an static height and width and calculate centered position\n            /** @type {?} */\n            var height = options.height || 470;\n            /** @type {?} */\n            var width = options.width || 500;\n            /** @type {?} */\n            var left = (screen.width / 2) - (width / 2);\n            /** @type {?} */\n            var top = (screen.height / 2) - (height / 2);\n            return \"location=no,toolbar=no,width=\" + width + \",height=\" + height + \",top=\" + top + \",left=\" + left;\n        };\n        /**\n         * @protected\n         * @param {?} e\n         * @return {?}\n         */\n        OAuthService.prototype.processMessageEventMessage = /**\n         * @protected\n         * @param {?} e\n         * @return {?}\n         */\n        function (e) {\n            /** @type {?} */\n            var expectedPrefix = '#';\n            if (this.silentRefreshMessagePrefix) {\n                expectedPrefix += this.silentRefreshMessagePrefix;\n            }\n            if (!e || !e.data || typeof e.data !== 'string') {\n                return;\n            }\n            /** @type {?} */\n            var prefixedMessage = e.data;\n            if (!prefixedMessage.startsWith(expectedPrefix)) {\n                return;\n            }\n            return '#' + prefixedMessage.substr(expectedPrefix.length);\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.canPerformSessionCheck = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            if (!this.sessionChecksEnabled) {\n                return false;\n            }\n            if (!this.sessionCheckIFrameUrl) {\n                console.warn('sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl');\n                return false;\n            }\n            /** @type {?} */\n            var sessionState = this.getSessionState();\n            if (!sessionState) {\n                console.warn('sessionChecksEnabled is activated but there is no session_state');\n                return false;\n            }\n            if (typeof document === 'undefined') {\n                return false;\n            }\n            return true;\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.setupSessionCheckEventListener = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            this.removeSessionCheckEventListener();\n            this.sessionCheckEventListener = (/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                /** @type {?} */\n                var origin = e.origin.toLowerCase();\n                /** @type {?} */\n                var issuer = _this.issuer.toLowerCase();\n                _this.debug('sessionCheckEventListener');\n                if (!issuer.startsWith(origin)) {\n                    _this.debug('sessionCheckEventListener', 'wrong origin', origin, 'expected', issuer);\n                }\n                // only run in Angular zone if it is 'changed' or 'error'\n                switch (e.data) {\n                    case 'unchanged':\n                        _this.handleSessionUnchanged();\n                        break;\n                    case 'changed':\n                        _this.ngZone.run((/**\n                         * @return {?}\n                         */\n                        function () {\n                            _this.handleSessionChange();\n                        }));\n                        break;\n                    case 'error':\n                        _this.ngZone.run((/**\n                         * @return {?}\n                         */\n                        function () {\n                            _this.handleSessionError();\n                        }));\n                        break;\n                }\n                _this.debug('got info from session check inframe', e);\n            });\n            // prevent Angular from refreshing the view on every message (runs in intervals)\n            this.ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            function () {\n                window.addEventListener('message', _this.sessionCheckEventListener);\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.handleSessionUnchanged = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            this.debug('session check', 'session unchanged');\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.handleSessionChange = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            /* events: session_changed, relogin, stopTimer, logged_out*/\n            this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n            this.stopSessionCheckTimer();\n            if (this.silentRefreshRedirectUri) {\n                this.silentRefresh().catch((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                function (_) {\n                    return _this.debug('silent refresh failed after session changed');\n                }));\n                this.waitForSilentRefreshAfterSessionChange();\n            }\n            else {\n                this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n                this.logOut(true);\n            }\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.waitForSilentRefreshAfterSessionChange = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            this.events\n                .pipe(operators.filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                return e.type === 'silently_refreshed' ||\n                    e.type === 'silent_refresh_timeout' ||\n                    e.type === 'silent_refresh_error';\n            })), operators.first())\n                .subscribe((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) {\n                if (e.type !== 'silently_refreshed') {\n                    _this.debug('silent refresh did not work after session changed');\n                    _this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n                    _this.logOut(true);\n                }\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.handleSessionError = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            this.stopSessionCheckTimer();\n            this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.removeSessionCheckEventListener = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            if (this.sessionCheckEventListener) {\n                window.removeEventListener('message', this.sessionCheckEventListener);\n                this.sessionCheckEventListener = null;\n            }\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.initSessionCheck = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            if (!this.canPerformSessionCheck()) {\n                return;\n            }\n            /** @type {?} */\n            var existingIframe = document.getElementById(this.sessionCheckIFrameName);\n            if (existingIframe) {\n                document.body.removeChild(existingIframe);\n            }\n            /** @type {?} */\n            var iframe = document.createElement('iframe');\n            iframe.id = this.sessionCheckIFrameName;\n            this.setupSessionCheckEventListener();\n            /** @type {?} */\n            var url = this.sessionCheckIFrameUrl;\n            iframe.setAttribute('src', url);\n            iframe.style.display = 'none';\n            document.body.appendChild(iframe);\n            this.startSessionCheckTimer();\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.startSessionCheckTimer = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            this.stopSessionCheckTimer();\n            this.ngZone.runOutsideAngular((/**\n             * @return {?}\n             */\n            function () {\n                _this.sessionCheckTimer = setInterval(_this.checkSession.bind(_this), _this.sessionCheckIntervall);\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.stopSessionCheckTimer = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            if (this.sessionCheckTimer) {\n                clearInterval(this.sessionCheckTimer);\n                this.sessionCheckTimer = null;\n            }\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.checkSession = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var iframe = document.getElementById(this.sessionCheckIFrameName);\n            if (!iframe) {\n                this.logger.warn('checkSession did not find iframe', this.sessionCheckIFrameName);\n            }\n            /** @type {?} */\n            var sessionState = this.getSessionState();\n            if (!sessionState) {\n                this.stopSessionCheckTimer();\n            }\n            /** @type {?} */\n            var message = this.clientId + ' ' + sessionState;\n            iframe.contentWindow.postMessage(message, this.issuer);\n        };\n        /**\n         * @protected\n         * @param {?=} state\n         * @param {?=} loginHint\n         * @param {?=} customRedirectUri\n         * @param {?=} noPrompt\n         * @param {?=} params\n         * @return {?}\n         */\n        OAuthService.prototype.createLoginUrl = /**\n         * @protected\n         * @param {?=} state\n         * @param {?=} loginHint\n         * @param {?=} customRedirectUri\n         * @param {?=} noPrompt\n         * @param {?=} params\n         * @return {?}\n         */\n        function (state, loginHint, customRedirectUri, noPrompt, params) {\n            if (state === void 0) { state = ''; }\n            if (loginHint === void 0) { loginHint = ''; }\n            if (customRedirectUri === void 0) { customRedirectUri = ''; }\n            if (noPrompt === void 0) { noPrompt = false; }\n            if (params === void 0) { params = {}; }\n            return __awaiter(this, void 0, void 0, function () {\n                var e_3, _a, e_4, _b, that, redirectUri, nonce, seperationChar, scope, url, _c, challenge, verifier, _d, _e, key, _f, _g, key;\n                return __generator(this, function (_h) {\n                    switch (_h.label) {\n                        case 0:\n                            that = this;\n                            if (customRedirectUri) {\n                                redirectUri = customRedirectUri;\n                            }\n                            else {\n                                redirectUri = this.redirectUri;\n                            }\n                            return [4 /*yield*/, this.createAndSaveNonce()];\n                        case 1:\n                            nonce = _h.sent();\n                            if (state) {\n                                state = nonce + this.config.nonceStateSeparator + state;\n                            }\n                            else {\n                                state = nonce;\n                            }\n                            if (!this.requestAccessToken && !this.oidc) {\n                                throw new Error('Either requestAccessToken or oidc or both must be true');\n                            }\n                            if (this.config.responseType) {\n                                this.responseType = this.config.responseType;\n                            }\n                            else {\n                                if (this.oidc && this.requestAccessToken) {\n                                    this.responseType = 'id_token token';\n                                }\n                                else if (this.oidc && !this.requestAccessToken) {\n                                    this.responseType = 'id_token';\n                                }\n                                else {\n                                    this.responseType = 'token';\n                                }\n                            }\n                            seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n                            scope = that.scope;\n                            if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n                                scope = 'openid ' + scope;\n                            }\n                            url = that.loginUrl +\n                                seperationChar +\n                                'response_type=' +\n                                encodeURIComponent(that.responseType) +\n                                '&client_id=' +\n                                encodeURIComponent(that.clientId) +\n                                '&state=' +\n                                encodeURIComponent(state) +\n                                '&redirect_uri=' +\n                                encodeURIComponent(redirectUri) +\n                                '&scope=' +\n                                encodeURIComponent(scope);\n                            if (!(this.responseType === 'code' && !this.disablePKCE)) return [3 /*break*/, 3];\n                            return [4 /*yield*/, this.createChallangeVerifierPairForPKCE()];\n                        case 2:\n                            _c = __read.apply(void 0, [_h.sent(), 2]), challenge = _c[0], verifier = _c[1];\n                            this._storage.setItem('PKCI_verifier', verifier);\n                            url += '&code_challenge=' + challenge;\n                            url += '&code_challenge_method=S256';\n                            _h.label = 3;\n                        case 3:\n                            if (loginHint) {\n                                url += '&login_hint=' + encodeURIComponent(loginHint);\n                            }\n                            if (that.resource) {\n                                url += '&resource=' + encodeURIComponent(that.resource);\n                            }\n                            if (that.oidc) {\n                                url += '&nonce=' + encodeURIComponent(nonce);\n                            }\n                            if (noPrompt) {\n                                url += '&prompt=none';\n                            }\n                            try {\n                                for (_d = __values(Object.keys(params)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                                    key = _e.value;\n                                    url +=\n                                        '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                                }\n                            }\n                            catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                            finally {\n                                try {\n                                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n                                }\n                                finally { if (e_3) throw e_3.error; }\n                            }\n                            if (this.customQueryParams) {\n                                try {\n                                    for (_f = __values(Object.getOwnPropertyNames(this.customQueryParams)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                                        key = _g.value;\n                                        url +=\n                                            '&' + key + '=' + encodeURIComponent(this.customQueryParams[key]);\n                                    }\n                                }\n                                catch (e_4_1) { e_4 = { error: e_4_1 }; }\n                                finally {\n                                    try {\n                                        if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                                    }\n                                    finally { if (e_4) throw e_4.error; }\n                                }\n                            }\n                            return [2 /*return*/, url];\n                    }\n                });\n            });\n        };\n        /**\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        OAuthService.prototype.initImplicitFlowInternal = /**\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        function (additionalState, params) {\n            var _this = this;\n            if (additionalState === void 0) { additionalState = ''; }\n            if (params === void 0) { params = ''; }\n            if (this.inImplicitFlow) {\n                return;\n            }\n            this.inImplicitFlow = true;\n            if (!this.validateUrlForHttps(this.loginUrl)) {\n                throw new Error('loginUrl must use https, or config value for property requireHttps must allow http');\n            }\n            /** @type {?} */\n            var addParams = {};\n            /** @type {?} */\n            var loginHint = null;\n            if (typeof params === 'string') {\n                loginHint = params;\n            }\n            else if (typeof params === 'object') {\n                addParams = params;\n            }\n            this.createLoginUrl(additionalState, loginHint, null, false, addParams)\n                .then(this.config.openUri)\n                .catch((/**\n             * @param {?} error\n             * @return {?}\n             */\n            function (error) {\n                console.error('Error in initImplicitFlow', error);\n                _this.inImplicitFlow = false;\n            }));\n        };\n        /**\n         * Starts the implicit flow and redirects to user to\n         * the auth servers' login url.\n         *\n         * @param additionalState Optional state that is passed around.\n         *  You'll find this state in the property `state` after `tryLogin` logged in the user.\n         * @param params Hash with additional parameter. If it is a string, it is used for the\n         *               parameter loginHint (for the sake of compatibility with former versions)\n         */\n        /**\n         * Starts the implicit flow and redirects to user to\n         * the auth servers' login url.\n         *\n         * @param {?=} additionalState Optional state that is passed around.\n         *  You'll find this state in the property `state` after `tryLogin` logged in the user.\n         * @param {?=} params Hash with additional parameter. If it is a string, it is used for the\n         *               parameter loginHint (for the sake of compatibility with former versions)\n         * @return {?}\n         */\n        OAuthService.prototype.initImplicitFlow = /**\n         * Starts the implicit flow and redirects to user to\n         * the auth servers' login url.\n         *\n         * @param {?=} additionalState Optional state that is passed around.\n         *  You'll find this state in the property `state` after `tryLogin` logged in the user.\n         * @param {?=} params Hash with additional parameter. If it is a string, it is used for the\n         *               parameter loginHint (for the sake of compatibility with former versions)\n         * @return {?}\n         */\n        function (additionalState, params) {\n            var _this = this;\n            if (additionalState === void 0) { additionalState = ''; }\n            if (params === void 0) { params = ''; }\n            if (this.loginUrl !== '') {\n                this.initImplicitFlowInternal(additionalState, params);\n            }\n            else {\n                this.events\n                    .pipe(operators.filter((/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                function (e) { return e.type === 'discovery_document_loaded'; })))\n                    .subscribe((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                function (_) { return _this.initImplicitFlowInternal(additionalState, params); }));\n            }\n        };\n        /**\n         * Reset current implicit flow\n         *\n         * @description This method allows resetting the current implict flow in order to be initialized again.\n         */\n        /**\n         * Reset current implicit flow\n         *\n         * \\@description This method allows resetting the current implict flow in order to be initialized again.\n         * @return {?}\n         */\n        OAuthService.prototype.resetImplicitFlow = /**\n         * Reset current implicit flow\n         *\n         * \\@description This method allows resetting the current implict flow in order to be initialized again.\n         * @return {?}\n         */\n        function () {\n            this.inImplicitFlow = false;\n        };\n        /**\n         * @protected\n         * @param {?} options\n         * @return {?}\n         */\n        OAuthService.prototype.callOnTokenReceivedIfExists = /**\n         * @protected\n         * @param {?} options\n         * @return {?}\n         */\n        function (options) {\n            /** @type {?} */\n            var that = this;\n            if (options.onTokenReceived) {\n                /** @type {?} */\n                var tokenParams = {\n                    idClaims: that.getIdentityClaims(),\n                    idToken: that.getIdToken(),\n                    accessToken: that.getAccessToken(),\n                    state: that.state\n                };\n                options.onTokenReceived(tokenParams);\n            }\n        };\n        /**\n         * @protected\n         * @param {?} accessToken\n         * @param {?} refreshToken\n         * @param {?} expiresIn\n         * @param {?} grantedScopes\n         * @return {?}\n         */\n        OAuthService.prototype.storeAccessTokenResponse = /**\n         * @protected\n         * @param {?} accessToken\n         * @param {?} refreshToken\n         * @param {?} expiresIn\n         * @param {?} grantedScopes\n         * @return {?}\n         */\n        function (accessToken, refreshToken, expiresIn, grantedScopes) {\n            this._storage.setItem('access_token', accessToken);\n            if (grantedScopes) {\n                this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split('+')));\n            }\n            this._storage.setItem('access_token_stored_at', '' + Date.now());\n            if (expiresIn) {\n                /** @type {?} */\n                var expiresInMilliSeconds = expiresIn * 1000;\n                /** @type {?} */\n                var now = new Date();\n                /** @type {?} */\n                var expiresAt = now.getTime() + expiresInMilliSeconds;\n                this._storage.setItem('expires_at', '' + expiresAt);\n            }\n            if (refreshToken) {\n                this._storage.setItem('refresh_token', refreshToken);\n            }\n        };\n        /**\n         * Delegates to tryLoginImplicitFlow for the sake of competability\n         * @param options Optional options.\n         */\n        /**\n         * Delegates to tryLoginImplicitFlow for the sake of competability\n         * @param {?=} options Optional options.\n         * @return {?}\n         */\n        OAuthService.prototype.tryLogin = /**\n         * Delegates to tryLoginImplicitFlow for the sake of competability\n         * @param {?=} options Optional options.\n         * @return {?}\n         */\n        function (options) {\n            if (options === void 0) { options = null; }\n            if (this.config.responseType === 'code') {\n                return this.tryLoginCodeFlow().then((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                function (_) { return true; }));\n            }\n            else {\n                return this.tryLoginImplicitFlow(options);\n            }\n        };\n        /**\n         * @private\n         * @param {?} queryString\n         * @return {?}\n         */\n        OAuthService.prototype.parseQueryString = /**\n         * @private\n         * @param {?} queryString\n         * @return {?}\n         */\n        function (queryString) {\n            if (!queryString || queryString.length === 0) {\n                return {};\n            }\n            if (queryString.charAt(0) === '?') {\n                queryString = queryString.substr(1);\n            }\n            return this.urlHelper.parseQueryString(queryString);\n        };\n        /**\n         * @return {?}\n         */\n        OAuthService.prototype.tryLoginCodeFlow = /**\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var parts = this.parseQueryString(window.location.search);\n            /** @type {?} */\n            var code = parts['code'];\n            /** @type {?} */\n            var state = parts['state'];\n            /** @type {?} */\n            var href = location.href\n                .replace(/[&\\?]code=[^&\\$]*/, '')\n                .replace(/[&\\?]scope=[^&\\$]*/, '')\n                .replace(/[&\\?]state=[^&\\$]*/, '')\n                .replace(/[&\\?]session_state=[^&\\$]*/, '');\n            history.replaceState(null, window.name, href);\n            var _a = __read(this.parseState(state), 2), nonceInState = _a[0], userState = _a[1];\n            this.state = userState;\n            if (parts['error']) {\n                this.debug('error trying to login');\n                this.handleLoginError({}, parts);\n                /** @type {?} */\n                var err = new OAuthErrorEvent('code_error', {}, parts);\n                this.eventsSubject.next(err);\n                return Promise.reject(err);\n            }\n            if (!nonceInState) {\n                return Promise.resolve();\n            }\n            /** @type {?} */\n            var success = this.validateNonce(nonceInState);\n            if (!success) {\n                /** @type {?} */\n                var event_1 = new OAuthErrorEvent('invalid_nonce_in_state', null);\n                this.eventsSubject.next(event_1);\n                return Promise.reject(event_1);\n            }\n            if (code) {\n                return new Promise((/**\n                 * @param {?} resolve\n                 * @param {?} reject\n                 * @return {?}\n                 */\n                function (resolve, reject) {\n                    _this.getTokenFromCode(code).then((/**\n                     * @param {?} result\n                     * @return {?}\n                     */\n                    function (result) {\n                        resolve();\n                    })).catch((/**\n                     * @param {?} err\n                     * @return {?}\n                     */\n                    function (err) {\n                        reject(err);\n                    }));\n                }));\n            }\n            else {\n                return Promise.resolve();\n            }\n        };\n        /**\n         * Get token using an intermediate code. Works for the Authorization Code flow.\n         */\n        /**\n         * Get token using an intermediate code. Works for the Authorization Code flow.\n         * @private\n         * @param {?} code\n         * @return {?}\n         */\n        OAuthService.prototype.getTokenFromCode = /**\n         * Get token using an intermediate code. Works for the Authorization Code flow.\n         * @private\n         * @param {?} code\n         * @return {?}\n         */\n        function (code) {\n            /** @type {?} */\n            var params = new http.HttpParams()\n                .set('grant_type', 'authorization_code')\n                .set('code', code)\n                .set('redirect_uri', this.redirectUri);\n            if (!this.disablePKCE) {\n                /** @type {?} */\n                var pkciVerifier = this._storage.getItem('PKCI_verifier');\n                if (!pkciVerifier) {\n                    console.warn('No PKCI verifier found in oauth storage!');\n                }\n                else {\n                    params = params.set('code_verifier', pkciVerifier);\n                }\n            }\n            return this.fetchAndProcessToken(params);\n        };\n        /**\n         * @private\n         * @param {?} params\n         * @return {?}\n         */\n        OAuthService.prototype.fetchAndProcessToken = /**\n         * @private\n         * @param {?} params\n         * @return {?}\n         */\n        function (params) {\n            var _this = this;\n            /** @type {?} */\n            var headers = new http.HttpHeaders()\n                .set('Content-Type', 'application/x-www-form-urlencoded');\n            if (!this.validateUrlForHttps(this.tokenEndpoint)) {\n                throw new Error('tokenEndpoint must use Http. Also check property requireHttps.');\n            }\n            if (this.useHttpBasicAuth) {\n                /** @type {?} */\n                var header = btoa(this.clientId + \":\" + this.dummyClientSecret);\n                headers = headers.set('Authorization', 'Basic ' + header);\n            }\n            if (!this.useHttpBasicAuth) {\n                params = params.set('client_id', this.clientId);\n            }\n            if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n                params = params.set('client_secret', this.dummyClientSecret);\n            }\n            return new Promise((/**\n             * @param {?} resolve\n             * @param {?} reject\n             * @return {?}\n             */\n            function (resolve, reject) {\n                var e_5, _a;\n                if (_this.customQueryParams) {\n                    try {\n                        for (var _b = __values(Object.getOwnPropertyNames(_this.customQueryParams)), _c = _b.next(); !_c.done; _c = _b.next()) {\n                            var key = _c.value;\n                            params = params.set(key, _this.customQueryParams[key]);\n                        }\n                    }\n                    catch (e_5_1) { e_5 = { error: e_5_1 }; }\n                    finally {\n                        try {\n                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                        }\n                        finally { if (e_5) throw e_5.error; }\n                    }\n                }\n                _this.http.post(_this.tokenEndpoint, params, { headers: headers }).subscribe((/**\n                 * @param {?} tokenResponse\n                 * @return {?}\n                 */\n                function (tokenResponse) {\n                    _this.debug('refresh tokenResponse', tokenResponse);\n                    _this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in, tokenResponse.scope);\n                    if (_this.oidc && tokenResponse.id_token) {\n                        _this.processIdToken(tokenResponse.id_token, tokenResponse.access_token).\n                            then((/**\n                         * @param {?} result\n                         * @return {?}\n                         */\n                        function (result) {\n                            _this.storeIdToken(result);\n                            _this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                            _this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n                            resolve(tokenResponse);\n                        }))\n                            .catch((/**\n                         * @param {?} reason\n                         * @return {?}\n                         */\n                        function (reason) {\n                            _this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n                            console.error('Error validating tokens');\n                            console.error(reason);\n                            reject(reason);\n                        }));\n                    }\n                    else {\n                        _this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                        _this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n                        resolve(tokenResponse);\n                    }\n                }), (/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) {\n                    console.error('Error getting token', err);\n                    _this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n                    reject(err);\n                }));\n            }));\n        };\n        /**\n         * Checks whether there are tokens in the hash fragment\n         * as a result of the implicit flow. These tokens are\n         * parsed, validated and used to sign the user in to the\n         * current client.\n         *\n         * @param options Optional options.\n         */\n        /**\n         * Checks whether there are tokens in the hash fragment\n         * as a result of the implicit flow. These tokens are\n         * parsed, validated and used to sign the user in to the\n         * current client.\n         *\n         * @param {?=} options Optional options.\n         * @return {?}\n         */\n        OAuthService.prototype.tryLoginImplicitFlow = /**\n         * Checks whether there are tokens in the hash fragment\n         * as a result of the implicit flow. These tokens are\n         * parsed, validated and used to sign the user in to the\n         * current client.\n         *\n         * @param {?=} options Optional options.\n         * @return {?}\n         */\n        function (options) {\n            var _this = this;\n            if (options === void 0) { options = null; }\n            options = options || {};\n            /** @type {?} */\n            var parts;\n            if (options.customHashFragment) {\n                parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n            }\n            else {\n                parts = this.urlHelper.getHashFragmentParams();\n            }\n            this.debug('parsed url', parts);\n            /** @type {?} */\n            var state = parts['state'];\n            var _a = __read(this.parseState(state), 2), nonceInState = _a[0], userState = _a[1];\n            this.state = userState;\n            if (parts['error']) {\n                this.debug('error trying to login');\n                this.handleLoginError(options, parts);\n                /** @type {?} */\n                var err = new OAuthErrorEvent('token_error', {}, parts);\n                this.eventsSubject.next(err);\n                return Promise.reject(err);\n            }\n            /** @type {?} */\n            var accessToken = parts['access_token'];\n            /** @type {?} */\n            var idToken = parts['id_token'];\n            /** @type {?} */\n            var sessionState = parts['session_state'];\n            /** @type {?} */\n            var grantedScopes = parts['scope'];\n            if (!this.requestAccessToken && !this.oidc) {\n                return Promise.reject('Either requestAccessToken or oidc (or both) must be true.');\n            }\n            if (this.requestAccessToken && !accessToken) {\n                return Promise.resolve(false);\n            }\n            if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n                return Promise.resolve(false);\n            }\n            if (this.oidc && !idToken) {\n                return Promise.resolve(false);\n            }\n            if (this.sessionChecksEnabled && !sessionState) {\n                this.logger.warn('session checks (Session Status Change Notification) ' +\n                    'were activated in the configuration but the id_token ' +\n                    'does not contain a session_state claim');\n            }\n            if (this.requestAccessToken && !options.disableOAuth2StateCheck) {\n                /** @type {?} */\n                var success = this.validateNonce(nonceInState);\n                if (!success) {\n                    /** @type {?} */\n                    var event_2 = new OAuthErrorEvent('invalid_nonce_in_state', null);\n                    this.eventsSubject.next(event_2);\n                    return Promise.reject(event_2);\n                }\n            }\n            if (this.requestAccessToken) {\n                this.storeAccessTokenResponse(accessToken, null, parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec, grantedScopes);\n            }\n            if (!this.oidc) {\n                this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n                    location.hash = '';\n                }\n                this.callOnTokenReceivedIfExists(options);\n                return Promise.resolve(true);\n            }\n            return this.processIdToken(idToken, accessToken)\n                .then((/**\n             * @param {?} result\n             * @return {?}\n             */\n            function (result) {\n                if (options.validationHandler) {\n                    return options\n                        .validationHandler({\n                        accessToken: accessToken,\n                        idClaims: result.idTokenClaims,\n                        idToken: result.idToken,\n                        state: state\n                    })\n                        .then((/**\n                     * @param {?} _\n                     * @return {?}\n                     */\n                    function (_) { return result; }));\n                }\n                return result;\n            }))\n                .then((/**\n             * @param {?} result\n             * @return {?}\n             */\n            function (result) {\n                _this.storeIdToken(result);\n                _this.storeSessionState(sessionState);\n                if (_this.clearHashAfterLogin) {\n                    location.hash = '';\n                }\n                _this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n                _this.callOnTokenReceivedIfExists(options);\n                _this.inImplicitFlow = false;\n                return true;\n            }))\n                .catch((/**\n             * @param {?} reason\n             * @return {?}\n             */\n            function (reason) {\n                _this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n                _this.logger.error('Error validating tokens');\n                _this.logger.error(reason);\n                return Promise.reject(reason);\n            }));\n        };\n        /**\n         * @private\n         * @param {?} state\n         * @return {?}\n         */\n        OAuthService.prototype.parseState = /**\n         * @private\n         * @param {?} state\n         * @return {?}\n         */\n        function (state) {\n            /** @type {?} */\n            var nonce = state;\n            /** @type {?} */\n            var userState = '';\n            if (state) {\n                /** @type {?} */\n                var idx = state.indexOf(this.config.nonceStateSeparator);\n                if (idx > -1) {\n                    nonce = state.substr(0, idx);\n                    userState = state.substr(idx + this.config.nonceStateSeparator.length);\n                }\n            }\n            return [nonce, userState];\n        };\n        /**\n         * @protected\n         * @param {?} nonceInState\n         * @return {?}\n         */\n        OAuthService.prototype.validateNonce = /**\n         * @protected\n         * @param {?} nonceInState\n         * @return {?}\n         */\n        function (nonceInState) {\n            /** @type {?} */\n            var savedNonce = this._storage.getItem('nonce');\n            if (savedNonce !== nonceInState) {\n                /** @type {?} */\n                var err = 'Validating access_token failed, wrong state/nonce.';\n                console.error(err, savedNonce, nonceInState);\n                return false;\n            }\n            return true;\n        };\n        /**\n         * @protected\n         * @param {?} idToken\n         * @return {?}\n         */\n        OAuthService.prototype.storeIdToken = /**\n         * @protected\n         * @param {?} idToken\n         * @return {?}\n         */\n        function (idToken) {\n            this._storage.setItem('id_token', idToken.idToken);\n            this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n            this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n            this._storage.setItem('id_token_stored_at', '' + Date.now());\n        };\n        /**\n         * @protected\n         * @param {?} sessionState\n         * @return {?}\n         */\n        OAuthService.prototype.storeSessionState = /**\n         * @protected\n         * @param {?} sessionState\n         * @return {?}\n         */\n        function (sessionState) {\n            this._storage.setItem('session_state', sessionState);\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.getSessionState = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            return this._storage.getItem('session_state');\n        };\n        /**\n         * @protected\n         * @param {?} options\n         * @param {?} parts\n         * @return {?}\n         */\n        OAuthService.prototype.handleLoginError = /**\n         * @protected\n         * @param {?} options\n         * @param {?} parts\n         * @return {?}\n         */\n        function (options, parts) {\n            if (options.onLoginError) {\n                options.onLoginError(parts);\n            }\n            if (this.clearHashAfterLogin) {\n                location.hash = '';\n            }\n        };\n        /**\n         * @ignore\n         */\n        /**\n         * @ignore\n         * @param {?} idToken\n         * @param {?} accessToken\n         * @param {?=} skipNonceCheck\n         * @return {?}\n         */\n        OAuthService.prototype.processIdToken = /**\n         * @ignore\n         * @param {?} idToken\n         * @param {?} accessToken\n         * @param {?=} skipNonceCheck\n         * @return {?}\n         */\n        function (idToken, accessToken, skipNonceCheck) {\n            var _this = this;\n            if (skipNonceCheck === void 0) { skipNonceCheck = false; }\n            /** @type {?} */\n            var tokenParts = idToken.split('.');\n            /** @type {?} */\n            var headerBase64 = this.padBase64(tokenParts[0]);\n            /** @type {?} */\n            var headerJson = b64DecodeUnicode(headerBase64);\n            /** @type {?} */\n            var header = JSON.parse(headerJson);\n            /** @type {?} */\n            var claimsBase64 = this.padBase64(tokenParts[1]);\n            /** @type {?} */\n            var claimsJson = b64DecodeUnicode(claimsBase64);\n            /** @type {?} */\n            var claims = JSON.parse(claimsJson);\n            /** @type {?} */\n            var savedNonce = this._storage.getItem('nonce');\n            if (Array.isArray(claims.aud)) {\n                if (claims.aud.every((/**\n                 * @param {?} v\n                 * @return {?}\n                 */\n                function (v) { return v !== _this.clientId; }))) {\n                    /** @type {?} */\n                    var err = 'Wrong audience: ' + claims.aud.join(',');\n                    this.logger.warn(err);\n                    return Promise.reject(err);\n                }\n            }\n            else {\n                if (claims.aud !== this.clientId) {\n                    /** @type {?} */\n                    var err = 'Wrong audience: ' + claims.aud;\n                    this.logger.warn(err);\n                    return Promise.reject(err);\n                }\n            }\n            if (!claims.sub) {\n                /** @type {?} */\n                var err = 'No sub claim in id_token';\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n            /* For now, we only check whether the sub against\n             * silentRefreshSubject when sessionChecksEnabled is on\n             * We will reconsider in a later version to do this\n             * in every other case too.\n             */\n            if (this.sessionChecksEnabled &&\n                this.silentRefreshSubject &&\n                this.silentRefreshSubject !== claims['sub']) {\n                /** @type {?} */\n                var err = 'After refreshing, we got an id_token for another user (sub). ' +\n                    (\"Expected sub: \" + this.silentRefreshSubject + \", received sub: \" + claims['sub']);\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n            if (!claims.iat) {\n                /** @type {?} */\n                var err = 'No iat claim in id_token';\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n            if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n                /** @type {?} */\n                var err = 'Wrong issuer: ' + claims.iss;\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n            if (!skipNonceCheck && claims.nonce !== savedNonce) {\n                /** @type {?} */\n                var err = 'Wrong nonce: ' + claims.nonce;\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n            if (!this.disableAtHashCheck &&\n                this.requestAccessToken &&\n                !claims['at_hash']) {\n                /** @type {?} */\n                var err = 'An at_hash is needed!';\n                this.logger.warn(err);\n                return Promise.reject(err);\n            }\n            /** @type {?} */\n            var now = Date.now();\n            /** @type {?} */\n            var issuedAtMSec = claims.iat * 1000;\n            /** @type {?} */\n            var expiresAtMSec = claims.exp * 1000;\n            /** @type {?} */\n            var clockSkewInMSec = (this.clockSkewInSec || 600) * 1000;\n            if (issuedAtMSec - clockSkewInMSec >= now ||\n                expiresAtMSec + clockSkewInMSec <= now) {\n                /** @type {?} */\n                var err = 'Token has expired';\n                console.error(err);\n                console.error({\n                    now: now,\n                    issuedAtMSec: issuedAtMSec,\n                    expiresAtMSec: expiresAtMSec\n                });\n                return Promise.reject(err);\n            }\n            /** @type {?} */\n            var validationParams = {\n                accessToken: accessToken,\n                idToken: idToken,\n                jwks: this.jwks,\n                idTokenClaims: claims,\n                idTokenHeader: header,\n                loadKeys: (/**\n                 * @return {?}\n                 */\n                function () { return _this.loadJwks(); })\n            };\n            return this.checkAtHash(validationParams)\n                .then((/**\n             * @param {?} atHashValid\n             * @return {?}\n             */\n            function (atHashValid) {\n                if (!_this.disableAtHashCheck &&\n                    _this.requestAccessToken &&\n                    !atHashValid) {\n                    /** @type {?} */\n                    var err = 'Wrong at_hash';\n                    _this.logger.warn(err);\n                    return Promise.reject(err);\n                }\n                return _this.checkSignature(validationParams).then((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                function (_) {\n                    /** @type {?} */\n                    var result = {\n                        idToken: idToken,\n                        idTokenClaims: claims,\n                        idTokenClaimsJson: claimsJson,\n                        idTokenHeader: header,\n                        idTokenHeaderJson: headerJson,\n                        idTokenExpiresAt: expiresAtMSec\n                    };\n                    return result;\n                }));\n            }));\n        };\n        /**\n         * Returns the received claims about the user.\n         */\n        /**\n         * Returns the received claims about the user.\n         * @return {?}\n         */\n        OAuthService.prototype.getIdentityClaims = /**\n         * Returns the received claims about the user.\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var claims = this._storage.getItem('id_token_claims_obj');\n            if (!claims) {\n                return null;\n            }\n            return JSON.parse(claims);\n        };\n        /**\n         * Returns the granted scopes from the server.\n         */\n        /**\n         * Returns the granted scopes from the server.\n         * @return {?}\n         */\n        OAuthService.prototype.getGrantedScopes = /**\n         * Returns the granted scopes from the server.\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var scopes = this._storage.getItem('granted_scopes');\n            if (!scopes) {\n                return null;\n            }\n            return JSON.parse(scopes);\n        };\n        /**\n         * Returns the current id_token.\n         */\n        /**\n         * Returns the current id_token.\n         * @return {?}\n         */\n        OAuthService.prototype.getIdToken = /**\n         * Returns the current id_token.\n         * @return {?}\n         */\n        function () {\n            return this._storage\n                ? this._storage.getItem('id_token')\n                : null;\n        };\n        /**\n         * @protected\n         * @param {?} base64data\n         * @return {?}\n         */\n        OAuthService.prototype.padBase64 = /**\n         * @protected\n         * @param {?} base64data\n         * @return {?}\n         */\n        function (base64data) {\n            while (base64data.length % 4 !== 0) {\n                base64data += '=';\n            }\n            return base64data;\n        };\n        /**\n         * Returns the current access_token.\n         */\n        /**\n         * Returns the current access_token.\n         * @return {?}\n         */\n        OAuthService.prototype.getAccessToken = /**\n         * Returns the current access_token.\n         * @return {?}\n         */\n        function () {\n            return this._storage\n                ? this._storage.getItem('access_token')\n                : null;\n        };\n        /**\n         * @return {?}\n         */\n        OAuthService.prototype.getRefreshToken = /**\n         * @return {?}\n         */\n        function () {\n            return this._storage\n                ? this._storage.getItem('refresh_token')\n                : null;\n        };\n        /**\n         * Returns the expiration date of the access_token\n         * as milliseconds since 1970.\n         */\n        /**\n         * Returns the expiration date of the access_token\n         * as milliseconds since 1970.\n         * @return {?}\n         */\n        OAuthService.prototype.getAccessTokenExpiration = /**\n         * Returns the expiration date of the access_token\n         * as milliseconds since 1970.\n         * @return {?}\n         */\n        function () {\n            if (!this._storage.getItem('expires_at')) {\n                return null;\n            }\n            return parseInt(this._storage.getItem('expires_at'), 10);\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.getAccessTokenStoredAt = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.getIdTokenStoredAt = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n        };\n        /**\n         * Returns the expiration date of the id_token\n         * as milliseconds since 1970.\n         */\n        /**\n         * Returns the expiration date of the id_token\n         * as milliseconds since 1970.\n         * @return {?}\n         */\n        OAuthService.prototype.getIdTokenExpiration = /**\n         * Returns the expiration date of the id_token\n         * as milliseconds since 1970.\n         * @return {?}\n         */\n        function () {\n            if (!this._storage.getItem('id_token_expires_at')) {\n                return null;\n            }\n            return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n        };\n        /**\n         * Checkes, whether there is a valid access_token.\n         */\n        /**\n         * Checkes, whether there is a valid access_token.\n         * @return {?}\n         */\n        OAuthService.prototype.hasValidAccessToken = /**\n         * Checkes, whether there is a valid access_token.\n         * @return {?}\n         */\n        function () {\n            if (this.getAccessToken()) {\n                /** @type {?} */\n                var expiresAt = this._storage.getItem('expires_at');\n                /** @type {?} */\n                var now = new Date();\n                if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Checks whether there is a valid id_token.\n         */\n        /**\n         * Checks whether there is a valid id_token.\n         * @return {?}\n         */\n        OAuthService.prototype.hasValidIdToken = /**\n         * Checks whether there is a valid id_token.\n         * @return {?}\n         */\n        function () {\n            if (this.getIdToken()) {\n                /** @type {?} */\n                var expiresAt = this._storage.getItem('id_token_expires_at');\n                /** @type {?} */\n                var now = new Date();\n                if (expiresAt && parseInt(expiresAt, 10) < now.getTime()) {\n                    return false;\n                }\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Returns the auth-header that can be used\n         * to transmit the access_token to a service\n         */\n        /**\n         * Returns the auth-header that can be used\n         * to transmit the access_token to a service\n         * @return {?}\n         */\n        OAuthService.prototype.authorizationHeader = /**\n         * Returns the auth-header that can be used\n         * to transmit the access_token to a service\n         * @return {?}\n         */\n        function () {\n            return 'Bearer ' + this.getAccessToken();\n        };\n        /**\n         * Removes all tokens and logs the user out.\n         * If a logout url is configured, the user is\n         * redirected to it.\n         * @param noRedirectToLogoutUrl\n         */\n        /**\n         * Removes all tokens and logs the user out.\n         * If a logout url is configured, the user is\n         * redirected to it.\n         * @param {?=} noRedirectToLogoutUrl\n         * @return {?}\n         */\n        OAuthService.prototype.logOut = /**\n         * Removes all tokens and logs the user out.\n         * If a logout url is configured, the user is\n         * redirected to it.\n         * @param {?=} noRedirectToLogoutUrl\n         * @return {?}\n         */\n        function (noRedirectToLogoutUrl) {\n            if (noRedirectToLogoutUrl === void 0) { noRedirectToLogoutUrl = false; }\n            /** @type {?} */\n            var id_token = this.getIdToken();\n            this._storage.removeItem('access_token');\n            this._storage.removeItem('id_token');\n            this._storage.removeItem('refresh_token');\n            this._storage.removeItem('nonce');\n            this._storage.removeItem('expires_at');\n            this._storage.removeItem('id_token_claims_obj');\n            this._storage.removeItem('id_token_expires_at');\n            this._storage.removeItem('id_token_stored_at');\n            this._storage.removeItem('access_token_stored_at');\n            this._storage.removeItem('granted_scopes');\n            this._storage.removeItem('session_state');\n            this.silentRefreshSubject = null;\n            this.eventsSubject.next(new OAuthInfoEvent('logout'));\n            if (!this.logoutUrl) {\n                return;\n            }\n            if (noRedirectToLogoutUrl) {\n                return;\n            }\n            if (!id_token && !this.postLogoutRedirectUri) {\n                return;\n            }\n            /** @type {?} */\n            var logoutUrl;\n            if (!this.validateUrlForHttps(this.logoutUrl)) {\n                throw new Error('logoutUrl must use https, or config value for property requireHttps must allow http');\n            }\n            // For backward compatibility\n            if (this.logoutUrl.indexOf('{{') > -1) {\n                logoutUrl = this.logoutUrl\n                    .replace(/\\{\\{id_token\\}\\}/, id_token)\n                    .replace(/\\{\\{client_id\\}\\}/, this.clientId);\n            }\n            else {\n                /** @type {?} */\n                var params = new http.HttpParams();\n                if (id_token) {\n                    params = params.set('id_token_hint', id_token);\n                }\n                /** @type {?} */\n                var postLogoutUrl = this.postLogoutRedirectUri || this.redirectUri;\n                if (postLogoutUrl) {\n                    params = params.set('post_logout_redirect_uri', postLogoutUrl);\n                }\n                logoutUrl =\n                    this.logoutUrl +\n                        (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') +\n                        params.toString();\n            }\n            this.config.openUri(logoutUrl);\n        };\n        /**\n         * @ignore\n         */\n        /**\n         * @ignore\n         * @return {?}\n         */\n        OAuthService.prototype.createAndSaveNonce = /**\n         * @ignore\n         * @return {?}\n         */\n        function () {\n            /** @type {?} */\n            var that = this;\n            return this.createNonce().then((/**\n             * @param {?} nonce\n             * @return {?}\n             */\n            function (nonce) {\n                that._storage.setItem('nonce', nonce);\n                return nonce;\n            }));\n        };\n        /**\n         * @ignore\n         */\n        /**\n         * @ignore\n         * @return {?}\n         */\n        OAuthService.prototype.ngOnDestroy = /**\n         * @ignore\n         * @return {?}\n         */\n        function () {\n            this.clearAccessTokenTimer();\n            this.clearIdTokenTimer();\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.createNonce = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _this = this;\n            return new Promise((/**\n             * @param {?} resolve\n             * @return {?}\n             */\n            function (resolve) {\n                if (_this.rngUrl) {\n                    throw new Error('createNonce with rng-web-api has not been implemented so far');\n                }\n                /*\n                             * This alphabet uses a-z A-Z 0-9 _- symbols.\n                             * Symbols order was changed for better gzip compression.\n                             */\n                /** @type {?} */\n                var url = 'Uint8ArdomValuesObj012345679BCDEFGHIJKLMNPQRSTWXYZ_cfghkpqvwxyz-';\n                /** @type {?} */\n                var size = 45;\n                /** @type {?} */\n                var id = '';\n                /** @type {?} */\n                var crypto = self.crypto || self['msCrypto'];\n                if (crypto) {\n                    /** @type {?} */\n                    var bytes = crypto.getRandomValues(new Uint8Array(size));\n                    while (0 < size--) {\n                        id += url[bytes[size] & 63];\n                    }\n                }\n                else {\n                    while (0 < size--) {\n                        id += url[Math.random() * 64 | 0];\n                    }\n                }\n                resolve(id);\n            }));\n        };\n        /**\n         * @protected\n         * @param {?} params\n         * @return {?}\n         */\n        OAuthService.prototype.checkAtHash = /**\n         * @protected\n         * @param {?} params\n         * @return {?}\n         */\n        function (params) {\n            return __awaiter(this, void 0, void 0, function () {\n                return __generator(this, function (_a) {\n                    if (!this.tokenValidationHandler) {\n                        this.logger.warn('No tokenValidationHandler configured. Cannot check at_hash.');\n                        return [2 /*return*/, true];\n                    }\n                    return [2 /*return*/, this.tokenValidationHandler.validateAtHash(params)];\n                });\n            });\n        };\n        /**\n         * @protected\n         * @param {?} params\n         * @return {?}\n         */\n        OAuthService.prototype.checkSignature = /**\n         * @protected\n         * @param {?} params\n         * @return {?}\n         */\n        function (params) {\n            if (!this.tokenValidationHandler) {\n                this.logger.warn('No tokenValidationHandler configured. Cannot check signature.');\n                return Promise.resolve(null);\n            }\n            return this.tokenValidationHandler.validateSignature(params);\n        };\n        /**\n         * Start the implicit flow or the code flow,\n         * depending on your configuration.\n         */\n        /**\n         * Start the implicit flow or the code flow,\n         * depending on your configuration.\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        OAuthService.prototype.initLoginFlow = /**\n         * Start the implicit flow or the code flow,\n         * depending on your configuration.\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        function (additionalState, params) {\n            if (additionalState === void 0) { additionalState = ''; }\n            if (params === void 0) { params = {}; }\n            if (this.responseType === 'code') {\n                return this.initCodeFlow(additionalState, params);\n            }\n            else {\n                return this.initImplicitFlow(additionalState, params);\n            }\n        };\n        /**\n         * Starts the authorization code flow and redirects to user to\n         * the auth servers login url.\n         */\n        /**\n         * Starts the authorization code flow and redirects to user to\n         * the auth servers login url.\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        OAuthService.prototype.initCodeFlow = /**\n         * Starts the authorization code flow and redirects to user to\n         * the auth servers login url.\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        function (additionalState, params) {\n            var _this = this;\n            if (additionalState === void 0) { additionalState = ''; }\n            if (params === void 0) { params = {}; }\n            if (this.loginUrl !== '') {\n                this.initCodeFlowInternal(additionalState, params);\n            }\n            else {\n                this.events.pipe(operators.filter((/**\n                 * @param {?} e\n                 * @return {?}\n                 */\n                function (e) { return e.type === 'discovery_document_loaded'; })))\n                    .subscribe((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                function (_) { return _this.initCodeFlowInternal(additionalState, params); }));\n            }\n        };\n        /**\n         * @private\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        OAuthService.prototype.initCodeFlowInternal = /**\n         * @private\n         * @param {?=} additionalState\n         * @param {?=} params\n         * @return {?}\n         */\n        function (additionalState, params) {\n            if (additionalState === void 0) { additionalState = ''; }\n            if (params === void 0) { params = {}; }\n            if (!this.validateUrlForHttps(this.loginUrl)) {\n                throw new Error('loginUrl must use Http. Also check property requireHttps.');\n            }\n            this.createLoginUrl(additionalState, '', null, false, params).then((/**\n             * @param {?} url\n             * @return {?}\n             */\n            function (url) {\n                location.href = url;\n            }))\n                .catch((/**\n             * @param {?} error\n             * @return {?}\n             */\n            function (error) {\n                console.error('Error in initAuthorizationCodeFlow');\n                console.error(error);\n            }));\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        OAuthService.prototype.createChallangeVerifierPairForPKCE = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            return __awaiter(this, void 0, void 0, function () {\n                var verifier, challengeRaw, challange;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            if (!this.crypto) {\n                                throw new Error('PKCI support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\n                            }\n                            return [4 /*yield*/, this.createNonce()];\n                        case 1:\n                            verifier = _a.sent();\n                            return [4 /*yield*/, this.crypto.calcHash(verifier, 'sha-256')];\n                        case 2:\n                            challengeRaw = _a.sent();\n                            challange = base64UrlEncode(challengeRaw);\n                            return [2 /*return*/, [challange, verifier]];\n                    }\n                });\n            });\n        };\n        OAuthService.decorators = [\n            { type: core.Injectable }\n        ];\n        /** @nocollapse */\n        OAuthService.ctorParameters = function () { return [\n            { type: core.NgZone },\n            { type: http.HttpClient },\n            { type: OAuthStorage, decorators: [{ type: core.Optional }] },\n            { type: ValidationHandler, decorators: [{ type: core.Optional }] },\n            { type: AuthConfig, decorators: [{ type: core.Optional }] },\n            { type: UrlHelperService },\n            { type: OAuthLogger },\n            { type: CryptoHandler, decorators: [{ type: core.Optional }] }\n        ]; };\n        return OAuthService;\n    }(AuthConfig));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var   /**\n     * @abstract\n     */\n    OAuthModuleConfig = /** @class */ (function () {\n        function OAuthModuleConfig() {\n        }\n        return OAuthModuleConfig;\n    }());\n    /**\n     * @abstract\n     */\n    var   /**\n     * @abstract\n     */\n    OAuthResourceServerConfig = /** @class */ (function () {\n        function OAuthResourceServerConfig() {\n        }\n        return OAuthResourceServerConfig;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @abstract\n     */\n    var   /**\n     * @abstract\n     */\n    OAuthResourceServerErrorHandler = /** @class */ (function () {\n        function OAuthResourceServerErrorHandler() {\n        }\n        return OAuthResourceServerErrorHandler;\n    }());\n    var OAuthNoopResourceServerErrorHandler = /** @class */ (function () {\n        function OAuthNoopResourceServerErrorHandler() {\n        }\n        /**\n         * @param {?} err\n         * @return {?}\n         */\n        OAuthNoopResourceServerErrorHandler.prototype.handleError = /**\n         * @param {?} err\n         * @return {?}\n         */\n        function (err) {\n            return rxjs.throwError(err);\n        };\n        return OAuthNoopResourceServerErrorHandler;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var DefaultOAuthInterceptor = /** @class */ (function () {\n        function DefaultOAuthInterceptor(authStorage, oAuthService, errorHandler, moduleConfig) {\n            this.authStorage = authStorage;\n            this.oAuthService = oAuthService;\n            this.errorHandler = errorHandler;\n            this.moduleConfig = moduleConfig;\n        }\n        /**\n         * @private\n         * @param {?} url\n         * @return {?}\n         */\n        DefaultOAuthInterceptor.prototype.checkUrl = /**\n         * @private\n         * @param {?} url\n         * @return {?}\n         */\n        function (url) {\n            if (this.moduleConfig.resourceServer.customUrlValidation) {\n                return this.moduleConfig.resourceServer.customUrlValidation(url);\n            }\n            if (this.moduleConfig.resourceServer.allowedUrls) {\n                return !!this.moduleConfig.resourceServer.allowedUrls.find((/**\n                 * @param {?} u\n                 * @return {?}\n                 */\n                function (u) { return url.startsWith(u); }));\n            }\n            return true;\n        };\n        /**\n         * @param {?} req\n         * @param {?} next\n         * @return {?}\n         */\n        DefaultOAuthInterceptor.prototype.intercept = /**\n         * @param {?} req\n         * @param {?} next\n         * @return {?}\n         */\n        function (req, next) {\n            var _this = this;\n            /** @type {?} */\n            var url = req.url.toLowerCase();\n            if (!this.moduleConfig) {\n                return next.handle(req);\n            }\n            if (!this.moduleConfig.resourceServer) {\n                return next.handle(req);\n            }\n            if (this.moduleConfig.resourceServer.allowedUrls && !this.checkUrl(url)) {\n                return next.handle(req);\n            }\n            /** @type {?} */\n            var sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n            if (!sendAccessToken) {\n                return next\n                    .handle(req)\n                    .pipe(operators.catchError((/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) { return _this.errorHandler.handleError(err); })));\n            }\n            return rxjs.merge(rxjs.of(this.oAuthService.getAccessToken()).pipe(operators.filter((/**\n             * @param {?} token\n             * @return {?}\n             */\n            function (token) { return token ? true : false; }))), this.oAuthService.events.pipe(operators.filter((/**\n             * @param {?} e\n             * @return {?}\n             */\n            function (e) { return e.type === 'token_received'; })), operators.timeout(this.oAuthService.waitForTokenInMsec || 0), operators.catchError((/**\n             * @param {?} _\n             * @return {?}\n             */\n            function (_) { return rxjs.of(null); })), // timeout is not an error\n            operators.map((/**\n             * @param {?} _\n             * @return {?}\n             */\n            function (_) { return _this.oAuthService.getAccessToken(); })))).pipe(operators.take(1), operators.mergeMap((/**\n             * @param {?} token\n             * @return {?}\n             */\n            function (token) {\n                if (token) {\n                    /** @type {?} */\n                    var header = 'Bearer ' + token;\n                    /** @type {?} */\n                    var headers = req.headers.set('Authorization', header);\n                    req = req.clone({ headers: headers });\n                }\n                return next\n                    .handle(req)\n                    .pipe(operators.catchError((/**\n                 * @param {?} err\n                 * @return {?}\n                 */\n                function (err) { return _this.errorHandler.handleError(err); })));\n            })));\n        };\n        DefaultOAuthInterceptor.decorators = [\n            { type: core.Injectable }\n        ];\n        /** @nocollapse */\n        DefaultOAuthInterceptor.ctorParameters = function () { return [\n            { type: OAuthStorage },\n            { type: OAuthService },\n            { type: OAuthResourceServerErrorHandler },\n            { type: OAuthModuleConfig, decorators: [{ type: core.Optional }] }\n        ]; };\n        return DefaultOAuthInterceptor;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * A validation handler that isn't validating nothing.\n     * Can be used to skip validation (at your own risk).\n     */\n    var   /**\n     * A validation handler that isn't validating nothing.\n     * Can be used to skip validation (at your own risk).\n     */\n    NullValidationHandler = /** @class */ (function () {\n        function NullValidationHandler() {\n        }\n        /**\n         * @param {?} validationParams\n         * @return {?}\n         */\n        NullValidationHandler.prototype.validateSignature = /**\n         * @param {?} validationParams\n         * @return {?}\n         */\n        function (validationParams) {\n            return Promise.resolve(null);\n        };\n        /**\n         * @param {?} validationParams\n         * @return {?}\n         */\n        NullValidationHandler.prototype.validateAtHash = /**\n         * @param {?} validationParams\n         * @return {?}\n         */\n        function (validationParams) {\n            return Promise.resolve(true);\n        };\n        return NullValidationHandler;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * @return {?}\n     */\n    function createDefaultLogger() {\n        return console;\n    }\n    /**\n     * @return {?}\n     */\n    function createDefaultStorage() {\n        return typeof sessionStorage !== 'undefined' ? sessionStorage : null;\n    }\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * Validates the signature of an id_token against one\n     * of the keys of an JSON Web Key Set (jwks).\n     *\n     * This jwks can be provided by the discovery document.\n     */\n    var   /**\n     * Validates the signature of an id_token against one\n     * of the keys of an JSON Web Key Set (jwks).\n     *\n     * This jwks can be provided by the discovery document.\n     */\n    JwksValidationHandler = /** @class */ (function (_super) {\n        __extends(JwksValidationHandler, _super);\n        function JwksValidationHandler() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            /**\n             * Allowed algorithms\n             */\n            _this.allowedAlgorithms = [\n                'HS256',\n                'HS384',\n                'HS512',\n                'RS256',\n                'RS384',\n                'RS512',\n                'ES256',\n                'ES384',\n                'PS256',\n                'PS384',\n                'PS512'\n            ];\n            /**\n             * Time period in seconds the timestamp in the signature can\n             * differ from the current time.\n             */\n            _this.gracePeriodInSec = 600;\n            return _this;\n        }\n        /**\n         * @param {?} params\n         * @param {?=} retry\n         * @return {?}\n         */\n        JwksValidationHandler.prototype.validateSignature = /**\n         * @param {?} params\n         * @param {?=} retry\n         * @return {?}\n         */\n        function (params, retry) {\n            var _this = this;\n            if (retry === void 0) { retry = false; }\n            if (!params.idToken)\n                throw new Error('Parameter idToken expected!');\n            if (!params.idTokenHeader)\n                throw new Error('Parameter idTokenHandler expected.');\n            if (!params.jwks)\n                throw new Error('Parameter jwks expected!');\n            if (!params.jwks['keys'] ||\n                !Array.isArray(params.jwks['keys']) ||\n                params.jwks['keys'].length === 0) {\n                throw new Error('Array keys in jwks missing!');\n            }\n            // console.debug('validateSignature: retry', retry);\n            /** @type {?} */\n            var kid = params.idTokenHeader['kid'];\n            /** @type {?} */\n            var keys = params.jwks['keys'];\n            /** @type {?} */\n            var key;\n            /** @type {?} */\n            var alg = params.idTokenHeader['alg'];\n            if (kid) {\n                key = keys.find((/**\n                 * @param {?} k\n                 * @return {?}\n                 */\n                function (k) { return k['kid'] === kid; } /* && k['use'] === 'sig' */));\n            }\n            else {\n                /** @type {?} */\n                var kty_1 = this.alg2kty(alg);\n                /** @type {?} */\n                var matchingKeys = keys.filter((/**\n                 * @param {?} k\n                 * @return {?}\n                 */\n                function (k) { return k['kty'] === kty_1 && k['use'] === 'sig'; }));\n                /*\n                      if (matchingKeys.length == 0) {\n                          let error = 'No matching key found.';\n                          console.error(error);\n                          return Promise.reject(error);\n                      }*/\n                if (matchingKeys.length > 1) {\n                    /** @type {?} */\n                    var error = 'More than one matching key found. Please specify a kid in the id_token header.';\n                    console.error(error);\n                    return Promise.reject(error);\n                }\n                else if (matchingKeys.length === 1) {\n                    key = matchingKeys[0];\n                }\n            }\n            if (!key && !retry && params.loadKeys) {\n                return params\n                    .loadKeys()\n                    .then((/**\n                 * @param {?} loadedKeys\n                 * @return {?}\n                 */\n                function (loadedKeys) { return (params.jwks = loadedKeys); }))\n                    .then((/**\n                 * @param {?} _\n                 * @return {?}\n                 */\n                function (_) { return _this.validateSignature(params, true); }));\n            }\n            if (!key && retry && !kid) {\n                /** @type {?} */\n                var error = 'No matching key found.';\n                console.error(error);\n                return Promise.reject(error);\n            }\n            if (!key && retry && kid) {\n                /** @type {?} */\n                var error = 'expected key not found in property jwks. ' +\n                    'This property is most likely loaded with the ' +\n                    'discovery document. ' +\n                    'Expected key id (kid): ' +\n                    kid;\n                console.error(error);\n                return Promise.reject(error);\n            }\n            /** @type {?} */\n            var keyObj = jsrsasign.KEYUTIL.getKey(key);\n            /** @type {?} */\n            var validationOptions = {\n                alg: this.allowedAlgorithms,\n                gracePeriod: this.gracePeriodInSec\n            };\n            /** @type {?} */\n            var isValid = jsrsasign.KJUR.jws.JWS.verifyJWT(params.idToken, keyObj, validationOptions);\n            if (isValid) {\n                return Promise.resolve();\n            }\n            else {\n                return Promise.reject('Signature not valid');\n            }\n        };\n        /**\n         * @private\n         * @param {?} alg\n         * @return {?}\n         */\n        JwksValidationHandler.prototype.alg2kty = /**\n         * @private\n         * @param {?} alg\n         * @return {?}\n         */\n        function (alg) {\n            switch (alg.charAt(0)) {\n                case 'R':\n                    return 'RSA';\n                case 'E':\n                    return 'EC';\n                default:\n                    throw new Error('Cannot infer kty from alg: ' + alg);\n            }\n        };\n        /**\n         * @param {?} valueToHash\n         * @param {?} algorithm\n         * @return {?}\n         */\n        JwksValidationHandler.prototype.calcHash = /**\n         * @param {?} valueToHash\n         * @param {?} algorithm\n         * @return {?}\n         */\n        function (valueToHash, algorithm) {\n            /** @type {?} */\n            var hashAlg = new jsrsasign.KJUR.crypto.MessageDigest({ alg: algorithm });\n            /** @type {?} */\n            var result = hashAlg.digestString(valueToHash);\n            /** @type {?} */\n            var byteArrayAsString = this.toByteArrayAsString(result);\n            return Promise.resolve(byteArrayAsString);\n        };\n        /**\n         * @param {?} hexString\n         * @return {?}\n         */\n        JwksValidationHandler.prototype.toByteArrayAsString = /**\n         * @param {?} hexString\n         * @return {?}\n         */\n        function (hexString) {\n            /** @type {?} */\n            var result = '';\n            for (var i = 0; i < hexString.length; i += 2) {\n                /** @type {?} */\n                var hexDigit = hexString.charAt(i) + hexString.charAt(i + 1);\n                /** @type {?} */\n                var num = parseInt(hexDigit, 16);\n                result += String.fromCharCode(num);\n            }\n            return result;\n        };\n        return JwksValidationHandler;\n    }(AbstractValidationHandler));\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var OAuthModule = /** @class */ (function () {\n        function OAuthModule() {\n        }\n        /**\n         * @param {?=} config\n         * @param {?=} validationHandlerClass\n         * @return {?}\n         */\n        OAuthModule.forRoot = /**\n         * @param {?=} config\n         * @param {?=} validationHandlerClass\n         * @return {?}\n         */\n        function (config, validationHandlerClass) {\n            if (config === void 0) { config = null; }\n            if (validationHandlerClass === void 0) { validationHandlerClass = NullValidationHandler; }\n            return {\n                ngModule: OAuthModule,\n                providers: [\n                    OAuthService,\n                    UrlHelperService,\n                    { provide: OAuthLogger, useFactory: createDefaultLogger },\n                    { provide: OAuthStorage, useFactory: createDefaultStorage },\n                    { provide: ValidationHandler, useClass: validationHandlerClass },\n                    { provide: CryptoHandler, useClass: JwksValidationHandler },\n                    {\n                        provide: OAuthResourceServerErrorHandler,\n                        useClass: OAuthNoopResourceServerErrorHandler\n                    },\n                    { provide: OAuthModuleConfig, useValue: config },\n                    {\n                        provide: http.HTTP_INTERCEPTORS,\n                        useClass: DefaultOAuthInterceptor,\n                        multi: true\n                    }\n                ]\n            };\n        };\n        OAuthModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [common.CommonModule],\n                        declarations: [],\n                        exports: []\n                    },] }\n        ];\n        return OAuthModule;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /** @type {?} */\n    var AUTH_CONFIG = new core.InjectionToken('AUTH_CONFIG');\n\n    exports.AUTH_CONFIG = AUTH_CONFIG;\n    exports.AbstractValidationHandler = AbstractValidationHandler;\n    exports.AuthConfig = AuthConfig;\n    exports.DefaultOAuthInterceptor = DefaultOAuthInterceptor;\n    exports.JwksValidationHandler = JwksValidationHandler;\n    exports.LoginOptions = LoginOptions;\n    exports.NullValidationHandler = NullValidationHandler;\n    exports.OAuthErrorEvent = OAuthErrorEvent;\n    exports.OAuthEvent = OAuthEvent;\n    exports.OAuthInfoEvent = OAuthInfoEvent;\n    exports.OAuthLogger = OAuthLogger;\n    exports.OAuthModule = OAuthModule;\n    exports.OAuthModuleConfig = OAuthModuleConfig;\n    exports.OAuthNoopResourceServerErrorHandler = OAuthNoopResourceServerErrorHandler;\n    exports.OAuthResourceServerConfig = OAuthResourceServerConfig;\n    exports.OAuthResourceServerErrorHandler = OAuthResourceServerErrorHandler;\n    exports.OAuthService = OAuthService;\n    exports.OAuthStorage = OAuthStorage;\n    exports.OAuthSuccessEvent = OAuthSuccessEvent;\n    exports.ReceivedTokens = ReceivedTokens;\n    exports.UrlHelperService = UrlHelperService;\n    exports.ValidationHandler = ValidationHandler;\n    exports.ɵa = CryptoHandler;\n    exports.ɵb = createDefaultLogger;\n    exports.ɵc = createDefaultStorage;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"]}
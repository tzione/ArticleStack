{"version":3,"file":"oauth-service.d.ts","sources":["c:/Users/tzion/OneDrive/מסמכים/Private/ArticleStack-master/ArticleStack-master/node_modules/angular-oauth2-oidc/oauth-service.d.ts"],"sourcesContent":["import { NgZone, OnDestroy } from '@angular/core';\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\nimport { Observable, Subject, Subscription } from 'rxjs';\nimport { ValidationHandler, ValidationParams } from './token-validation/validation-handler';\nimport { UrlHelperService } from './url-helper.service';\nimport { OAuthEvent } from './events';\nimport { OAuthLogger, OAuthStorage, LoginOptions, ParsedIdToken, OidcDiscoveryDoc } from './types';\nimport { AuthConfig } from './auth.config';\nimport { CryptoHandler } from './token-validation/crypto-handler';\n/**\n * Service for logging in and logging out with\n * OIDC and OAuth2. Supports implicit flow and\n * password flow.\n */\nexport declare class OAuthService extends AuthConfig implements OnDestroy {\n    protected ngZone: NgZone;\n    protected http: HttpClient;\n    protected config: AuthConfig;\n    protected urlHelper: UrlHelperService;\n    protected logger: OAuthLogger;\n    protected crypto: CryptoHandler;\n    /**\n     * The ValidationHandler used to validate received\n     * id_tokens.\n     */\n    tokenValidationHandler: ValidationHandler;\n    /**\n     * @internal\n     * Deprecated:  use property events instead\n     */\n    discoveryDocumentLoaded: boolean;\n    /**\n     * @internal\n     * Deprecated:  use property events instead\n     */\n    discoveryDocumentLoaded$: Observable<object>;\n    /**\n     * Informs about events, like token_received or token_expires.\n     * See the string enum EventType for a full list of event types.\n     */\n    events: Observable<OAuthEvent>;\n    /**\n     * The received (passed around) state, when logging\n     * in with implicit flow.\n     */\n    state?: string;\n    protected eventsSubject: Subject<OAuthEvent>;\n    protected discoveryDocumentLoadedSubject: Subject<object>;\n    protected silentRefreshPostMessageEventListener: EventListener;\n    protected grantTypesSupported: Array<string>;\n    protected _storage: OAuthStorage;\n    protected accessTokenTimeoutSubscription: Subscription;\n    protected idTokenTimeoutSubscription: Subscription;\n    protected sessionCheckEventListener: EventListener;\n    protected jwksUri: string;\n    protected sessionCheckTimer: any;\n    protected silentRefreshSubject: string;\n    protected inImplicitFlow: boolean;\n    constructor(ngZone: NgZone, http: HttpClient, storage: OAuthStorage, tokenValidationHandler: ValidationHandler, config: AuthConfig, urlHelper: UrlHelperService, logger: OAuthLogger, crypto: CryptoHandler);\n    /**\n     * Use this method to configure the service\n     * @param config the configuration\n     */\n    configure(config: AuthConfig): void;\n    protected configChanged(): void;\n    restartSessionChecksIfStillLoggedIn(): void;\n    protected restartRefreshTimerIfStillLoggedIn(): void;\n    protected setupSessionCheck(): void;\n    /**\n     * Will setup up silent refreshing for when the token is\n     * about to expire. When the user is logged out via this.logOut method, the\n     * silent refreshing will pause and not refresh the tokens until the user is\n     * logged back in via receiving a new token.\n     * @param params Additional parameter to pass\n     * @param listenTo Setup automatic refresh of a specific token type\n     */\n    setupAutomaticSilentRefresh(params?: object, listenTo?: 'access_token' | 'id_token' | 'any', noPrompt?: boolean): void;\n    protected refreshInternal(params: any, noPrompt: any): Promise<object>;\n    /**\n     * Convenience method that first calls `loadDiscoveryDocument(...)` and\n     * directly chains using the `then(...)` part of the promise to call\n     * the `tryLogin(...)` method.\n     *\n     * @param options LoginOptions to pass through to `tryLogin(...)`\n     */\n    loadDiscoveryDocumentAndTryLogin(options?: LoginOptions): Promise<boolean>;\n    /**\n     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\n     * and if then chains to `initImplicitFlow()`, but only if there is no valid\n     * IdToken or no valid AccessToken.\n     *\n     * @param options LoginOptions to pass through to `tryLogin(...)`\n     */\n    loadDiscoveryDocumentAndLogin(options?: LoginOptions): Promise<boolean>;\n    protected debug(...args: any[]): void;\n    protected validateUrlFromDiscoveryDocument(url: string): string[];\n    protected validateUrlForHttps(url: string): boolean;\n    protected validateUrlAgainstIssuer(url: string): boolean;\n    protected setupRefreshTimer(): void;\n    protected setupExpirationTimers(): void;\n    protected setupAccessTokenTimer(): void;\n    protected setupIdTokenTimer(): void;\n    protected clearAccessTokenTimer(): void;\n    protected clearIdTokenTimer(): void;\n    protected calcTimeout(storedAt: number, expiration: number): number;\n    /**\n     * DEPRECATED. Use a provider for OAuthStorage instead:\n     *\n     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\n     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\n     * Sets a custom storage used to store the received\n     * tokens on client side. By default, the browser's\n     * sessionStorage is used.\n     * @ignore\n     *\n     * @param storage\n     */\n    setStorage(storage: OAuthStorage): void;\n    /**\n     * Loads the discovery document to configure most\n     * properties of this service. The url of the discovery\n     * document is infered from the issuer's url according\n     * to the OpenId Connect spec. To use another url you\n     * can pass it to to optional parameter fullUrl.\n     *\n     * @param fullUrl\n     */\n    loadDiscoveryDocument(fullUrl?: string): Promise<object>;\n    protected loadJwks(): Promise<object>;\n    protected validateDiscoveryDocument(doc: OidcDiscoveryDoc): boolean;\n    /**\n     * Uses password flow to exchange userName and password for an\n     * access_token. After receiving the access_token, this method\n     * uses it to query the userinfo endpoint in order to get information\n     * about the user in question.\n     *\n     * When using this, make sure that the property oidc is set to false.\n     * Otherwise stricter validations take place that make this operation\n     * fail.\n     *\n     * @param userName\n     * @param password\n     * @param headers Optional additional http-headers.\n     */\n    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName: string, password: string, headers?: HttpHeaders): Promise<object>;\n    /**\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\n     *\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\n     * Otherwise stricter validations take place that make this operation fail.\n     */\n    loadUserProfile(): Promise<object>;\n    /**\n     * Uses password flow to exchange userName and password for an access_token.\n     * @param userName\n     * @param password\n     * @param headers Optional additional http-headers.\n     */\n    fetchTokenUsingPasswordFlow(userName: string, password: string, headers?: HttpHeaders): Promise<object>;\n    /**\n     * Refreshes the token using a refresh_token.\n     * This does not work for implicit flow, b/c\n     * there is no refresh_token in this flow.\n     * A solution for this is provided by the\n     * method silentRefresh.\n     */\n    refreshToken(): Promise<object>;\n    protected removeSilentRefreshEventListener(): void;\n    protected setupSilentRefreshEventListener(): void;\n    /**\n     * Performs a silent refresh for implicit flow.\n     * Use this method to get new tokens when/before\n     * the existing tokens expire.\n     */\n    silentRefresh(params?: object, noPrompt?: boolean): Promise<OAuthEvent>;\n    initImplicitFlowInPopup(options?: {\n        height?: number;\n        width?: number;\n    }): Promise<{}>;\n    protected calculatePopupFeatures(options: {\n        height?: number;\n        width?: number;\n    }): string;\n    protected processMessageEventMessage(e: MessageEvent): string;\n    protected canPerformSessionCheck(): boolean;\n    protected setupSessionCheckEventListener(): void;\n    protected handleSessionUnchanged(): void;\n    protected handleSessionChange(): void;\n    protected waitForSilentRefreshAfterSessionChange(): void;\n    protected handleSessionError(): void;\n    protected removeSessionCheckEventListener(): void;\n    protected initSessionCheck(): void;\n    protected startSessionCheckTimer(): void;\n    protected stopSessionCheckTimer(): void;\n    protected checkSession(): void;\n    protected createLoginUrl(state?: string, loginHint?: string, customRedirectUri?: string, noPrompt?: boolean, params?: object): Promise<string>;\n    initImplicitFlowInternal(additionalState?: string, params?: string | object): void;\n    /**\n     * Starts the implicit flow and redirects to user to\n     * the auth servers' login url.\n     *\n     * @param additionalState Optional state that is passed around.\n     *  You'll find this state in the property `state` after `tryLogin` logged in the user.\n     * @param params Hash with additional parameter. If it is a string, it is used for the\n     *               parameter loginHint (for the sake of compatibility with former versions)\n     */\n    initImplicitFlow(additionalState?: string, params?: string | object): void;\n    /**\n     * Reset current implicit flow\n     *\n     * @description This method allows resetting the current implict flow in order to be initialized again.\n     */\n    resetImplicitFlow(): void;\n    protected callOnTokenReceivedIfExists(options: LoginOptions): void;\n    protected storeAccessTokenResponse(accessToken: string, refreshToken: string, expiresIn: number, grantedScopes: String): void;\n    /**\n     * Delegates to tryLoginImplicitFlow for the sake of competability\n     * @param options Optional options.\n     */\n    tryLogin(options?: LoginOptions): Promise<boolean>;\n    private parseQueryString;\n    tryLoginCodeFlow(): Promise<void>;\n    /**\n     * Get token using an intermediate code. Works for the Authorization Code flow.\n     */\n    private getTokenFromCode;\n    private fetchAndProcessToken;\n    /**\n     * Checks whether there are tokens in the hash fragment\n     * as a result of the implicit flow. These tokens are\n     * parsed, validated and used to sign the user in to the\n     * current client.\n     *\n     * @param options Optional options.\n     */\n    tryLoginImplicitFlow(options?: LoginOptions): Promise<boolean>;\n    private parseState;\n    protected validateNonce(nonceInState: string): boolean;\n    protected storeIdToken(idToken: ParsedIdToken): void;\n    protected storeSessionState(sessionState: string): void;\n    protected getSessionState(): string;\n    protected handleLoginError(options: LoginOptions, parts: object): void;\n    /**\n     * @ignore\n     */\n    processIdToken(idToken: string, accessToken: string, skipNonceCheck?: boolean): Promise<ParsedIdToken>;\n    /**\n     * Returns the received claims about the user.\n     */\n    getIdentityClaims(): object;\n    /**\n     * Returns the granted scopes from the server.\n     */\n    getGrantedScopes(): object;\n    /**\n     * Returns the current id_token.\n     */\n    getIdToken(): string;\n    protected padBase64(base64data: any): string;\n    /**\n     * Returns the current access_token.\n     */\n    getAccessToken(): string;\n    getRefreshToken(): string;\n    /**\n     * Returns the expiration date of the access_token\n     * as milliseconds since 1970.\n     */\n    getAccessTokenExpiration(): number;\n    protected getAccessTokenStoredAt(): number;\n    protected getIdTokenStoredAt(): number;\n    /**\n     * Returns the expiration date of the id_token\n     * as milliseconds since 1970.\n     */\n    getIdTokenExpiration(): number;\n    /**\n     * Checkes, whether there is a valid access_token.\n     */\n    hasValidAccessToken(): boolean;\n    /**\n     * Checks whether there is a valid id_token.\n     */\n    hasValidIdToken(): boolean;\n    /**\n     * Returns the auth-header that can be used\n     * to transmit the access_token to a service\n     */\n    authorizationHeader(): string;\n    /**\n     * Removes all tokens and logs the user out.\n     * If a logout url is configured, the user is\n     * redirected to it.\n     * @param noRedirectToLogoutUrl\n     */\n    logOut(noRedirectToLogoutUrl?: boolean): void;\n    /**\n     * @ignore\n     */\n    createAndSaveNonce(): Promise<string>;\n    /**\n     * @ignore\n     */\n    ngOnDestroy(): void;\n    protected createNonce(): Promise<string>;\n    protected checkAtHash(params: ValidationParams): Promise<boolean>;\n    protected checkSignature(params: ValidationParams): Promise<any>;\n    /**\n     * Start the implicit flow or the code flow,\n     * depending on your configuration.\n     */\n    initLoginFlow(additionalState?: string, params?: {}): void;\n    /**\n     * Starts the authorization code flow and redirects to user to\n     * the auth servers login url.\n     */\n    initCodeFlow(additionalState?: string, params?: {}): void;\n    private initCodeFlowInternal;\n    protected createChallangeVerifierPairForPKCE(): Promise<[string, string]>;\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiTA;"}